<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[初探electron]]></title>
    <url>%2F%E5%88%9D%E6%8E%A2electron%2F</url>
    <content type="text"><![CDATA[ElectronElectron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。Electron和nwjs其实是一个作者，中间的种种可以访问参考2来查看，很有意思的一件事。 渲染进程和主进程Electron 中，入口是一个 js 文件（和 NW.js 不同，入口是 html 文件），运行这个入口文件（通常会是 package.json 里的 main 脚本）的进程称作主进程，在主进程使用 BrowserWindow 模块可以创建并管理 web 页面，也就是应用的 GUI。 const {BrowserWindow} = require(&apos;electron&apos;) // 主进程创建web页面 let someWindow = new BrowserWindow(winOpts) // 加载本地的文件 someWindow.loadURL(&apos;file://&apos; + __dirname + &apos;/index.html&apos;) 在主进程创建的一个个web页面也都运行着自己的进程，即渲染进程，渲染进程各自独立，各自管理自己的页面，可以想象是浏览器一个个的 tab。 每个 BrowserWindow 实例都在自己的渲染进程里运行页面。 当一个 BrowserWindow 实例被销毁后，相应的渲染进程也会被终止。 进程间的通信Web 页面因为安全限制，不能直接访问原生的GUI资源（比如dialog、电源监控，通知栏等），Electron 中也是一样，渲染进程如果想要进行原生的GUI操作，就必须和主进程通讯，请求相应的GUI操作。 Electron 提供了几种渲染进程和主进程通信的方式： 第一种是使用ipcMain和ipcRenderer模块在渲染进程中使用ipcRender模块向主进程发送消息，主进程中ipcMain接收消息，进行操作，如果还需要反馈，则通知渲染进程，渲染进程根据接收的内容执行相应的操作： // 渲染进程中 const {ipcRenderer} = require(&apos;electron&apos;) ipcRender.send(&apos;somemsg&apos;, data); ipcRender.on(&apos;replaymsg&apos;, (evt, otherData) =&gt; { console.log(otherData) }) // 主进程中 const {ipcMain} = require(&apos;electron&apos;) ipcMain.on(&apos;somemsg&apos;, (evt, data) =&gt; { console.log(data) evt.sender.send(&apos;replymsg&apos;, otherData); }); // 同时Electron 也提供了同步的方式 不过切忌用 ipc 传递大量的数据，会有很大的性能问题，严重会让你整个应用卡住。 第二种是直接在渲染进程使用remote模块remote 模块可以直接获取主进程中的模块。这种方式其实是第一种方式的简化。 // 在渲染进程打开提示对话框 const {dialog} = require(&apos;electron&apos;).remote dialog.showMessageBox({ opts }); 第三种是主进程向渲染进程发送消息this.webviewWindow.webContents.send(&apos;ping&apos;); 第四种是渲染进程之间的通信最简单的方法是使用浏览器中已经实现的 HTML5 API。 其中比较好的方案是用 Storage API， localStorage，sessionStorage 或者 IndexedDB。 你还可以用 Electron 内的 IPC 机制实现。将数据存在主进程的某个全局变量中，然后在多个渲染进程中使用 remote 模块来访问它。 // 在主进程中 global.sharedObject = { someProperty: &apos;default value&apos; }Copy // 在第一个页面中 require(&apos;electron&apos;).remote.getGlobal(&apos;sharedObject&apos;).someProperty = &apos;new value&apos;Copy // 在第二个页面中 console.log(require(&apos;electron&apos;).remote.getGlobal(&apos;sharedObject&apos;).someProperty) Electron + Vue参考electron-vue，但是项目的Electron版本默认是2.x的版本，有点老，升级成了最新版（5.0.1），修改了一些配置，使其可以在高版本正常运行：electron-vue-demo。 但发现一个点，Electron将打包后的代码压缩加密为.asar文件，但是，这个加密文件是可以被解密的，开发electron-vue项目的同一个哥们，同时开源了一个可视化的解密工具：asar-explorer 但打包出来的包依旧有点大，打包后的文件中的node_modules 暂时还未找到合适方案合并到dist/electron/render.js中。 测试代码； 参考 Electron的应用结构 nwjs和Electron的创始人的知乎回答 我眼中的Electron]]></content>
      <tags>
        <tag>桌面应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cef wek electron nwjs和miniblink的简单介绍]]></title>
    <url>%2Fcef%20wek%20electron%20nwjs%E5%92%8Cminiblink%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[概述前端这两年的发展开始出现一个新的分支，PC桌面应用，类比移动端的混合开发，PC端的各种“壳子”也是百花齐放。我们来细数下这些年出现的相关内核 wkewke出现的比较早，wke 是一个基于 WebKit 精简的浏览器引擎，github上可以发现这个项目早在2013年左右已经停止更新了，同时有一个新的fork的github项目目前还在维护，同时介（吐）绍（槽）了原项目的相关发展。因为wke 是由 WebKit 2011 年的版本精简而来，之后一直没有同步 WebKit 更新过，因此 wke 对 HTML5 的支持能力停留在 2011 年，一直未改进。所以，bug很多，但是，体积很小!! cef（Chromium Embeded Framework）CEF的历史： CEF有两种版本的Chromium Embedded Framework：CEF 1和CEF 3 在Chromium Content API出现后，CEF 2的开发被放弃。 CEF 1是基于Chromium WebKit API的单进程实现。它不再积极发展或支持。 CEF 3是基于Chromium Content API的多进程实现，其性能类似于Google Chrome。 优点: 是由于集成的chromium内核，所以对H5支持的很全，同时因为使用的人也多，各种教程、示例，资源很多。 缺点: 最新的cef已经夸张到了100多M，不支持xp了（chromium对应版本是M49）。而且由于是多进程架构，对资源的消耗也很大。 nwjs 和 electron二者都是基于chromium内核，提供了一个能通过 JavaScript 和 HTML 创建桌面应用的平台，同时集成 Node 来授予网页访问底层系统的权限，所以支持性对前端友好。 功能上看，二者差不多，主要的区别是入口方式。Electron是基于node的，入口是类似node module的index.js，这是因为Electron是基于node的event-loop将chromium的功能和event全部整合app，Electron的开发跟其他的node应用没区别。NW.js像一个跑在node-platform上的浏览器，所以他的入口是index.html，NW.js将自己的功能都整合进了chromium-runtime，因此更接近一个前端的应用开发方式。NW.js也可以用到node的api，这是通过binding到chromium-runtime来调用的。 同时，nwjs支持xp，新版的electron已经不支持xp了。 安装包依旧比较大，且内存占用高居不下。 miniblinkminiblink是一个开源的、单文件、且目前已知的最小的基于chromium的，浏览器控件，主要就是把blink从chromium抽离了出来，同时补上了cc层（硬件渲染层）。github地址：https://github.com/weolar/miniblink49 缺点应该是，目前文档较少，遇到问题需要自己解决。 延伸浏览器内核知多少浏览器的内核是分为两个部分的：渲染引擎（layout engineer）或（Rendering Engine）和 JS 引擎。 渲染引擎：负责对网页语法的解释（HTML、javaScript、引入css等），并渲染（显示）网页。JS引擎：javaScript的解释、编译、执行。 最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于单指渲染引擎。 主流的内核有：Trident(IE)、Gecko(FireFox)、Webkit(Safari)、Presto(opera前内核、已废弃)、blink(Chrome)、edgehtml(IE Edge)PS:国内很多的双核浏览器的其中一核便是 Trident，美其名曰 “兼容模式”。 主流浏览器 内核 IE -&gt; Edge trident-&gt;EdgeHTML Chrome webkit-&gt;blink Safari webkit Firefox Gecko Opera Presto-&gt;blink 关于浏览器内核的纷争和发展，具体访问参考4即可。此处着重说下WebKit。 WebKitWebKit内核则是苹果基于KDE小组（Linux桌面系统）的 KHTML 引擎开发出来的，可以说 WebKit 是 KHTML 的一个开源的分支（感谢苹果当年弃用了Gecko）。webkit内核的轻便得到了谷歌的青睐，2008 年谷歌公司发布 chrome 浏览器，采用的 chromium 内核便 fork 了Webkit，同时，chrome将webkit内核发扬光大。 ChromiumChromium是谷歌为了研发Chrome而启动的项目，两者基于相同的源代码构建，Chrome所有的新功能都会先在Chromium上实现，待验证稳定后才会移植，因此Chromium的版本更新频率更高，也会包含很多新的功能，但作为一款独立的浏览器，Chromium的用户群体要小众得多。由于两款浏览器“同根同源”，因此它们有着同样的logo，只是配色不同。谷歌发布的 chrome 浏览器使用的内核被命名为 chromium。chromium 虽然是开源引擎webkit的一个分支，却把 WebKit 的代码梳理得可读性提高很多。也有很多人将chrome内核依旧称为webkit内核。 因为一些利益原因和项目问题（个人认为主要是利益原因），Google 决定从 WebKit 衍生出自己的 Blink 引擎。 BlinkBlink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支一样，Google 和 Opera Software 将共同研发该内核。自chrome 28开始，已经改用blink内核了。 JS引擎说起JS引擎，大家估计首先想到的就是V8，这是chrome内置的js解释器，同时万能的node也是基于V8开发的。 其实各大浏览器也有自己的js引擎，只是没有V8那么出名而已 主流浏览器 js引擎 IE EdgeJScript（IE3.0-IE8.0） / Chakra（IE9+之后，查克拉，微软也看火影么..） Chrome V8（大名鼎鼎） Safari Nitro（4-） Firefox SpiderMonkey（1.0-3.0）/ TraceMonkey（3.5-3.6）/ JaegerMonkey（4.0-）OperaLinear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-） Firefox SpiderMonkey（1.0-3.0）/ TraceMonkey（3.5-3.6）/ JaegerMonkey（4.0-）OperaLinear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-） UserAgent关于UserAgent其实它的发展更有趣，可以访问参考6。 参考 github之wke 屌炸天的内核来袭，史上最小chromium内核miniblink github之cef Electron 和 NW.js 在技术上的差异 全面了解浏览器（内核）发展史 浏览器野史 UserAgent列传 主流浏览器内核及JS引擎]]></content>
      <categories>
        <category>Chromium</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>闲话前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脚手架开发指南]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[何谓脚手架？在前端工程化高度发展的当代，各种构建工具大行其道，webpack、gulp、rollup、fis等，这些构建工具的主要作用就是将前端代码工程化，实现代码编译，文件优化，模块分割，自动刷新，代码校验，自动发布等供嫩，我们在实际开发中，要根据自己的需求定制不同的配置，但是多数情况下，项目配置在不同的项目中改动不大，有些甚至不需要做任何修改。这个时候，开发不同的项目，我们需要将这些配置重新拷贝一遍，于是，为了减少重复性工作，脚手架的概念应运而生。 对于vue-cli,create-react-app,或者自己开发的工具，脚手架的定位基本是一致的：创建项目初始文件，脚手架作用是：创建项目的初始文件，本质是方案的封装 编写一个脚手架基本流程考虑到模板项目可能需要经常更新，而脚手架可能更新不及时，所以我们通常不会将模板项目放到脚手架中，而是将其放在github（gitlab）上进行维护，项目创建时，拉取最新的代码，以保证最新创建的项目源码最新。下面是基本流程： 获取目录process.cwd() 是当前执行node命令时候的文件夹地址 ——工作目录，保证了文件在不同的目录下执行时，路径始终不变 __dirname 是被执行的js 文件的地址 ——文件所在目录 获取输入命令行参数const program = require(&apos;commander&apos;); console.log(program.args[0]) cli中交互式询问inquirer.prompt([{ type: &apos;input&apos;, message: &apos;请输入项目名称：&apos;, name: &apos;projectName&apos;, default: &quot;my-template-project&quot;, // 默认值 validate: function (val) { if (!val) { // 校验 return &quot;请输入有效项目名称！&quot;; } else { return true } } }, { type: &quot;confirm&quot;, message: &quot;是否使用监听？&quot;, name: &quot;watch&quot;, }, { type: &apos;list&apos;, message: &apos;请选择一种水果:&apos;, name: &apos;fruit&apos;, choices: [ &quot;Apple&quot;, &quot;Pear&quot;, &quot;Banana&quot; ], filter: function (val) { // 使用filter将回答变为小写 return val.toLowerCase(); } }, ]).then(result =&gt; { console.log(`你输入的项目名称是：${result.projectName}`) console.log(`你是否选择监听：${result.watch}`) console.log(`你选择的水果是：${result.fruit}`) }) 参考文章 小工具，大作用——前端脚手架开发指北 手把手教你写cli inquirer.js —— 一个用户与命令行交互的工具 不仅仅是复制粘贴 - 聊聊前端脚手架]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shim 和 polyfill]]></title>
    <url>%2Fshim%20%E5%92%8C%20polyfill%2F</url>
    <content type="text"><![CDATA[概述本文将介绍一下我们在各种项目中见到的 xx.shim.js 和 xx.polyfill.js，这两个文件命名各自有什么含义。 shimShim 指的是在一个旧的环境中模拟出一个新 API ，而且仅靠旧环境中已有的手段实现，以便所有的浏览器具有相同的行为。主要特征： 该 API 存在于现代浏览器中; 浏览器有各自的 API 或 可通过别的 API 实现; API 的所有方法都被重新实现； 拦截 API 调用，并提供自己的实现； 是一个优雅降级。 polyfillpolyfill 是一段代码(或者插件)，提供了那些开发者们希望浏览器原生提供支持的功能。程序库先检查浏览器是否支持某个API，如果不支持则加载对应的 polyfill。主要特征： 是一个浏览器 API 的 Shim; 与浏览器有关; 没有提供新的API，只是在 API 中实现缺少的功能; 以只需要引入 polyfill ，它会静静地工作; 二者区别shim 是一个库,将不同 api封装成一种，比如 jQuery的 $.ajax 封装了 XMLHttpRequest和 IE用ActiveXObject方式创建xhr对象, 它将一个新的 API 引入到一个旧的环境中,而且仅靠旧环境中已有的手段实现（没有遵循标准API规范，而是又实现了一套） polyfill也是一个js库，它的做法通常是:先检查浏览器是否支持某个标准 API,如果不支持,就使用旧的技术对浏览器做兼容处理,这样就可以在旧的浏览器上使用新的标准 API。(polyfill 是 shim 的一种,它的 API 是遵循标准的) 这是处理js兼容性问题的两种思路，都可以解决实际问题，但polyfill的设计思想更优秀，首先，不需要额外的学习成本（譬如学习$.ajax的写法），其次，后续浏览器支持标准API后，移除polyfill相关js库即可，不需要做任何其他改动。 参考 javascript术语shim 和 polyfill shim和polyfill]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端模块化进化史]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%BF%9B%E5%8C%96%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[概述历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。譬如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 、AMD 和 CMD 两种。CommonJS 用于服务器，AMD 和 CMD 用于浏览器，对应的实践分别为requireJs和seaJs。 1 CommonJS CommonJS 1.1 规范CommonJS也可以说是NodeJS的模块化规范，他是随着nodejs的出现而被制定的，Modules/1.0规范包含以下内容： 1. 模块的标识应遵循的规则（书写规范） 2. 定义全局函数require，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴漏出来的API 3. 如果被require函数引入的模块中也包含依赖，那么依次加载这些依赖 4. 如果引入模块失败，那么require函数应该报一个异常 5. 模块通过变量exports来向往暴漏API，exports只能是一个对象，暴漏的API须作为此对象的属性。 符合CommonJS规范的模块应该是这样： var react=require(./react.js);//引入模块 react.render();//使用模块 module.exports.x = x;//对外输出 其中： 【module】CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。 【module.exports】module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。 【exports】为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。 var exports = module.exports; 我们可以在export对象下挂载属性和方法： exports.area = function (r) { return Math.PI * r * r; }; exports.x = &quot;hello world&quot; 注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。 exports = function(){}//不要这样做！！！！ 同样对module.exports赋值的话，挂载在exports对象下的方法也无法输出了。保险简单起见都用module.exports即可！！ 1.2 利弊nodeJS主要是运行在服务端的，因此CommonJS的规范主要是针对服务器端环境，并不完全适用于浏览器环境，主要原因是：CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD和CMD 解决方案。 2 AMDAMD(Asynchronous Module Definition)即“异步的模块定义”，它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 2.1 规范模块定义 defined方法AMD就只有一个接口：define(id?,dependencies?,factory); define(&quot;modA&quot;, [&apos;package/lib&apos;], function(lib){ function foo(){ lib.log(&apos;hello world!&apos;); } //dependencies参数加载依赖，[&apos;package/lib&apos;] //factory函数的形参调用依赖，function(lib){} return { foo: foo //通过return对外输出 }; }); AMD规范也允许输出的模块兼容CommonJS规范，这时define方法需要写成下面这样： define(function (require, exports, module){ //加载依赖模块 var someModule = require(&quot;someModule&quot;); var anotherModule = require(&quot;anotherModule&quot;); //调用模块 someModule.doTehAwesome(); anotherModule.doMoarAwesome(); //对外输出 exports.asplode = function (){ someModule.doTehAwesome(); anotherModule.doMoarAwesome(); }; }); 主模块入口（require加载）require(dependencies?,callback?) dependencies:所依赖的模块（可选）：该模块名称可以是模块的路径（不要加’.js’）,也可以是require.config中配置的模块别名，但对于有主模块（就是定义了模块ID），paths中的别名必须和模块ID相同。 callback 回调函数：参数名可以自定义。一般和依赖模块名中写入的相同。 例如： require([&apos;pkg/index/index_common_homepage&apos;], function(index_common_homepage) { console.log(&apos;pkg index_common_homepage called&apos;) }); 2.2 利弊AMD规范会将所有的依赖模块预先下载，预先下载没什么争议，由于浏览器的环境特点，被依赖的模块肯定要预先下载的。问题在于，模块也被预先解析和执行了。如果一个模块依赖了十个其他模块，那么在本模块的代码执行之前，要先把其他十个模块的代码都执行一遍，无论该模块是否用到。这个性能消耗是不容忽视的。而CMD规范就很好的避开了这个问题。 3 CMDCMD（Common Module Definition）也称“通用的模块定义”，和CommonJS保持了更好的兼容性。 3.1 规范定义模块定义 defined方法define(function(require, exports, module){ //code }） 三个形参，不可更改，与commonJS是对应的 define(function(require, exports, module){ //加载依赖模块 var mod = require(&quot;./mod.js&quot;); //调用模块 var nums=mod.add(); //对外输出，两种方式 //方式1： return { nums:nums } //方式2： module.exports.nums=nums; }） 主模块入口（sea.use加载）seajs.use(&quot;main&quot;,function(ex){ console.log(ex.num); }); 3.2利弊 CMD可以做到按需加载，定义一个模块的时候不需要立即制定依赖模块，在需要的时候require就可以了，比较方便； CMD定义模块时无需罗列依赖数组，在factory函数中需传入形参require,exports,module，然后它会调用factory函数的toString方法，对函数的内容进行正则匹配，通过匹配到的require语句来分析依赖，这样就真正实现了commonJS风格的代码。 4 AMD VS CMD AMD 推崇依赖前置, 代码在一旦运行到此处，能立即知晓依赖。而无需遍历整个函数体找到它的依赖，因此性能有所提升，缺点就是开发者必须显式得指明依赖——这会使得开发工作量变大，比如：当依赖项有n个时候 那么写起来比较烦 且容易出错。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。 执行顺序上：CMD是延迟执行的，而AMD是提前执行的。 api设计角度：AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。 5 ES6ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。 5.1 规范定义ES6 中新增了两个命令 import 和 export import 命令用于输入其他模块提供的功能 export 命令用于规定模块的对外接口 ES6 中的模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 //加载依赖模块 import {deviceInfo, cookie,} from &quot;../lib/util.js&quot;; //调用模块，对外输出 export var cookie_spm = cookie.get(&apos;spm&apos;) || &quot;&quot;; //对外输出 export function(){ //code.. } 5.2 利弊ES6 的模块是编译时加载，效率要比 CommonJS 模块的加载方式高。 参考文献 CommonJS规范 阮一峰 ES6 Module 的语法]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
      </tags>
  </entry>
</search>
