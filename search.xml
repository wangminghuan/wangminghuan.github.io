<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ArrayBuffer TypedArray和DataView</title>
    <url>/ArrayBuffer%20TypedArray%E5%92%8CDataView/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ArrayBuffer对象、TypedArray视图和DataView视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。</p>
<p>这个接口的原始设计目的，与 WebGL 项目有关。浏览器与显卡之间的大量通信都是通过二进制数据完成的，而传统的文本格式是32位整数，为了解决数据转化的效率低下问题，使得二者可以直接通过二进制进行通信，二进制数组就是在这种背景下诞生的。它很像 C 语言的数组，允许开发者以数组下标的形式，直接操作内存。</p>
<span id="more"></span>

<h2 id="二进制数组的组成"><a href="#二进制数组的组成" class="headerlink" title="二进制数组的组成"></a>二进制数组的组成</h2><p>由三类对象组成：  </p>
<ul>
<li><p>ArrayBuffer对象：代表内存之中的一段二进制数据，可以存放多种类型的数据。不同数据有不同的存储方式，这就叫做“视图”。可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。</p>
</li>
<li><p>TypedArray视图：共包括 9 种类型的视图，比如Uint8Array（无符号 8 位整数）数组视图, Int16Array（16 位整数）数组视图, Float32Array（32 位浮点数）数组视图等等。</p>
</li>
<li><p>DataView视图：可以自定义复合格式的视图，比如第一个字节是 Uint8（无符号 8 位整数）、第二、三个字节是 Int16（16 位整数）、第四个字节开始是 Float32（32 位浮点数）等等，此外还可以自定义字节序。</p>
</li>
</ul>
<p>简单说，ArrayBuffer对象代表原始的二进制数据，TypedArray视图用来读写简单类型的二进制数据，DataView视图用来读写复杂类型的二进制数据</p>
<h3 id="ArrayBuffer-对象"><a href="#ArrayBuffer-对象" class="headerlink" title="ArrayBuffer 对象"></a>ArrayBuffer 对象</h3><p>ArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。</p>
<p>ArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。</p>
<p><img src="1.png"></p>
<p>可以看到，ArrayBuffer构造函数的参数是所需要的内存大小（单位字节）。</p>
<h3 id="TypedArray-视图"><a href="#TypedArray-视图" class="headerlink" title="TypedArray 视图"></a>TypedArray 视图</h3><p>TypedArray视图一共包括 9 种类型，每一种视图都是一种构造函数（接受一个ArrayBuffer对象作为参数）: </p>
<ul>
<li>Int8Array：8 位有符号整数，长度 1 个字节。</li>
<li>Uint8Array：8 位无符号整数，长度 1 个字节。</li>
<li>Uint8ClampedArray：8 位无符号整数，长度 1 个字节，溢出处理不同。</li>
<li>Int16Array：16 位有符号整数，长度 2 个字节。</li>
<li>Uint16Array：16 位无符号整数，长度 2 个字节。</li>
<li>Int32Array：32 位有符号整数，长度 4 个字节。</li>
<li>Uint32Array：32 位无符号整数，长度 4 个字节。</li>
<li>Float32Array：32 位浮点数，长度 4 个字节。</li>
<li>Float64Array：64 位浮点数，长度 8 个字节。</li>
</ul>
<p>这 9 个构造函数生成的数组，统称为TypedArray视图。它们很像普通数组，都有length属性，都能用方括号运算符（[]）获取单个元素，所有数组的方法，在它们上面都能使用。普通数组与 TypedArray 数组的差异主要在以下方面: </p>
<ul>
<li>TypedArray 数组的所有成员，都是同一种类型。</li>
<li>TypedArray 数组的成员是连续的，不会有空位。</li>
<li>TypedArray 数组成员的默认值为 0。比如，new Array(10)返回一个普通数组，里面没有任何成员，只是 10 个空位；new Uint8Array(10)返回一个 TypedArray 数组，里面 10 个成员都是 0。</li>
<li>TypedArray 数组只是一层视图，本身不储存数据，它的数据都储存在底层的ArrayBuffer对象之中，要获取底层对象必须使用buffer属性。</li>
</ul>
<p>譬如我们读取一个文件（文本文件）的二进制数据</p>
<pre><code>  document.getElementById(&quot;select-file&quot;).addEventListener(&quot;change&quot;,(e)=&gt;&#123;
        const files=e.target.files[0];
        let fileReader = new FileReader();
        fileReader.readAsArrayBuffer(files)
        fileReader.onload = function () &#123;
              let arrayBuffer = this.result;
              console.log(arrayBuffer)
              let uInt8data=new Uint8Array(arrayBuffer);
              console.log(uInt8data)
              console.log(uInt8data.buffer)
        &#125;
  &#125;)
</code></pre>
<p>结果如下：</p>
<p><img src="2.png"></p>
<h3 id="DataView-视图"><a href="#DataView-视图" class="headerlink" title="DataView 视图"></a>DataView 视图</h3><p>DataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。</p>
<p>DataView视图支持的类型共8种，除不支持 Uint8ClampedArray 类型外，其他与TypedArray视图相同</p>
<h3 id="ArrayBuffer-与字符串的互相转换"><a href="#ArrayBuffer-与字符串的互相转换" class="headerlink" title="ArrayBuffer 与字符串的互相转换"></a>ArrayBuffer 与字符串的互相转换</h3><p>ArrayBuffer 和字符串的相互转换，使用原生 TextEncoder 和 TextDecoder 方法:</p>
<pre><code>  function arrayBufferToString(buffer)&#123;
    const decoder = new TextDecoder(&#39;utf8&#39;)
    return decoder.decode(buffer);//ArrayBuffer | Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array,
  &#125;
  function stringToArrayBuffer(input)&#123;
    const encoder = new TextEncoder()
    const view = encoder.encode(input);//string
    return view.buffer;
  &#125;
</code></pre>
<p>我们转换上一步得到的文本文件，结果如下：</p>
<p><img src="3.png"></p>
<p>可以看到通过转换我们可以读取到文件中的内容（文本文件），而对于非utf8编码方式文件，得到的则是乱码。</p>
<p>对于ArrayBuffer TypedArray 和DataView 更详细的用法可以参考阮一峰的ES6教程（参考文章1）</p>
<h2 id="二进制数组的应用"><a href="#二进制数组的应用" class="headerlink" title="二进制数组的应用"></a>二进制数组的应用</h2><p>大量的 Web API 用到了ArrayBuffer对象和它的视图对象。</p>
<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>XHR第一版，服务器通过 AJAX 操作只能返回文本数据，即responseType属性默认为text。XMLHttpRequest第二版XHR2允许服务器返回二进制数据，这时分成两种情况。如果明确知道返回的二进制数据类型，可以把返回类型（responseType）设为arraybuffer：</p>
<pre><code> let xhr = new XMLHttpRequest();
  xhr.open(&#39;GET&#39;, &quot;http://minghuan-image.test.upcdn.net/test/zeus-3.0.txt&quot;);
  xhr.responseType = &#39;arraybuffer&#39;;

  xhr.onload = function () &#123;
    let arrayBuffer = xhr.response;
    console.log(arrayBuffer)
  &#125;;

  xhr.send();
</code></pre>
<p>运行结果：<br><img src="4.png"></p>
<p>responseType支持以下几个参数：</p>
<ul>
<li>arraybuffer:    ArrayBuffer对象</li>
<li>blob:    Blob对象</li>
<li>document:    Document对象</li>
<li>json: JS 对象，解析得到的从服务器返回来的JSON字符串</li>
<li>text:    DOMString(默认)</li>
</ul>
<h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><p>之前文章<a href="https://blog.mhwang.club/Fetch-and-XMLHttpRequest/">Fetch-and-XMLHttpRequest</a>中有提到过：Fetch得到的Response 下共有5个方法，其中包含arrayBuffer方法，所以通过Fetch也可以得到ArrayBuffer数据:</p>
<pre><code> fetch(&quot;http://minghuan-image.test.upcdn.net/test/zeus-3.0.txt&quot;).then((res)=&gt;&#123;
    return  res.arrayBuffer()
  &#125;).then((data)=&gt;&#123;
    console.log(data)
  &#125;)
</code></pre>
<p>运行结果：</p>
<p><img src="4.png"></p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>开发中遇到一个接口上传，不同于常规接受FormData，接口只接受二进制数据，代码如下：</p>
<p>input表单</p>
<pre><code>  &lt;input type=&quot;file&quot; @change=&quot;handleChange&quot;&gt;
</code></pre>
<p>监听变化完成上传：</p>
<pre><code>  handleChange (e) &#123;
        const files = e.target.files[0];
        var fileReader = new FileReader();
        fileReader.readAsArrayBuffer(files);
        fileReader.onload = function () &#123;
          const _buffer = (this.result)
          fetch(&quot;http://xxx/upload&quot;, &#123;
            body: _buffer,
            method: &#39;POST&#39;,
          &#125;).then((res) =&gt; &#123;
            return res.json()
          &#125;).then((data) =&gt; &#123;
            console.log(data)
          &#125;)
        &#125;
      &#125;
</code></pre>
<p>执行成功时的请求与返回截图如下:</p>
<p><img src="upload1.jpg"><br><img src="upload2.jpg"></p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket可以通过ArrayBuffer，发送或接收二进制数据。</p>
<pre><code>let socket = new WebSocket(&#39;ws://127.0.0.1:8081&#39;);
socket.binaryType = &#39;arraybuffer&#39;;

// Wait until socket is open
socket.addEventListener(&#39;open&#39;, function (event) &#123;
  // Send binary data
  const typedArray = new Uint8Array(4);
  socket.send(typedArray.buffer);
&#125;);

// Receive binary data
socket.addEventListener(&#39;message&#39;, function (event) &#123;
  const arrayBuffer = event.data;
  // ···
&#125;);
</code></pre>
<h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p>网页Canvas元素输出的二进制像素数据，就是 TypedArray 数组</p>
<pre><code>const canvas = document.getElementById(&#39;myCanvas&#39;);
const ctx = canvas.getContext(&#39;2d&#39;);
const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
const uint8ClampedArray = imageData.data;
console.log(uint8ClampedArray)
</code></pre>
<p>运行结果：</p>
<p><img src="5.png"></p>
<p>可以看到，它的视图类型是一种针对Canvas元素的专有类型Uint8ClampedArray。这个视图类型的特点，就是专门针对颜色，把每个字节解读为无符号的 8 位整数，即只能取值 0 ～ 255，而且发生运算的时候自动过滤高位溢出。这为图像处理带来了巨大的方便。</p>
<h3 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h3><p>在本文第二部分涉及到的二进制数据，均为File API得到的，实际上我们读取文件后，通过内置的reader.readAsArrayBuffer方法可以轻易将文件转化为ArrayBuffer, 然后可以在此基础上做其他二进制操作。</p>
<h3 id="SharedArrayBuffer-和-Atomics-对象"><a href="#SharedArrayBuffer-和-Atomics-对象" class="headerlink" title="SharedArrayBuffer 和 Atomics 对象"></a>SharedArrayBuffer 和 Atomics 对象</h3><p>日常用到的不多，本文不做表述，具体可访问参考文章1</p>
<h2 id="Blob对象"><a href="#Blob对象" class="headerlink" title="Blob对象"></a>Blob对象</h2><p>Blob(Binary Large Object 二进制大对象)术语最初来自数据库，早期数据库因为要存储声音、图片、以及可执行程序等二进制数据对象所以给该类对象取名为Blob。 在Web领域，Blob被定义为包含只读数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>Blob() 构造函数返回一个新的 Blob 对象：</p>
<p><code>new Blob( array, options )</code></p>
<ul>
<li><p>array 是一个由ArrayBuffer, ArrayBufferView, Blob, DOMString 等对象构成的 Array ，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings会被编码为UTF-8。</p>
</li>
<li><p>options 是一个可选的BlobPropertyBag字典，它可能会指定如下两个属性：<br>type，默认值为 “”，它代表了将会被放入到blob中的数组内容的MIME类型。<br>endings，默认值为”transparent”，用于指定包含行结束符\n的字符串如何被写入。它是以下两个值中的一个：”native”，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 “transparent”，代表会保持blob中保存的结束符不变。</p>
<pre><code>var debug = &#123;hello: &quot;world&quot;&#125;;
var blob = new Blob([JSON.stringify(debug, null, 2)], &#123;type : &#39;application/json&#39;&#125;);
console.log(blob)
</code></pre>
</li>
</ul>
<p>我们也可以将本地选取的音频，直接转化为url在页面中播放</p>
<p> input表单与audio控件</p>
<pre><code>  &lt;input type=&quot;file&quot; @change=&quot;handleChange&quot;&gt;
  &lt;audio :src=&quot;blobUrl&quot; controls=&quot;controls&quot;&gt;&lt;/audio&gt;
</code></pre>
<p><img src="audio1.jpg"></p>
<p>方式一：通过FileReader读取文件，获取文件二进制数据，传入Blob对象，创建blob实例，创建URL：</p>
<pre><code>  handleChange (e) &#123;
      const target=e.target.files[0]
      const fileReader = new FileReader();
      fileReader.readAsArrayBuffer(target);
      fileReader.onload = () =&gt; &#123;
        const arrayBuffer = fileReader.result;
        const unit8=new Uint8Array(arrayBuffer)
        let _blob = new Blob([unit8],&#123;
          type: &#39;audio/mp3&#39; 
        &#125;)
      this.blobUrl = URL.createObjectURL(_blob);
    &#125;
  &#125;
</code></pre>
<p>方式二：直接将文件传入<code>URL.createObjectURL</code>中,生成URL</p>
<pre><code>  handleChange (e) &#123;
    const target=e.target.files[0]
    this.blobUrl = URL.createObjectURL(target);
  &#125;
</code></pre>
<p><img src="audio2.jpg"></p>
<h2 id="File对象"><a href="#File对象" class="headerlink" title="File对象"></a>File对象</h2><p>文件（File）接口提供有关文件的信息，并允许网页中的 JavaScript 访问其内容。</p>
<p>通常情况下， File 对象是来自用户在一个 <code>&lt;input&gt;</code> 元素上选择文件后返回的 FileList 对象,也可以是来自由拖放操作生成的 DataTransfer 对象，或者来自 HTMLCanvasElement 上的 mozGetAsFile() API。在Gecko中，特权代码可以创建代表任何本地文件的File对象，而无需用户交互。</p>
<p>File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的 context 中：比如说， </p>
<ul>
<li>FileReader()</li>
<li>URL.createObjectURL()</li>
<li>createImageBitmap()</li>
<li>XMLHttpRequest.send() </li>
</ul>
<p>都可以接收 Blob 或 File 对象来进行对应处理。</p>
<p>从Blob中读取内容的唯一方法是使用 FileReader(具体使用参照5.1介绍):</p>
<pre><code>  var reader = new FileReader();
  reader.readAsArrayBuffer(blob);
  reader.onload = function (e) &#123;
    let arrayBuffer = e.target.result;
    console.log(arrayBuffer)
  &#125;
</code></pre>
<p>运行结果：</p>
<p><img src="6.png"> </p>
<h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p>FileReader对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。</p>
<p>它有一下几个方法：</p>
<ul>
<li>FileReader.abort()：中止读取操作。在返回时，readyState属性为DONE。</li>
<li>FileReader.readAsArrayBuffer()：开始读取指定的 Blob中的内容, 一旦完成, result 属性中保存的将是被读取文件的 ArrayBuffer 数据对象.</li>
<li>FileReader.readAsBinaryString()：开始读取指定的Blob中的内容。一旦完成，result属性中将包含所读取文件的原始二进制数据。</li>
<li>FileReader.readAsDataURL()：开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容。</li>
<li>FileReader.readAsText()：开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个字符串以表示所读取的文件内容。</li>
</ul>
<h3 id="URL-createObjectURL"><a href="#URL-createObjectURL" class="headerlink" title="URL.createObjectURL"></a>URL.createObjectURL</h3><p>URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL，该对象表示指定的 File 对象或 Blob 对象。</p>
<p>得到的URL字符串可以用在html的任何可以使用url的地方，比如img的src ; audio/video的src和source标签等。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="http://es6.ruanyifeng.com/#docs/arraybuffer">阮一峰 ECMAScript 6 入门 之 ArrayBuffer</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob">MDN文档- Blob</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File">MDN文档- File</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>二进制数据</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3中的var</title>
    <url>/CSS3%E4%B8%AD%E7%9A%84var/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>CSS3中增加了变量函数var, 当然这些变量在less/sass等css预编译语言中早有实现，CSS标准也已经支持，并且也有着不错的兼容性：</p>
<span id="more"></span>
<p><img src="./1.png"></p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>var的标注语法如下</p>
<pre><code>var( &lt;custom-property-name&gt; [, &lt;declaration-value&gt; ]? ) // var( &lt;自定义属性名&gt; [, &lt;默认值 ]? )
</code></pre>
<p>代码展示</p>
<pre><code>:root&#123;
  --blue:#2196f3;
&#125;
.box&#123;
  --size:20px;
  background-color: var(--blue);
  font-size: var(--size);
&#125;
</code></pre>
<p>放在root下即为全局变量，在选择器的声明块内就只在当前块区域有效。</p>
<p>我们利用这个属性实现一个简单的换肤功能，代码如下：</p>
<pre><code>  &lt;!-- css部分 --&gt;
    &lt;style&gt;
      /* 变量全局使用 */
    :root&#123;
      --blue:#2196f3;
      --red:#fc3737;
      --grey:#CCC;
      --myColor:var(--blue);
    &#125;
    .content&#123;
      padding: 30px;
    &#125;
    .box&#123;
      width: 200px;
      height: 200px;
      background-color: var(--myColor);
      margin-top:20px
    &#125;
    &lt;/style&gt;
    &lt;body&gt;
    &lt;!-- HTML部分 --&gt;
    &lt;div class=&quot;content&quot;&gt;
      &lt;div class=&quot;btn-box&quot;&gt;
        &lt;button class=&quot;btn&quot; data-color=&quot;red&quot; style=&quot;color:var(--red)&quot;&gt;更换背景色1&lt;/button&gt;
        &lt;button class=&quot;btn&quot; data-color=&quot;blue&quot; style=&quot;color:var(--blue)&quot;&gt;更换背景色2&lt;/button&gt;
        &lt;button class=&quot;btn&quot; data-color=&quot;grey&quot; style=&quot;color:var(--grey)&quot;&gt;更换背景色3&lt;/button&gt;
      &lt;/div&gt;
      &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
      const $root= document.querySelector(&#39;:root&#39;);//document.querySelector(&#39;:root&#39;) === document.documentElement
      const $btnBox= document.querySelector(&quot;.btn-box&quot;)
      $btnBox.addEventListener(&quot;click&quot;,(e)=&gt;&#123;
        const target=e.target;
        const color=target.getAttribute(&quot;data-color&quot;)
        if(color)&#123;
          const colorVal=getComputedStyle($root).getPropertyValue(&#39;--&#39;+color)
          $root.style.setProperty(&#39;--myColor&#39;, colorVal);
        &#125;
      &#125;)
    &lt;/script&gt;
  &lt;/body&gt;
</code></pre>
<p>上述代码中有js检测控制变量的部分，效果如下</p>
<p>  <img src="./2.gif"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="空格问题"><a href="#空格问题" class="headerlink" title="空格问题"></a>空格问题</h3><p>因为CSS变量的空格尾随特性，也就是每个变量解析完自动追加一个空格</p>
<pre><code>  .box&#123;
    --border-px:2px;
    --size:20;
    border:var(--border-px)solid black;
    font-size: var(--size)px;
  &#125;
</code></pre>
<p>等同于</p>
<pre><code>.box&#123;
    border:2px solid black;
    font-size: 20 px;
  &#125;
</code></pre>
<p>所以font-size部分的值不会生效，我们可以利用calc函数再进行一次计算</p>
<pre><code>.box&#123;
    --border-px:2px;
    --size:20;
    border:var(--border-px)solid black;
    font-size: calc(var(--size) * 1px);
  &#125;
</code></pre>
<h3 id="默认值问题"><a href="#默认值问题" class="headerlink" title="默认值问题"></a>默认值问题</h3><p>对于上述语法中的默认值，有一个非常有意思的一个点：对于CSS变量，只要语法是正确的，就算变量里面的值是个乱七八糟的东西，也是会作为正常的声明解析，如果发现变量值是不合法的，也不会取后面的默认值，会使用该属性的缺省值进行计算：</p>
<pre><code> .box&#123;
    --size:#000;
    font-size: var(--size,20px);
  &#125;
</code></pre>
<p>fontSize的值不是20px,而是默认继承了body的默认值，只有当变量–size不存在时，才会得到20px</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.zhangxinxu.com/wordpress/2016/11/css-css3-variables-var/">小tips:了解CSS变量var</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/var()">MDN- var()</a></li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>var</tag>
      </tags>
  </entry>
  <entry>
    <title>Canvas获取视频封面与添加水印</title>
    <url>/Canvas%E8%8E%B7%E5%8F%96%E8%A7%86%E9%A2%91%E5%B0%81%E9%9D%A2%E4%B8%8E%E6%B7%BB%E5%8A%A0%E6%B0%B4%E5%8D%B0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在实际工作中，会遇到一类似获取视频封面等需求，当然，这个工作无需前端也能实现，但前端也能跨界救场，因为前端代码都运行在用户端，在机器性能过剩的情况下，前端可以实现这些类似功能来减少服务器的压力，同时有时也能获取更好的用户体验。当然，这些功能的核心都是基于Canvas实现的。</p>
<span id="more"></span>
<h2 id="图片添加水印"><a href="#图片添加水印" class="headerlink" title="图片添加水印"></a>图片添加水印</h2><p>这个在各家产品经常看到，现在我们来通过前端实现水印功能，假定我们通过input来将用户选择的图片添加水印，首先，需要将Bolb对象转为img对象</p>
<pre><code>  /*
  @ desc bolb对象转image
  */
  function blobToImg(blob) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
      let reader = new FileReader()
      reader.addEventListener(&#39;load&#39;, () =&gt; &#123;
        let img = new Image()
        img.src = reader.result
        img.addEventListener(&#39;load&#39;, () =&gt; resolve(img))
      &#125;)
      reader.readAsDataURL(blob)
    &#125;)
  &#125;
</code></pre>
<p>接着，我们将得到的img对象转为canvas</p>
<pre><code>  /*
  @ desc domObj转canvas
  */
  function imgToCanvas(&#123;
    obj,
    width,
    height
  &#125;) &#123;
    const canvas = document.createElement(&#39;canvas&#39;);
    canvas.setAttribute(&#39;width&#39;, width);
    canvas.setAttribute(&#39;height&#39;, height);
    const ctx = canvas.getContext(&quot;2d&quot;);
    ctx.drawImage(obj, 0, 0) // obj可以是任意dom對象
    return canvas
  &#125;
</code></pre>
<p>現在开始进入关键功能：在canvas对象中添加水印</p>
<pre><code>  /*
  @ desc 生成水印
  */
  function watermark(canvas, text) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
      const ctx = canvas.getContext(&#39;2d&#39;)
      ctx.textAlign = &#39;right&#39;;
      ctx.textBaseline = &#39;middle&#39;,
      ctx.font = &quot;14px Microsoft Yahei&quot;,
      ctx.fillStyle = &#39;rgba(0, 0, 0, 0.6)&#39;,
      ctx.fillText(text, canvas.width - 20, canvas.height - 20); // 生成文本的坐标
      canvas.toBlob(blob =&gt; resolve(blob))
      // 此处也可以直接通过canvas输出base64: canvas.toDataURL(&#39;image/png&#39;, &#39;0.5&#39;);
    &#125;)
  &#125;
</code></pre>
<p>最后我们将得到的bolb对象再次调用<code>blobToImg</code>方法得到最终的带水印图片。</p>
<h2 id="获取视频首帧作为封面"><a href="#获取视频首帧作为封面" class="headerlink" title="获取视频首帧作为封面"></a>获取视频首帧作为封面</h2><p>我们通过视频地址创建一个video对象，同时监听timeupdate事件（播放位置发生改变时触发）</p>
<pre><code>/*
@ desc 初始化视频对象，监听事件变化
*/
function initVideo(url, callback) &#123;
  const video = document.createElement(&#39;video&#39;)
  video.src = url;
  video.controls = true;
  //必须要设置 video 的 crossOrigin = &#39;Anonymous&#39;，对此元素的 CORS 请求将不设置凭据标志。否则无法调用toDataURL，会提示画布被污染
  video.crossOrigin = &quot;Anonymous&quot;; 
  video.addEventListener(&quot;timeupdate&quot;, () =&gt; &#123;
    const imgBase64 = getVideoCapture(video);
    callback &amp;&amp; callback(imgBase64)
  &#125;)
  return video
&#125;
</code></pre>
<p>timeupdate事件触发时将videDom转为Canvas对象，并得到base64（调用了上面的imgToCanvas方法）</p>
<pre><code>  /*
  @ desc 获取video对象对应帧率base64
  */
  function getVideoCapture(video)&#123;
    let canvas = imgToCanvas(&#123;
        obj: video,
        width: video.videoWidth,
        height: video.videoHeight
      &#125;)
    return canvas.toDataURL(&#39;image/png&#39;, &#39;0.5&#39;);
  &#125;
</code></pre>
<p>将得到的base64渲染到img标签内即可。</p>
<h2 id="base64图片下载到本地"><a href="#base64图片下载到本地" class="headerlink" title="base64图片下载到本地"></a>base64图片下载到本地</h2><p>我们对上面的功能再添加一个保存到本地的功能，首先需要将base64图片转成Bolb对象：</p>
<pre><code>  /*
  @ desc base64转Bolb对象
  */
  function base64ToBlob(code)&#123;
    let parts = code.split(&quot;;base64,&quot;);
    // 获取图片类型
    let contentType = parts[0].split(&quot;:&quot;)[1];
    /**
    * 解码base64
    * Window atob() 方法
    * encodedStr: 必需，是一个通过 btoa() 方法编码的字符串。
    * 该方法返回一个解码的字符串。
    */
    let raw = window.atob(parts[1]);
    let rawLength = raw.length;
    const uInt8Array= new Uint8Array(rawLength)
    // 将字符转换成unicode值
    for (let i = 0; i &lt; rawLength; ++i) &#123;
      uInt8Array[i] = raw.charCodeAt(i);
    &#125;
    return new Blob([uInt8Array], &#123;type : contentType&#125;);
  &#125;
</code></pre>
<p>接着创建可下载文件的a标签并且触发（download属性）</p>
<pre><code>/*
@ desc 保存base64图片到本地
*/
function downFile(code)&#123;
  if (!code)  return alert(&quot;base64不能为空&quot;);
  const fileName = Date.now();
  let aLink = document.createElement(&quot;a&quot;);
  let blob = base64ToBlob(code);
  let evt = document.createEvent(&quot;HTMLEvents&quot;);
  evt.initEvent(&quot;click&quot;, true, true); //initEvent 不加后两个参数在FF下会报错  事件类型，是否冒泡，是否阻止浏览器的默认行为
  aLink.download = fileName;
  aLink.href = URL.createObjectURL(blob);
  aLink.click();
&#125;
</code></pre>
<h2 id="其他：各种转换"><a href="#其他：各种转换" class="headerlink" title="其他：各种转换"></a>其他：各种转换</h2><p><img src="./1.png"></p>
<p>更详细的版本</p>
<p><img src="./2.png"></p>
<p>更详细的demo可参考<a href="https://github.com/wangminghuan/graphics-project/blob/master/demo1-canvas/video.html">graphics-project:demo1-canvas</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/iBc5kBDJvc7qDBQQsACEIQ">【附源码】跨界救场：如何用纯前端的方式获取视频首帧</a></li>
<li><a href="https://mp.weixin.qq.com/s/O_zKQviNcW4c4Uz2zfqAhg">前端利用canvas给图片添加水印</a></li>
<li><a href="https://blog.csdn.net/fesfsefgs/article/details/109553759">js中url、base64、blob、字符串等相互转换方法</a></li>
</ul>
]]></content>
      <categories>
        <category>图形图像</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列-1-命名与解构赋值</title>
    <url>/ES6%E7%B3%BB%E5%88%97-1-%E5%91%BD%E5%90%8D%E4%B8%8E%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<p>本篇主要介绍ES6新增的命名方式：let/const ，与解构赋值。</p>
<span id="more"></span>

<h2 id="第一章-let和const"><a href="#第一章-let和const" class="headerlink" title="第一章 let和const"></a>第一章 let和const</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ol>
<li><p>ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的<strong>代码块内有效</strong>。也就是其声明的变量就绑定在这个区域中，不会再受到外界影响。</p>
<pre><code> &#123;
   let a = 10;
   var b = 1;
 &#125;
 console.log(b);//1
 console.log(a);//报错: a is not defined.
</code></pre>
<p>例子2：</p>
<pre><code> for (let i = 0; i &lt; 3; i++) &#123;
   let i = 100;
   console.log(i);
 &#125;
 //输出 三次100，说明循环体内部是一个单独的作用域，如果换成var,则只会输出一次100。
</code></pre>
<p>特别对于for循环绑定事件获取索引问题可以很好的解决<a href="https://github.com/wangminghuan/MyNotes/blob/master/%E5%85%B6%E4%BB%96/for%E5%BE%AA%E7%8E%AF%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E8%8E%B7%E5%8F%96%E7%B4%A2%E5%BC%95%E9%97%AE%E9%A2%98.md">点我了解更多</a></p>
</li>
<li><p>ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
</li>
<li><p>let声明，一个代码块内不可重复声明，否则会报错，而var命名则不会。</p>
<pre><code> function func(arg) &#123;
   let arg; // 报错
 &#125;
 
 function func(arg) &#123;
   &#123;
     let arg; // 不报错
   &#125;
 &#125;
</code></pre>
</li>
</ol>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ol>
<li><p>const声明一个只读的常量。一旦声明，常量的值就不能改变, </p>
</li>
<li><p>const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
</li>
<li><p>const如果赋值一个对象时，保存的只是一个指向实际数据的指针</p>
<pre><code> const obj=&#123;&#125;;
 obj.name=&quot;123&quot;;//可以修改指针指向对象的数据
 obj=null；//报错！，不可修改指针的指向
</code></pre>
</li>
</ol>
<h3 id="顶层对象属性"><a href="#顶层对象属性" class="headerlink" title="顶层对象属性"></a>顶层对象属性</h3><p>ES5中顶层对象的属性与全局变量挂钩，这也被认为是js语言设计最大的败笔之一，各种命名冲突，很多只有在运行过程中才被暴露出来。</p>
<pre><code>let a=1;
var b=2;
const c=3;
console.log(window.a);//undefined
console.log(window.b);//2
console.log(window.c);//undefined
</code></pre>
<p>目前在ES6中顶层对象依旧没有统一。</p>
<ol>
<li>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。</li>
<li>浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。</li>
<li>Node 里面，顶层对象是global，但其他环境都不支持。</li>
</ol>
<h3 id="变量声明的六种方式"><a href="#变量声明的六种方式" class="headerlink" title="变量声明的六种方式"></a>变量声明的六种方式</h3><p>待补充~</p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><ol>
<li>es6 支持通过 <code>&#123;&#125;</code>（花括号）创建块级作用域</li>
<li>es6 允许块级作用域的任意嵌套，外层作用域无法读取内层作用域的变量。</li>
<li>es5的块级作用域一般通过自执行函数（IIFE）来创建，块级作用域的出现，IIFE不再必要了。</li>
<li>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。ES6进行了修正，允许块级作用域内声明函数，但该函数只能在当前作用域内生效。外部无法访问（具体不同的浏览器实现会不一样）</li>
</ol>
<h2 id="第二章-变量的解构赋值"><a href="#第二章-变量的解构赋值" class="headerlink" title="第二章 变量的解构赋值"></a>第二章 变量的解构赋值</h2><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><p>将等号右边的数组，按照一定的匹配模式赋值给左边的变量。</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>我们通常给变量赋值，采用下面写法：</p>
<pre><code>let a = 1;
let b = 2;
let c = 3;
</code></pre>
<p>ES6 允许这样赋值</p>
<pre><code>let [a, b, c] = [1, 2, 3];
</code></pre>
<p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li>如果解构不成功，变量的值就等于undefined。  </li>
<li>不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。  </li>
<li>如果等号的右边不是数组，（或者严格地说，不是可遍历的结构），那么将会报错。<pre><code> // 报错
 let [foo] = 1;
 let [foo] = false;
 let [foo] = NaN;
 let [foo] = undefined;
 let [foo] = null;
 let [foo] = &#123;&#125;;
</code></pre>
</li>
</ol>
<h3 id="指定默认值"><a href="#指定默认值" class="headerlink" title="指定默认值"></a>指定默认值</h3><p>解构赋值允许指定默认值。</p>
<pre><code>let [foo = true] = [];
foo // true

let [x, y = &#39;b&#39;] = [&#39;a&#39;]; // x=&#39;a&#39;, y=&#39;b&#39;
let [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; // x=&#39;a&#39;, y=&#39;b&#39;
</code></pre>
<p>ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。</p>
<h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><p>解构不仅可以用于数组，还可以用于对象。<br>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值（也可以将数组的索引认为是唯一的key，这样与对象的属性其实也是相通的）</p>
<pre><code>let &#123; bar, foo &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;

let &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;
baz // undefined
//可以这样理解：前面的部分只是变量声明，声明了变量foo和bar, 等号后面是对这两个变量进行赋值，foo的值为&#39;aaa&#39;，bar的为&#39;bbb&#39;。  
</code></pre>
<p>如果变量名与属性名不一致，必须写成下面这样(可以理解为变量名映射）</p>
<pre><code>let &#123; foo: baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;
console.log(baz);//foo是匹配的模式，baz才是变量。真正被赋值的是变量baz
</code></pre>
<p>与数组一样，解构也可以用于嵌套结构的对象:</p>
<pre><code>let obj = &#123;
  p: [
    &#39;Hello&#39;,
    &#123; y: &#39;World&#39; &#125;
  ]
&#125;;

let &#123; p: [x, &#123; y &#125;] &#125; = obj;

console.log(x,y);// Hello World
console.log(p);// 报错
</code></pre>
<p>这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以这样写：</p>
<pre><code>let obj = &#123;
  p: [
    &#39;Hello&#39;,
    &#123; y: &#39;World&#39; &#125;
  ]
&#125;;

let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;

console.log(x,y);// Hello World
console.log(p);// [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]
</code></pre>
<p>如果层级比较多，需要每一级都赋值的话，需要多次匹配</p>
<pre><code>    const node = &#123;
      loc: &#123;
        start: &#123;
          line: 1,
          column: 5
        &#125;
      &#125;
    &#125;;
    
    let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;
    line // 1
    loc  // Object &#123;start: Object&#125;
    start // Object &#123;line: 1, column: 5&#125;
</code></pre>
<h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<pre><code>    const [a, b, c, d, e] = &#39;hello&#39;;
    a // &quot;h&quot;
    b // &quot;e&quot;
    c // &quot;l&quot;
    d // &quot;l&quot;
    e // &quot;o&quot;
</code></pre>
<p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p>
<pre><code>let &#123;length : len&#125; = &#39;hello&#39;;
len // 5
</code></pre>
<h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象,无法转换成对象的就报错（null 和 undefined）</p>
<pre><code>let &#123;toString: s&#125; = 123;
s === Number.prototype.toString // true

let &#123;toString: s&#125; = true;
s === Boolean.prototype.toString // true

let &#123; prop: x &#125; = undefined; // TypeError
let &#123; prop: y &#125; = null; // TypeError
</code></pre>
<h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><p>函数的参数也可以使用解构赋值。<br>例子1：</p>
<pre><code>function add([x, y])&#123;
  return x + y;
&#125;

add([1, 2]); // 3
</code></pre>
<p>例子2：</p>
<pre><code>[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b); //[3, 7]
// 如果不好理解可以运行 [3, 7].map((item) =&gt; item); //[3, 7]
</code></pre>
<p>例子3：函数参数的解构也可以使用默认值。</p>
<pre><code>function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;
  return [x, y];
&#125;

move(&#123;x: 3, y: 8&#125;); // [3, 8]
move(&#123;x: 3&#125;); // [3, 0]
move(&#123;&#125;); // [0, 0]
move(); // [0, 0]
</code></pre>
<h3 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h3><p>结构语句中慎用圆括号，以下几种情况不要用圆括号，会报错：  </p>
<ol>
<li>变量声明语句</li>
<li>函数参数</li>
<li>赋值语句的模式</li>
</ol>
<p>可以使用圆括号的情况只有一种：<strong>赋值语句的非模式部分，可以使用圆括号</strong></p>
<h3 id="解构赋值的用途"><a href="#解构赋值的用途" class="headerlink" title="解构赋值的用途"></a>解构赋值的用途</h3><h4 id="交换变量的值"><a href="#交换变量的值" class="headerlink" title="交换变量的值"></a>交换变量的值</h4><pre><code>    let x = 1;
    let y = 2;
    
    [x, y] = [y, x];
    console.log(x,y);//2,1
</code></pre>
<h4 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h4><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就变得非常方便：</p>
<pre><code>    // 返回一个数组
    
    function example() &#123;
      return [1, 2, 3];
    &#125;
    let [a, b, c] = example();
    
    // 返回一个对象
    
    function example() &#123;
      return &#123;
        foo: 1,
        bar: 2
      &#125;;
    &#125;
    let &#123; foo, bar &#125; = example();
</code></pre>
<h4 id="函数参数的定义"><a href="#函数参数的定义" class="headerlink" title="函数参数的定义"></a>函数参数的定义</h4><pre><code>    // 参数是一组有次序的值
    function f([x, y, z]) &#123; console.log(x+y+z) &#125;
    f([1, 2, 3]); //6
     // 参数是一组无次序的值
    function f(&#123;x, y, z&#125;) &#123; console.log(2*x+y-z) &#125;
    f(&#123;z: 3, y: 2, x: 1&#125;);//1
</code></pre>
<h4 id="提取-JSON-数据"><a href="#提取-JSON-数据" class="headerlink" title="提取 JSON 数据"></a>提取 JSON 数据</h4><p>解构赋值对提取 JSON 对象中的数据，尤其有用。  </p>
<pre><code>    let jsonData = &#123;
      id: 42,
      status: &quot;OK&quot;,
      data: [867, 5309]
    &#125;;
    
    let &#123; id, status, data: number &#125; = jsonData;
    
    console.log(id, status, number);
</code></pre>
<h4 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h4><pre><code>    function share(&#123;
        title=&quot;标题&quot;,
        url=window.location.href,
        content=&quot;分享描述&quot;
    &#125;)&#123;
        return JSON.stringify(&#123;
            title:title,
            shortLink:url,
            content:content
        &#125;)
    &#125;
    console.log(share(&quot;自定义标题&quot;));//&#123;&quot;title&quot;:&quot;标题&quot;,&quot;shortLink&quot;:&quot;http://zc.dev.bxd365.com/#/index&quot;,&quot;content&quot;:&quot;分享描述&quot;&#125;
</code></pre>
<h4 id="遍历-Map-结构"><a href="#遍历-Map-结构" class="headerlink" title="遍历 Map 结构"></a>遍历 Map 结构</h4><p>任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<pre><code>    const map = new Map();
    map.set(&#39;first&#39;, &#39;hello&#39;);
    map.set(&#39;second&#39;, &#39;world&#39;);
    
    for (let [key, value] of map) &#123;
      console.log(key + &quot; is &quot; + value);
    &#125;
    // first is hello
    // second is world
</code></pre>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样：<br>        // 获取键名<br>        for (let [key] of map) {<br>          // …<br>        }</p>
<pre><code>    // 获取键值
    for (let [,value] of map) &#123;
      // ...
    &#125;
</code></pre>
<h4 id="输入模块的指定方法-webpack中常见"><a href="#输入模块的指定方法-webpack中常见" class="headerlink" title="输入模块的指定方法(webpack中常见)"></a>输入模块的指定方法(webpack中常见)</h4><pre><code>const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);
</code></pre>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="http://es6.ruanyifeng.com/">阮一峰ES6入门</a></li>
<li><a href="https://my.oschina.net/u/2903254/blog/818796">ES6 的 Symbol 类型及使用案例</a></li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列-2-新增类型与扩展方法</title>
    <url>/ES6%E7%B3%BB%E5%88%97-2-%E6%96%B0%E5%A2%9E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本篇主要介绍全新的原始数据类型Symbol, 以及ES6新增的数据结构：set与map, 还有对ES6之前数据类型新增了一些扩展方法。</p>
<span id="more"></span>

<h2 id="第一章-Symbol"><a href="#第一章-Symbol" class="headerlink" title="第一章  Symbol"></a>第一章  Symbol</h2><h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><ol>
<li><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。所以ES6新引入了一种全新的原始数据类型Symbol。</p>
</li>
<li><p>Symbol不是对象，所以不同通过创建对象的方式来创建（譬如 new），它的值通过Symbol函数生成。基本上，它是一种类似于字符串的数据类型。</p>
</li>
<li><p>举个例子</p>
<pre><code> let s1 = Symbol(&#39;foo&#39;);
 let s2 = Symbol(&#39;bar&#39;);
 console.log([s1,s2])//[Symbol(foo), Symbol(bar)]
  //Symbol 值不能与其他类型的值进行运算
 console.log(&quot;s1的值为&quot;+s1) //报错，Cannot convert a Symbol value to a string
 console.log(&quot;s1的值为&quot;+s1.toString()) // s1的值为Symbol(foo)

 let s3 = Symbol();
 let s4 = Symbol();
 console.log(s3===s4);//false ,就算参数相同，symbol函数每次返回的值都是不相等的，这就可以用于对象属性命名上

 let s5=&quot;hello&quot;;
 let s6=&quot;hello&quot;;
 console.log(s5===s6);//true
 
</code></pre>
</li>
</ol>
<h3 id="作为属性名"><a href="#作为属性名" class="headerlink" title="作为属性名"></a>作为属性名</h3><ol>
<li><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，可以防止改写或者覆盖</p>
<pre><code> let symbol1=Symbol(),symbol2=Symbol(),symbol3=Symbol();
 let myObject = &#123; 
     publicProperty: &#39;Value of myObject[ &quot;publicProperty&quot; ]&#39;,
     [symbol1]:&#39;Value of myObject[ symbol1 ]&#39;
 &#125;;
  
 myObject[ symbol2 ] = &#39;value of myObject[ symbol2 ]&#39;;
 Object.defineProperty(myObject, symbol3, &#123; value: &#39;Value of myObject[ symbol1 ]&#39; &#125;);
 console.log(myObject)
</code></pre>
<p><img src="1.png"></p>
</li>
<li><p>Symbol 值作为对象属性名时，不能用点运算符,所以读取该属性时，必须通过<code>myObject[ symbol2 ]</code>来读取。</p>
</li>
<li><p>Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys(</code>)、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回，</p>
</li>
<li><p>可以通过<code>Object.getOwnPropertySymbols</code>来进行读取symbol属性，他返回一个数据</p>
<pre><code> [Symbol(), Symbol(), Symbol()]
</code></pre>
</li>
<li><p>在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
</li>
<li><p>Symbol.for()，Symbol.keyFor()（略）</p>
</li>
</ol>
<h2 id="第二章-新的数据结构-set"><a href="#第二章-新的数据结构-set" class="headerlink" title="第二章 新的数据结构-set"></a>第二章 新的数据结构-set</h2><p>ES6新增了两种数据结构，set结构和map结构：首先介绍一下set结构：</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>Set本身是一个构造函数，用来生成 Set 数据结构。<br>Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。返回的是一个set结构的数据  </p>
<p><img src="2.png">  </p>
<p>可以用作数组和字符串的去重操作:</p>
<pre><code>[...new Set([1,2,3,5,6,7,2,3])] //[1, 2, 3, 5, 6, 7] 数组去重
[...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)// &quot;abc&quot; 字符串去重
Array.from(new Set([1,2,3,5,6,7,2,3])) //[1, 2, 3, 5, 6, 7] Array.from方法也可以将 Set 结构转为数组。
</code></pre>
<h3 id="实例的属性和方法"><a href="#实例的属性和方法" class="headerlink" title="实例的属性和方法"></a>实例的属性和方法</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ol>
<li><p>Set.prototype.constructor：构造函数，默认就是Set函数。</p>
</li>
<li><p>Set.prototype.size：返回Set实例的成员总数。</p>
</li>
</ol>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol>
<li><p>四个操作方法（用于操作数据）</p>
<pre><code> add(value)：添加某个值，返回 Set 结构本身。
 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
 has(value)：返回一个布尔值，表示该值是否为Set的成员。
 clear()：清除所有成员，没有返回值。
</code></pre>
<p>举个例子：</p>
<pre><code> let s = new Set();
 s.add(2).add(&quot;2&quot;).add(1).add(1)
 console.log(s.size)；//3        
 console.log(s.has(&quot;2&quot;));// true
 console.log(s.has(0));// false
 s.delete(2);
 console.log(s.has(2))// false
</code></pre>
</li>
<li><p>四个遍历方法（三个遍历器生成函数和一个遍历方法）。</p>
<pre><code> keys()：返回键名的遍历器
 values()：返回键值的遍历器
 entries()：返回键值对的遍历器
 forEach()：使用回调函数遍历每个成员
</code></pre>
<p>举个例子：需要特别指出的是，Set的遍历顺序就是插入顺序。</p>
<pre><code> let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);
 
 for (let item of set.keys()) &#123;
   console.log(item);
 &#125;
 // red
 // green
 // blue
 
 for (let item of set.values()) &#123;
   console.log(item);
 &#125;
 // red
 // green
 // blue
 
 for (let item of set.entries()) &#123;
   console.log(item);
 &#125;
 // [&quot;red&quot;, &quot;red&quot;]
 // [&quot;green&quot;, &quot;green&quot;]
 // [&quot;blue&quot;, &quot;blue&quot;]

 /////可以省略values方法，直接用for...of循环遍历 Set。

 for (let x of set) &#123;
   console.log(x);
 &#125;
 // red
 // green
 // blue

 set.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value))
 // red : red
 // green : green
 // blue : blue
</code></pre>
</li>
</ol>
<p>扩展运算符（…）内部使用for…of循环，所以也可以用于 Set 结构。相结合后，数组的map和filter方法也可以间接用于 Set 了。</p>
<pre><code>let set = new Set([1, 2, 3, 4, 5]);
set = new Set([...set].filter(x =&gt; (x % 2) == 0));
</code></pre>
<h3 id="weekSet结构"><a href="#weekSet结构" class="headerlink" title="weekSet结构"></a>weekSet结构</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别：</p>
<ol>
<li>WeakSet 的成员只能是对象，而不能是其他类型的值。</li>
<li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用</li>
<li>WeakSet 没有size属性，没有办法遍历它的成员</li>
<li>WeakSet 没有clear方法。</li>
</ol>
<h2 id="第三章-新的数据结构-map"><a href="#第三章-新的数据结构-map" class="headerlink" title="第三章 新的数据结构-map"></a>第三章 新的数据结构-map</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p>
<ol>
<li><p>Map是一个构造函数，创建map对象通过关键字new即可。</p>
</li>
<li><p>Map构造函数参数可以为空，数组或Set,Map等，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。</p>
<pre><code> const m=new Map();
 const s=&#123;p:&quot;hello world&quot;&#125;
 
 m.set(s,&#39;jack&#39;)
 console.log(m.get(s));//&quot;jack&quot;
 console.log(m.has(s));// true
 m.delete(s)
 console.log(m.has(s));// false
 
 //传入一个set结构
 const set = new Set([
   [&#39;foo&#39;, 1],
   [&#39;bar&#39;, 2]
 ]);
 const m1 = new Map(set);
 console.log(m1.get(&#39;foo&#39;)) // 1
 
 //传入一个map结构
 const m2 = new Map([[&#39;baz&#39;, 3]]);
 const m3 = new Map(m2);
 console.log(m3.get(&#39;baz&#39;)) // 3

 //传入一个数组，数组内的元素是键-值对组合的方式（多余的会被忽略，就像例子中的 other），
 const n=new Map([
       [&#39;name&#39;,&quot;lilei&quot;],
       [&#39;age&#39;,24],
       [&#39;sex&#39;,&quot;man&quot;,&#39;other&#39;]
     ]);
 console.log(n.get(&#39;sex&#39;)); //man
 console.log(n);
</code></pre>
<p><img src="3.png"></p>
</li>
<li><p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>
</li>
<li><p>如果读取一个未知的键，则返回undefined。</p>
</li>
<li><p>对于引用类型，只有对同一个对象的引用，Map 结构才将其视为同一个键。</p>
</li>
<li><p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键：</p>
<pre><code> //0和-0就是一个键，布尔值true和字符串true则是两个不同的键。
 //另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。
 let map = new Map();
 
 map.set(-0, 123);
 map.get(+0) // 123
 
 map.set(true, 1);
 map.set(&#39;true&#39;, 2);
 map.get(true) // 1
 
 map.set(undefined, 3);
 map.set(null, 4);
 map.get(undefined) // 3
 
 map.set(NaN, 123);
 map.get(NaN) // 123
</code></pre>
<h3 id="实例的属性和方法-1"><a href="#实例的属性和方法-1" class="headerlink" title="实例的属性和方法"></a>实例的属性和方法</h3><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4></li>
<li><p>size 属性: 返回 Map 结构的成员总数</p>
</li>
</ol>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ol>
<li><p>四个操作方法（用于操作数据）</p>
<pre><code> set(key, value)：设置键名key对应的键值为value,返回是当前的Map对象，因此可以采用链式写法。
 get(key)：读取key对应的键值，如果找不到key，返回undefined。
 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
 has(value)：返回一个布尔值，表示某个键是否在当前 Map 对象之中。
 clear()：清除所有成员，没有返回值。
</code></pre>
<p>举个例子：</p>
<pre><code> const map=new Map();
 const s=&#123;p:&quot;hello world&quot;&#125;
 const o=()=&gt;&#123;console.log(&quot;my function&quot;)&#125;
 map.set(s,&#39;jack&#39;).set(o,&quot;fun&quot;);
 console.log(map.get(o));//fun
 console.log(map.has(s));// true
 map.delete(s);
 console.log(map.size);//1
 map.clear();
 console.log(map.size);//0
</code></pre>
</li>
<li><p>四个遍历方法（三个遍历器生成函数和一个遍历方法）。</p>
<pre><code> keys()：返回键名的遍历器。
 values()：返回键值的遍历器。
 entries()：返回所有成员的遍历器。
 forEach()：遍历 Map 的所有成员。
</code></pre>
<p>举个例子：</p>
<pre><code> const map = new Map([
   [&#39;F&#39;, &#39;no&#39;],
   [&#39;T&#39;,  &#39;yes&#39;],
 ]);
 
 for (let key of map.keys()) &#123;
   console.log(key);
 &#125;
 // &quot;F&quot;
 // &quot;T&quot;
 
 for (let value of map.values()) &#123;
   console.log(value);
 &#125;
 // &quot;no&quot;
 // &quot;yes&quot;
 
 for (let item of map.entries()) &#123;
   console.log(item[0], item[1]);
 &#125;
 // &quot;F&quot; &quot;no&quot;
 // &quot;T&quot; &quot;yes&quot;
 
 // 或者
 for (let [key, value] of map.entries()) &#123;
   console.log(key, value);
 &#125;
 // &quot;F&quot; &quot;no&quot;
 // &quot;T&quot; &quot;yes&quot;
 
 // 等同于使用map.entries() ,也可以省略entries
 for (let [key, value] of map) &#123;
   console.log(key, value);
 &#125;
 // &quot;F&quot; &quot;no&quot;
 // &quot;T&quot; &quot;yes&quot;
 
 //forEach方法
 map.forEach((value, key, map)=&gt; &#123;
   console.log(&quot;Key: %s, Value: %s&quot;, key, value, map);
 &#125;);
</code></pre>
<h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3></li>
<li><p>Map &lt;=&gt; 数组</p>
<pre><code> 1. Map =&gt; 数组
 //（...)运算符将map转换为数组，转换成数组
 //结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）
 const myMap = new Map()
   .set(true, 7)
   .set(&#123;foo: 3&#125;, [&#39;abc&#39;]);
 [...myMap]
 // [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#39;abc&#39; ] ] ]

 2. 数组 =&gt; Map，
 //将数组作为构造函数参数即可

 new Map([
   [true, 7],
   [&#123;foo: 3&#125;, [&#39;abc&#39;]]
 ])
 // Map &#123;
 //   true =&gt; 7,
 //   Object &#123;foo: 3&#125; =&gt; [&#39;abc&#39;]
 // &#125;
</code></pre>
</li>
<li><p>Map &lt;=&gt; 对象</p>
<pre><code> 1. Map =&gt; 对象
 //如果所有 Map 的键都是字符串，它可以无损地转为对象。
 //如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。
 
 function strMapToObj(strMap) &#123;
   let obj = Object.create(null);
   for (let [k,v] of strMap) &#123;
     obj[k] = v;
   &#125;
   return obj;
 &#125;
 
 const myMap = new Map()
   .set(&#39;yes&#39;, true)
   .set(&#39;no&#39;, false);
 strMapToObj(myMap) // &#123; yes: true, no: false &#125;

 2. 对象 =&gt; Map
 function objToStrMap(obj) &#123;
   let strMap = new Map();
   for (let k of Object.keys(obj)) &#123;
     strMap.set(k, obj[k]);
   &#125;
   return strMap;
 &#125;
 
 objToStrMap(&#123;yes: true, no: false&#125;)
 // Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125;
</code></pre>
</li>
<li><p>Map &lt;=&gt; JSON<br>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p>
<pre><code> //Map 的键名都是字符串
 function strMapToJson(strMap) &#123;
   return JSON.stringify(strMapToObj(strMap));
 &#125;
 
 let myMap = new Map().set(&#39;yes&#39;, true).set(&#39;no&#39;, false);
 strMapToJson(myMap)
 // &#39;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#39;

 //Map 的键名有非字符串，这时可以选择转为数组 JSON
 function mapToArrayJson(map) &#123;
   return JSON.stringify([...map]);
 &#125;
 
 let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&#39;abc&#39;]);
 const result=mapToArrayJson(myMap)// &#39;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#39;
 console.log(typeof result);// string
</code></pre>
<p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p>
<pre><code> function jsonToStrMap(jsonStr) &#123;
   return objToStrMap(JSON.parse(jsonStr));
 &#125;
 
 jsonToStrMap(&#39;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&#39;)
 // Map &#123;&#39;yes&#39; =&gt; true, &#39;no&#39; =&gt; false&#125;
</code></pre>
<p>还有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p>
<pre><code> function jsonToMap(jsonStr) &#123;
   return new Map(JSON.parse(jsonStr));
 &#125;
 
 jsonToMap(&#39;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#39;)
 // Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&#39;abc&#39;]&#125;
</code></pre>
</li>
</ol>
<h3 id="weekMap结构"><a href="#weekMap结构" class="headerlink" title="weekMap结构"></a>weekMap结构</h3><p>WeakMap结构与Map结构类似，也是用于生成键值对的集合。但是，它与 Set 有两个区别：</p>
<ol>
<li>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</li>
<li>WeakMap的键名所指向的对象，不计入垃圾回收机制。</li>
</ol>
<h4 id="WeakMap结构的用途"><a href="#WeakMap结构的用途" class="headerlink" title="WeakMap结构的用途"></a>WeakMap结构的用途</h4><p>WeakMap 的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。  </p>
<p>因此，一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。</p>
<pre><code>    const wm = new WeakMap();
    
    const element = document.getElementById(&#39;example&#39;);
    
    wm.set(element, &#39;some information&#39;);
    wm.get(element) // &quot;some information&quot;
</code></pre>
<h2 id="第四章-数据类型的扩展方法"><a href="#第四章-数据类型的扩展方法" class="headerlink" title="第四章 数据类型的扩展方法"></a>第四章 数据类型的扩展方法</h2><h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><h4 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h4><p>ES6 为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历。</p>
<pre><code>for (let codePoint of &#39;foo&#39;) &#123;
  console.log(codePoint)
&#125;
</code></pre>
<h4 id="normalize方法"><a href="#normalize方法" class="headerlink" title="normalize方法"></a>normalize方法</h4><p>ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</p>
<pre><code>&#39;\u01D1&#39;.normalize() === &#39;\u004F\u030C&#39;.normalize()
// true
</code></pre>
<h4 id="includes-amp-amp-startsWith-amp-amp-endsWith"><a href="#includes-amp-amp-startsWith-amp-amp-endsWith" class="headerlink" title="includes() &amp;&amp; startsWith() &amp;&amp; endsWith()"></a>includes() &amp;&amp; startsWith() &amp;&amp; endsWith()</h4><p>ES6 又提供了三种新方法，来确定一个字符串是否包含在另一个字符串中（ES5中只有indexOf）。</p>
<ol>
<li><p>includes()：返回布尔值，表示是否找到了参数字符串。</p>
</li>
<li><p>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</p>
</li>
<li><p>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</p>
<pre><code> let s = &#39;Hello world!&#39;;
 
 s.startsWith(&#39;Hello&#39;) // true
 s.endsWith(&#39;!&#39;) // true
 s.includes(&#39;o&#39;) // true
</code></pre>
<p>这三个方法都支持第二个参数，表示开始搜索的位置。</p>
<pre><code> let s = &#39;Hello world!&#39;;
 
 s.startsWith(&#39;world&#39;, 6) // true 针对第n个位置直到字符串结束
 s.endsWith(&#39;Hello&#39;, 5) // true   针对前n个
 s.includes(&#39;Hello&#39;, 6) // false  针对第n个位置直到字符串结束
</code></pre>
</li>
</ol>
<h4 id="repeat方法"><a href="#repeat方法" class="headerlink" title="repeat方法"></a>repeat方法</h4><p>repeat方法返回一个新字符串，表示将原字符串重复n次。</p>
<pre><code>&#39;x&#39;.repeat(3) // &quot;xxx&quot;
&#39;hello&#39;.repeat(2) // &quot;hellohello&quot;
&#39;na&#39;.repeat(0) // &quot;&quot;
</code></pre>
<h4 id="padStart-amp-amp-padEnd"><a href="#padStart-amp-amp-padEnd" class="headerlink" title="padStart() &amp;&amp; padEnd()"></a>padStart() &amp;&amp; padEnd()</h4><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</p>
<pre><code>&#39;x&#39;.padStart(5, &#39;ab&#39;) // &#39;ababx&#39;
&#39;x&#39;.padEnd(4, &#39;ab&#39;) // &#39;xaba&#39;
&#39;xxx&#39;.padStart(2, &#39;ab&#39;) // &#39;xxx&#39; 等于或大于最大长度，则字符串补全不生效，返回原字符串。
&#39;abc&#39;.padStart(10, &#39;0123456789&#39;) // &#39;0123456abc&#39; 补全字符串与原字符串的长度之和超过了最大长度，则会截去超出位数的补全字符串
&#39;x&#39;.padStart(4) // &#39;   x&#39; 省略第二个参数，默认使用空格补全长度
</code></pre>
<p>padStart()的常见用途是为数值补全指定位数和提示字符串格式。</p>
<pre><code>&#39;123456&#39;.padStart(10, &#39;0&#39;) // &quot;0000123456&quot;
&#39;09-12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-09-12&quot;
</code></pre>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>模板字符串（template string）是增强版的字符串，用反引号 <code>`</code> 标识。</p>
<pre><code>// 普通字符串
`In JavaScript &#39;\n&#39; is a line-feed.`

// 多行字符串
`In JavaScript this is
 not legal.`

// 字符串中嵌入变量
let name = &quot;Bob&quot;, time = &quot;today&quot;;
`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`
&quot;Hello Bob, how are you today?&quot;
</code></pre>
<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。<br>变量名写在${}之中，大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性 ，还可以调用函数。</p>
<pre><code>let x = 1;
let y = 2;

`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`
// &quot;1 + 2 = 3&quot;

`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`
// &quot;1 + 4 = 5&quot;

let obj = &#123;x: 1, y: 2&#125;;
`$&#123;obj.x + obj.y&#125;`

//函数调用
function fn() &#123;
  return &quot;Hello World&quot;;
&#125;

`foo $&#123;fn()&#125; bar`
</code></pre>
<h3 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h3><h4 id="二进制和八进制表示法"><a href="#二进制和八进制表示法" class="headerlink" title="二进制和八进制表示法"></a>二进制和八进制表示法</h4><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示。</p>
<pre><code>0b111110111 === 503 // true
0o767 === 503 // true
</code></pre>
<h4 id="Number-isFinite-amp-amp-Number-isNaN"><a href="#Number-isFinite-amp-amp-Number-isNaN" class="headerlink" title="Number.isFinite() &amp;&amp; Number.isNaN()"></a>Number.isFinite() &amp;&amp; Number.isNaN()</h4><p>ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效：</p>
<p>Number.isFinite()对于非数值一律返回false。<br>Number.isNaN()只有对于NaN才返回true，非NaN一律返回false</p>
<pre><code>isFinite(25) // true
isFinite(&quot;25&quot;) // true
Number.isFinite(25) // true
Number.isFinite(&quot;25&quot;) // false

isNaN(NaN) // true
isNaN(&quot;NaN&quot;) // true
Number.isNaN(NaN) // true
Number.isNaN(&quot;NaN&quot;) // false
Number.isNaN(1) // false

Number.isFinite(Infinity); // false
Number.isFinite(-Infinity); // false
isFinite(Infinity); // false
isFinite(-Infinity); // false
</code></pre>
<h4 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(), Number.parseFloat()"></a>Number.parseInt(), Number.parseFloat()</h4><p>ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。（这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。）</p>
<h4 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h4><p>用来判断一个数值是否为整数。</p>
<pre><code>Number.isInteger(25) // true
Number.isInteger(25.1) // false
Number.isInteger(25.0) // true
</code></pre>
<h4 id="Number-isSafeInteger-和安全整数"><a href="#Number-isSafeInteger-和安全整数" class="headerlink" title="Number.isSafeInteger()和安全整数"></a>Number.isSafeInteger()和安全整数</h4><p>ES6 引入了 <code>Number.MAX_SAFE_INTEGER</code> 和 <code>Number.MIN_SAFE_INTEGER</code> 这两个常量（2^53 和 -2^53），超出这两个常量js就无法精确表示了。Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</p>
<h4 id="MATH-对象的扩展"><a href="#MATH-对象的扩展" class="headerlink" title="MATH 对象的扩展"></a>MATH 对象的扩展</h4><p>ES6 在 Math 对象上新增了 <strong>17</strong> 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。</p>
<ol>
<li><p>Math.trunc 方法用于去除一个数的小数部分，返回整数部分。</p>
<pre><code> Math.trunc(4.1) // 4
 Math.trunc(-4.1) // -4
 Math.trunc(-0.1234) // -0
 
 //对于非数值，Math.trunc内部使用Number方法将其先转为数值
 Math.trunc(&#39;123.456&#39;) // 123
 Math.trunc(true) //1
 Math.trunc(false) // 0
 Math.trunc(null) // 0

 //对于空值和无法截取整数的值，返回NaN。
 Math.trunc(NaN);      // NaN
 Math.trunc(&#39;foo&#39;);    // NaN
 Math.trunc();         // NaN
 Math.trunc(undefined) // NaN
</code></pre>
</li>
<li><p>Math.sign 方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p>
<pre><code> // 它会返回五种值。
 //         参数为正数，返回+1；
 //         参数为负数，返回-1；
 //         参数为 0，返回0；
 //         参数为-0，返回-0;
 //         其他值，返回NaN。

 Math.sign(-5) // -1
 Math.sign(5) // +1
 Math.sign(0) // +0
 Math.sign(-0) // -0
 Math.sign(NaN) // NaN
 Math.sign(&#39;&#39;)  // 0
 Math.sign(true)  // +1
 Math.sign(false)  // 0
 Math.sign(null)  // 0
 Math.sign(&#39;9&#39;)  // +1
 Math.sign(&#39;foo&#39;)  // NaN
 Math.sign()  // NaN
 Math.sign(undefined)  // NaN
</code></pre>
</li>
<li><p>Math.cbrt 方法用于计算一个数的立方根。</p>
<pre><code> Math.cbrt(-1) // -1
 Math.cbrt(0)  // 0
 Math.cbrt(1)  // 1
 Math.cbrt(2)  // 1.2599210498948734
 //对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。
 Math.cbrt(&#39;8&#39;) // 2
 Math.cbrt(&#39;hello&#39;) // NaN
</code></pre>
</li>
<li><p>Math.clz32 方法将参数转为 32 位无符号整数的形式</p>
</li>
<li><p>Math.imul方 法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</p>
</li>
<li><p>Math.fround 方法返回一个数的32位单精度浮点数形式。</p>
</li>
<li><p>Math.hypot 方法返回所有参数的平方和的平方根。</p>
</li>
<li><p>Math.expm1 方法: Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1</p>
</li>
<li><p>Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。</p>
</li>
<li><p>Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。</p>
</li>
<li><p>Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。</p>
</li>
<li><p>Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）</p>
</li>
<li><p>Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）</p>
</li>
<li><p>Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）</p>
</li>
<li><p>Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）</p>
</li>
<li><p>Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）</p>
</li>
<li><p>Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）</p>
</li>
</ol>
<h4 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h4><p>ES2016 新增了一个指数运算符（**）,这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。</p>
<pre><code>2 ** 3 ** 2;// 512   相当于 2 ** (3 ** 2)
</code></pre>
<h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><ol>
<li><p>将一个数组转为用逗号分隔的参数序列。</p>
<pre><code> console.log(...[1, 2, 3])// 1 2 3
 console.log([...[], 1]) //[1]
</code></pre>
</li>
<li><p>主要用于函数调用, 该运算符将一个数组，变为参数序列</p>
<pre><code> function add(x, y) &#123;
   return x + y;
 &#125;
 
 const numbers = [4, 38];
 add(...[4, 38]);//42
</code></pre>
</li>
<li><p>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。</p>
<pre><code> // 在函数后面加上apply就等同于调用执行了函数,apply接受的第一个参数仍是运行函数的作用域，第二个是参数数组
 Math.max.apply(null, [14, 3, 77]);//77
 
 // ES6 的写法
 Math.max(...[14, 3, 77]);//77
 
 // 等同于
 Math.max(14, 3, 77);//77
</code></pre>
<h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5></li>
<li><p>复制数组(浅拷贝)</p>
<pre><code> const a1 = [1, &#123;x:2&#125;];
 // 写法一
 const a2 = [...a1];
 // 写法二
 const [...a2] = a1;
 a1[1].y=3;
 console.log(a1);//[1,&#123;x: 2, y: 3&#125;]
 console.log(a2);//[1,&#123;x: 2, y: 3&#125;] //注意是浅拷贝
</code></pre>
</li>
<li><p>合并数组(浅拷贝，同上)</p>
<pre><code> const arr1 = [&#39;a&#39;, &#39;b&#39;];
 const arr2 = [&#39;c&#39;];
 const arr3 = [&#39;d&#39;, &#39;e&#39;];
 // ES5 的合并数组
 arr1.concat(arr2, arr3);
 // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
 
 // ES6 的合并数组
 [...arr1, ...arr2, ...arr3]
</code></pre>
</li>
<li><p>与解构赋值结合：</p>
<pre><code> const [first, ...rest] = [1, 2, 3, 4, 5];
 //如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。
 const [...butLast, last] = [1, 2, 3, 4, 5]; //报错
</code></pre>
</li>
<li><p>字符串</p>
<pre><code> //扩展运算符还可以将字符串转为真正的数组。
 [...&#39;hello&#39;]
 // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]
</code></pre>
</li>
</ol>
<ol start="5">
<li><p>实现了 Iterator 接口的对象<br>任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组。</p>
<pre><code> let nodeList = document.querySelectorAll(&#39;div&#39;);//得到类数组
 let array = [...nodeList]; //转化成真正数组
</code></pre>
</li>
<li><p>Map 和 Set 结构，Generator 函数<br>只要具有 Iterator 接口的对象，都可以使用扩展运算符：</p>
<pre><code> let map = new Map([
   [1, &#39;one&#39;],
   [2, &#39;two&#39;],
   [3, &#39;three&#39;],
 ]);
 
 let arr = [...map.keys()]; // [1, 2, 3]

 const go = function*()&#123;
   yield 1;
   yield 2;
   yield 3;
 &#125;;
 
 [...go()] // [1, 2, 3]
</code></pre>
</li>
</ol>
<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h4><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）</p>
<h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h4><p>用于将一组值，转换为数组。</p>
<pre><code>Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
</code></pre>
<h4 id="数组实例的-copyWithin"><a href="#数组实例的-copyWithin" class="headerlink" title="数组实例的 copyWithin()"></a>数组实例的 copyWithin()</h4><p>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<pre><code>//Array.prototype.copyWithin(target(必选), start = 0（可选）, end = this.length（可选）)

[1, 2, 3, 4, 5].copyWithin(0, 3);
//[4, 5, 3, 4, 5]
//上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。

// 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4)
// [4, 2, 3, 4, 5]
</code></pre>
<h4 id="数组实例的-find-和-findIndex"><a href="#数组实例的-find-和-findIndex" class="headerlink" title="数组实例的 find() 和 findIndex()"></a>数组实例的 find() 和 findIndex()</h4><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数</p>
<pre><code>[1, 4, -5, 10].find((n) =&gt; n &lt; 0)
</code></pre>
<p>find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<pre><code>[1, 5, 10, 15].find(function(value, index, arr) &#123;
  return value &gt; 9;
&#125;) // 10
</code></pre>
<p>findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>
<pre><code>[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;
  return value &gt; 9;
&#125;) // 2
</code></pre>
<p>这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。</p>
<pre><code>function f(v)&#123;
  return v &gt; this.age;
&#125;
let person = &#123;name: &#39;John&#39;, age: 20&#125;;
[10, 12, 26, 15].find(f, person);    //26
</code></pre>
<h4 id="数组实例的fill"><a href="#数组实例的fill" class="headerlink" title="数组实例的fill()"></a>数组实例的fill()</h4><p>fill方法使用给定值，填充一个数组。用于空数组的初始化非常方便,数组中已有的元素，会被全部抹去。fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<pre><code>new Array(3).fill(7)
// [7, 7, 7]

[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)
// [&#39;a&#39;, 7, &#39;c&#39;]
</code></pre>
<p>如果填充的类型为对象，依旧是浅拷贝。</p>
<h4 id="数组实例的-entries-，keys-和-values"><a href="#数组实例的-entries-，keys-和-values" class="headerlink" title="数组实例的 entries()，keys() 和 values()"></a>数组实例的 entries()，keys() 和 values()</h4><p>ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。可以用for…of循环进行遍历:</p>
<pre><code>//是对键名的遍历
for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) &#123;
  console.log(index);
&#125;
// 0
// 1
//对键值的遍历
for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) &#123;
  console.log(elem);
&#125;
// &#39;a&#39;
// &#39;b&#39;
//对键值对的遍历
for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) &#123;
  console.log(index, elem);
&#125;
// 0 &quot;a&quot;
// 1 &quot;b&quot;
</code></pre>
<h4 id="数组实例的-includes"><a href="#数组实例的-includes" class="headerlink" title="数组实例的 includes()"></a>数组实例的 includes()</h4><p>与字符串的includes方法类似。返回一个布尔值，表示某个数组是否包含给定的值。ES2016 引入了该方法：</p>
<pre><code>[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(3, 3);  // false， 第二个参数表示搜索的起始位置，默认为0。
</code></pre>
<h4 id="数组实例的-flat-，flatMap"><a href="#数组实例的-flat-，flatMap" class="headerlink" title="数组实例的 flat()，flatMap()"></a>数组实例的 flat()，flatMap()</h4><p><code>flat()</code>用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</p>
<pre><code>//flat()默认只会“拉平”一层，接收一个参数表示想要拉平的层数，默认为1。
[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]

[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]
</code></pre>
<p>如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。</p>
<pre><code>[1, [2, [3]]].flat(Infinity)
</code></pre>
<p>flatMap()方法对原数组的每个成员执行一个函数。然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。且只能展开一层数组。</p>
<pre><code>// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) =&gt; [x, x * 2])
// [2, 4, 3, 6, 4, 8]
</code></pre>
<h4 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h4><p>数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。ES6 则是明确将空位转为undefined</p>
<h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><h4 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h4><h5 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h5><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<pre><code>function log(x, y = &#39;World&#39;) &#123;
  console.log(x, y);
&#125;

log(&#39;Hello&#39;) // Hello World
log(&#39;Hello&#39;, &#39;China&#39;) // Hello China
log(&#39;Hello&#39;, &#39;&#39;) // Hello
</code></pre>
<p>这比ES5中的断路运算要好很多，断路运算存在缺点：如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用</p>
<pre><code>function log(x, y) &#123;
  y = y || &#39;World&#39;;
  console.log(x, y);
&#125;
</code></pre>
<p>注意：  </p>
<ol>
<li><p>参数变量是默认声明的，所以不能用let或const再次声明。</p>
<pre><code> function foo(x = 5) &#123;
   let x = 1; // error
   const x = 2; // error
 &#125;
</code></pre>
</li>
<li><p>使用参数默认值时，函数不能有同名参数。</p>
<pre><code> // 不报错
 function foo(x, x, y) &#123;
   // ...
 &#125;
 
 // 报错
 function foo(x, x, y = 1) &#123;
   // ...
 &#125;
</code></pre>
</li>
</ol>
<h5 id="与解构赋值的配合使用"><a href="#与解构赋值的配合使用" class="headerlink" title="与解构赋值的配合使用"></a>与解构赋值的配合使用</h5><pre><code>function foo(&#123;x, y = 5&#125;) &#123;
  console.log(x, y);
&#125;

foo(&#123;&#125;) // undefined 5
foo(&#123;x: 1&#125;) // 1 5
foo(&#123;x: 1, y: 2&#125;) // 1 2
foo() // TypeError: Cannot read property &#39;x&#39; of undefined
</code></pre>
<p>从上面代码中可以看到：如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。为了解决这个问题，我们可以提供函数参数的默认值</p>
<pre><code>function foo(&#123;x, y = 5&#125;=&#123;&#125;) &#123;
  console.log(x, y);
&#125;
foo();//  undefined 5
</code></pre>
<p>对于可以省略的参数，我们可以使用双重默认值。    </p>
<pre><code>function fetch(url, &#123; body = &#39;&#39;, method = &#39;GET&#39;, headers = &#123;&#125; &#125;=&#123;&#125;) &#123;
  console.log(method);
&#125;
fetch(&quot;/test&quot;,&#123;&#125;);//正常
fetch(&quot;/test&quot;);//正常运行，不会报错
</code></pre>
<h5 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h5><p>函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真</p>
<pre><code>(function (a) &#123;&#125;).length // 1
(function (a = 5) &#123;&#125;).length // 0
(function (a, b, c = 5) &#123;&#125;).length // 2
</code></pre>
<h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<pre><code>var x = 1;
function f1(x, y = x) &#123;
  console.log(y);
&#125;

f1(2) // 2
//解释：参数y的默认值等于变量x。调用函数f1时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。

function f2(y = x) &#123;
    let x = 2;
    console.log(y);
  &#125;

f2() // 1
//解释：函数f2调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。
//如果此时，全局变量x不存在，f2就会报错。
</code></pre>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<pre><code>  function throwIfMissing() &#123;
    throw new Error(&#39;Missing parameter&#39;);
  &#125;
  
  function foo(mustBeProvided = throwIfMissing()) &#123;
    return mustBeProvided;
  &#125;
  
  foo() // Error: Missing parameter
</code></pre>
<h4 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h4><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<pre><code>function add(...values) &#123;
  let sum = 0;

  for (var val of values) &#123;
    sum += val;
  &#125;

  return sum;
&#125;

console.log(add(2, 5, 3, 9, 2)); //21
</code></pre>
<p>rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<pre><code>function f(a, ...b, c) &#123;
  // ...
&#125;//报错
</code></pre>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>从 ES5 开始，函数内部可以设定为严格模式。</p>
<pre><code>function doSomething(a, b) &#123;
  &#39;use strict&#39;;
  // code
&#125;
</code></pre>
<p>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<h4 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h4><pre><code>var f = function () &#123;&#125;;
console.log(f.name) // &quot;f&quot; ES5 会返回空

const bar = function baz() &#123;&#125;;
console.log(bar.name) // &quot;baz&quot; ES5和 ES6 返回结果一致

(new Function()).name // &quot;anonymous&quot; 含义为“匿名”
</code></pre>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><pre><code>var sum = (num1, num2) =&gt; num1 + num2;
// 等同于
var sum = function(num1, num2) &#123;
  return num1 + num2;
&#125;
</code></pre>
<p>如果箭头函数中只有一个语句，可以省略return;</p>
<h5 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h5><ol>
<li><p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
</li>
<li><p>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
</li>
<li><p>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
</li>
<li><p>不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</p>
</li>
</ol>
<h4 id="双冒号运算符"><a href="#双冒号运算符" class="headerlink" title="双冒号运算符"></a>双冒号运算符</h4><p>“函数绑定”（function bind）运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。用来取代call、apply、bind调用。</p>
<pre><code>foo::bar;
// 等同于
bar.bind(foo);

foo::bar(...arguments);
// 等同于
bar.apply(foo, arguments);
</code></pre>
<h3 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h3><h4 id="RegExp-构造函数"><a href="#RegExp-构造函数" class="headerlink" title="RegExp 构造函数"></a>RegExp 构造函数</h4><pre><code>var regex = new RegExp(&#39;xyz&#39;, &#39;i&#39;); //写法一
var regex = new RegExp(/xyz/i); //写法二
// 等价于
var regex = /xyz/i;
</code></pre>
<p>但是ES5中不允许这种写法，会报错：</p>
<pre><code>var regex = new RegExp(/xyz/, &#39;i&#39;);
</code></pre>
<p>ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符：</p>
<pre><code>new RegExp(/abc/ig, &#39;i&#39;)
</code></pre>
<h4 id="字符串的正则方法"><a href="#字符串的正则方法" class="headerlink" title="字符串的正则方法"></a>字符串的正则方法</h4><p>字符串对象共有 4 个方法，可以使用正则表达式：<code>match()、replace()、search()和split()</code>。<br>ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</p>
<h4 id="新增修饰符"><a href="#新增修饰符" class="headerlink" title="新增修饰符"></a>新增修饰符</h4><ol>
<li>u修饰符</li>
<li>y 修饰符</li>
<li>s 修饰符</li>
</ol>
<h4 id="新增属性"><a href="#新增属性" class="headerlink" title="新增属性"></a>新增属性</h4><ol>
<li>unicode属性，表示是否设置了u修饰符</li>
<li>sticky 属性，表示是否设置了y修饰符</li>
<li>flags属性，会返回正则表达式的修饰符。</li>
</ol>
<h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><p>对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级</p>
<h4 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h4><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。</p>
<pre><code>const foo = &#39;bar&#39;;
const baz = &#123;foo&#125;;

console.log(baz);//&#123;foo: &quot;bar&quot;&#125;
</code></pre>
<p>ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。</p>
<pre><code>let x=1,y=2;
console.log(&#123;x,y&#125;);//&#123;x: 1, y: 2&#125;
</code></pre>
<p>属性简写，方法也可以简写。</p>
<pre><code>let x=1;
const o = &#123;
  x,
  method() &#123;
    return &quot;Hello!&quot;;
  &#125;
&#125;;
console.log(o.x);//1
console.log(o.method());//&quot;Hello!&quot;
</code></pre>
<p>VUE中组件的ES6写法也是这样：</p>
<pre><code>const VueComponents = &#123;
  data() &#123;
    return &#123;&#125;
  &#125;,
  computed: &#123;
    $target() &#123;
      return null
    &#125;
  &#125;,
  method: &#123;
    handleClick() &#123;
      //...
    &#125;
  &#125;,
  mounted() &#123;&#125;,
  created() &#123;&#125;
&#125;
</code></pre>
<p>CommonJS 模块输出一组变量，就非常合适使用简洁写法：</p>
<pre><code>const getItem= ()=&gt; &#123;&#125;;
const setItem= ()=&gt; &#123;&#125;;
const clear= ()=&gt; &#123;&#125;;
module.exports = &#123; getItem, setItem, clear &#125;;
// 等同于
module.exports = &#123;
  getItem: getItem,
  setItem: setItem,
  clear: clear
&#125;;
</code></pre>
<h4 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h4><p>JavaScript 定义对象的属性，有两种方法。</p>
<pre><code>// 方法一
obj.foo = true;

// 方法二
obj[&#39;a&#39; + &#39;bc&#39;] = 123;
</code></pre>
<p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p>
<pre><code>let propKey = &#39;foo&#39;;

let obj = &#123;
  [propKey]: true,
  [&#39;a&#39; + &#39;bc&#39;]: 123,
  [&#39;h&#39; + &#39;ello&#39;]() &#123;
    return &#39;hi&#39;;
  &#125;
&#125;;
</code></pre>
<p>属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。</p>
<pre><code>const keyA = &#123;a: 1&#125;;
const keyB = &#123;b: 2&#125;;

const myObject = &#123;
  [keyA]: &#39;valueA&#39;,
  [keyB]: &#39;valueB&#39;
&#125;;

myObject // Object &#123;[object Object]: &quot;valueB&quot;&#125;
</code></pre>
<h4 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h4><p>函数的name属性，返回函数名。对象方法也是函数，因此也有name属性</p>
<pre><code>const o = &#123;
  x,
  method() &#123;
    return &quot;Hello!&quot;;
  &#125;
&#125;;
console.log(o.x.name);//undefined
console.log(o.method.name)// method
</code></pre>
<p>bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous</p>
<pre><code>(new Function()).name // &quot;anonymous&quot;

var doSomething = function() &#123;
  // ...
&#125;;
doSomething.bind().name // &quot;bound doSomething&quot;
</code></pre>
<h4 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="headerlink" title="属性的可枚举性和遍历"></a>属性的可枚举性和遍历</h4><h5 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h5><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</p>
<pre><code>let obj = &#123; foo: 123 &#125;;
console.log(Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;))
//  &#123;
//    value: 123,
//    writable: true,
//    enumerable: true,
//    configurable: true
//  &#125;
</code></pre>
<p>描述对象的enumerable属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。<br>目前，有四个操作会忽略enumerable为false的属性。</p>
<ol>
<li>for…in循环：只遍历对象自身的和<strong>继承</strong>的可枚举的属性。</li>
<li>Object.keys()：返回对象自身的所有可枚举的属性的键名。</li>
<li>JSON.stringify()：只串行化对象自身的可枚举的属性。</li>
<li>Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</li>
</ol>
<h5 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h5><p>ES6 一共有 5 种方法可以遍历对象的属性：</p>
<ol>
<li><p>for…in<br>Object.defineProperty</p>
<pre><code> //for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。
</code></pre>
</li>
<li><p>Object.keys(obj)</p>
<pre><code> //Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。
</code></pre>
</li>
<li><p>Object.getOwnPropertyNames(obj)</p>
<pre><code> //Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。
</code></pre>
</li>
<li><p>Object.getOwnPropertySymbols(obj)</p>
<pre><code> //Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。
</code></pre>
</li>
<li><p>Reflect.ownKeys(obj)</p>
<pre><code> //返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举
</code></pre>
<p>举个例子：</p>
<pre><code> const obj=&#123;
   name:&quot;jack&quot;,
   [Symbol()]:&quot;1&quot;
 &#125;
 Object.prototype.age=12;
 Object.defineProperty(obj, &quot;job&quot;, &#123;
     configurable:true,
     value:&quot;teacher&quot;,
     writable:true,
     enumerable:false
 &#125;)
 for(let key in obj)&#123;
   console.log(obj[key]);//&quot;jack&quot;  12
 &#125;
 
 console.log(Object.getOwnPropertyNames(obj));// [&quot;name&quot;, &quot;job&quot;]
 
 console.log(Object.getOwnPropertySymbols(obj));// [Symbol()]
 
 console.log(Reflect.ownKeys(obj));// [&quot;name&quot;, &quot;job&quot;, Symbol()]
</code></pre>
</li>
</ol>
<h4 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h4><p>this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。</p>
<pre><code>const proto = &#123;
  foo: &#39;hello&#39;
&#125;;

const obj = &#123;
  foo: &#39;world&#39;,
  find() &#123;
    return super.foo;
  &#125;
&#125;;

Object.setPrototypeOf(obj, proto);//setPrototypeOf方法设置一个指定的对象的原型到另一个对象
obj.find() // &quot;hello&quot;
</code></pre>
<p>super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。</p>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><pre><code>let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;
x // 1
y // 2
z // &#123; a: 3, b: 4 &#125;
</code></pre>
<p>变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。<br>解构赋值必须是最后一个参数，否则会报错。</p>
<pre><code>let &#123; ...x, y, z &#125; = someObject; // 句法错误
let &#123; x, ...y, ...z &#125; = someObject; // 句法错误
</code></pre>
<h4 id="扩展运算符（…）"><a href="#扩展运算符（…）" class="headerlink" title="扩展运算符（…）"></a>扩展运算符（…）</h4><p>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中（注意，还是浅拷贝）。</p>
<pre><code>const n=&#123;
  a:&#123;name:&quot;jack&quot;&#125;,
  b:2
&#125;
const m=&#123;
  c:3，
  b:4
&#125;
const p=&#123;...n,...m&#125;;

n.a.name=&quot;lilei&quot;;
m.c=&quot;0&quot;;
console.log(p);//a: &#123;name: &quot;lilei&quot;&#125;, b: 4, c: 3&#125; 同名属性后面会覆盖前面的，依旧是浅拷贝
</code></pre>
<p>对象的扩展运算符等同于使用Object.assign()方法（下一章会讲到）。</p>
<h2 id="第五章-对象新增方法"><a href="#第五章-对象新增方法" class="headerlink" title="第五章 对象新增方法"></a>第五章 对象新增方法</h2><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a>Object.is</h3><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，且+0等于-0，因此需要一个新算法来解决这个问题，<code>Object.is</code>接收两个参数，除了刚才提到的两个异常，其他均与<code>===</code>运算符结果一致：</p>
<pre><code>    +0 === -0 //true
    NaN === NaN // false
    
    Object.is(+0, -0) // false
    Object.is(NaN, NaN) // true
</code></pre>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p><code>Object.assign</code>方法用于对象的合并，第一个参数是目标对象，后面的参数都是源对象</p>
<pre><code>const target = &#123; a: 1, b: 1 &#125;;
const source1 = &#123; b: 2, c: 2 &#125;;
const source2 = &#123; c: 3 &#125;;
Object.assign(target,source1,source2);//&#123;a: 1, b: 2, c: 3&#125;
</code></pre>
<p>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 </p>
<ol>
<li><p>如果只有一个参数，如果该参数不是对象，则会先转成对象，然后返回（无法转换null 和 undefined）：</p>
<pre><code> Object.assign(2)
 Object.assign(&quot;2&quot;)
 Object.assign(false)
 Object.assign(undefined) // 报错
 Object.assign(null) // 报错
</code></pre>
</li>
<li><p>如果非对象参数出现在源对象的位置（即非首参数）,无法转成对象的参数，就会跳过（null 和 undefined不会报错）</p>
<pre><code> let obj = &#123;a: 1&#125;;
 Object.assign(obj, undefined) === obj // true
 Object.assign(obj, null) === obj // true
</code></pre>
</li>
<li><p>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）</p>
<pre><code> const v1 = &#39;abc&#39;;
 const v2 = true;
 const v3 = 10;
 
 const obj = Object.assign(&#123;&#125;, v1, v2, v3);
 console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;，只有字符串的包装对象，会产生可枚举属性。
</code></pre>
</li>
<li><p>属性名为 Symbol 值的属性，也会被Object.assign拷贝。</p>
</li>
</ol>
<h4 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h4><ol>
<li><p><code>Object.assign</code>方法实行的是浅拷贝，而不是深拷贝。</p>
</li>
<li><p>对于嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加：</p>
<pre><code> const target = &#123; a: &#123; b: &#39;c&#39;, d: &#39;e&#39; &#125; &#125;
 const source = &#123; a: &#123; b: &#39;hello&#39; &#125; &#125;
 Object.assign(target, source)// &#123; a: &#123; b: &#39;hello&#39; &#125; &#125;
</code></pre>
</li>
<li><p>可以用来处理数组，但是会把数组视为对象</p>
<pre><code>  Object.assign([1, 2, 3], [4, 5])// [4, 5, 3]
</code></pre>
</li>
<li><p>取值函数的处理：<code>Object.assig</code>n只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p>
</li>
</ol>
<h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><ol>
<li><p>为对象添加属性/方法</p>
</li>
<li><p>克隆对象</p>
<pre><code>  const copy1=source;
 const copy2=Object.assign(&#123;&#125;,source);
 source.name=&quot;lilei&quot;;
 console.log(copy1);//&#123;name: &quot;lilei&quot;, sex: &quot;man&quot;&#125;
 console.log(copy2);//&#123;name: &quot;jack&quot;, sex: &quot;man&quot;&#125;
</code></pre>
<p>原始对象拷贝到一个空对象，就得到了原始对象的克隆；不过只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p>
<pre><code> function clone(origin) &#123;
   let originProto = Object.getPrototypeOf(origin);
   return Object.assign(Object.create(originProto), origin);
 &#125;
</code></pre>
</li>
<li><p>合并多个对象</p>
</li>
<li><p>为属性指定默认值</p>
<pre><code> const DEFAULTS = &#123;
   logLevel: 0,
   outputFormat: &#39;html&#39;
 &#125;;
 
 function processContent(options) &#123;
   options = Object.assign(&#123;&#125;, DEFAULTS, options);
 &#125;
</code></pre>
<h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys"></a>Object.keys</h3><p>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。<br>ES2017 引入了跟<code>Object.keys</code>配套的<code>Object.values和Object.entries</code>，作为遍历一个对象的补充手段，供for…of循环使用；</p>
<pre><code> const source=&#123;
       name:&quot;jack&quot;,
       sex:&quot;man&quot;
     &#125;
 console.log(Object.keys(source));//[&quot;name&quot;, &quot;sex&quot;]
</code></pre>
<h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values"></a>Object.values</h3><p>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值：</p>
<pre><code> const source=&#123;
       name:&quot;jack&quot;,
       sex:&quot;man&quot;
     &#125;
 console.log(Object.values(source));//[&quot;jack&quot;, &quot;man&quot;]
</code></pre>
<h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p>返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>
<pre><code>     const source=&#123;
       name:&quot;jack&quot;,
       sex:&quot;man&quot;,
       age:20
     &#125;
 console.log(Object.entries(source));//[[&quot;name&quot;, &quot;jack&quot;],[&quot;sex&quot;, &quot;man&quot;],[&quot;age&quot;, 20]]
</code></pre>
<p>返回值只输出属性名非 Symbol 值的属性：</p>
<pre><code>   const source1=&#123;
       name:&quot;jack&quot;,
       [Symbol()]:&quot;12&quot;
     &#125;
  const source2=&#123;
       [Symbol()]:&quot;12&quot;
     &#125;
 console.log(Object.entries(source1));//[&quot;name&quot;, &quot;jack&quot;]
 console.log(Object.entries(source2));//[]
</code></pre>
<h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h3><p><code>Object.fromEntries()</code>方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。</p>
<pre><code> Object.fromEntries([
     [&quot;name&quot;, &quot;jack&quot;],
     [&quot;sex&quot;, &quot;man&quot;]
 ]);//&#123;name:&quot;jack&quot;,sex:&quot;man&quot;&#125;
</code></pre>
</li>
</ol>
<p>该方法的主要作用是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象</p>
<pre><code>const entries = new Map([
  [&#39;foo&#39;, &#39;bar&#39;],
  [&#39;baz&#39;, 42]
]);

Object.fromEntries(entries)
// &#123; foo: &quot;bar&quot;, baz: 42 &#125;
</code></pre>
<p>ps:截止目前（2019.1.23 chrome和火狐均未实现该方法）</p>
<h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h3><p>ES5 的<code>Object.getOwnPropertyDescriptor()</code>方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了<code>Object.getOwnPropertyDescriptors()</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<pre><code>   const source=&#123;
    name:&quot;jack&quot;,
    sex:&quot;man&quot;,
    _age:18,
    get age()&#123;
        return this._age
    &#125;,
    set age(val)&#123;
        this._age=val&gt;10?10:val;
    &#125;
  &#125;;
console.log(Object.getOwnPropertyDescriptor(source, &#39;sex&#39;));
console.log(Object.getOwnPropertyDescriptors(source))
</code></pre>
<p><img src="4.png"></p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol>
<li><p>解决Object.assign()无法正确拷贝get属性和set属性的问题(主要目的)：</p>
<pre><code> const source=&#123;
     name:&quot;jack&quot;,
     sex:&quot;man&quot;,
     _age:18,
     get age()&#123;
         return this._age
     &#125;,
     set age(val)&#123;
         this._age=val&gt;10?10:val;
     &#125;
   &#125;;
 const target=Object.assign(&#123;&#125;,source);
 console.log(target)
 console.log(Object.getOwnPropertyDescriptor(source, &#39;age&#39;))
 console.log(Object.getOwnPropertyDescriptor(target, &#39;age&#39;))
</code></pre>
<p><img src="5.png"><br>我们可以这样解决：</p>
<pre><code> const source=&#123;
     name:&quot;jack&quot;,
     sex:&quot;man&quot;,
     _age:18,
     get age()&#123;
         return this._age
     &#125;,
     set age(val)&#123;
         this._age=val&gt;10?10:val;
     &#125;
   &#125;;
 const target = &#123;&#125;;
 Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
</code></pre>
</li>
<li><p>是配合Object.create()方法，将对象属性克隆到一个新对象。这属于浅拷贝:</p>
<pre><code> const source=&#123;
     name:&quot;jack&quot;,
     sex:&quot;man&quot;,
     _age:18,
     get age()&#123;
         return this._age
     &#125;,
     set age(val)&#123;
         this._age=val&gt;10?10:val;
     &#125;
   &#125;;
 const clone=(obj)=&gt;Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj))
  source.sex=&quot;women&quot;;
  console.log(clone(source));
   //&#123;name: &quot;jack&quot;, sex: &quot;women&quot;, _age: 18&#125;
</code></pre>
</li>
<li><p>可以实现一个对象继承另一个对象:</p>
<pre><code> const prot=&#123;
     x:1
 &#125;
 const obj = Object.create(
     prot,
     Object.getOwnPropertyDescriptors(&#123;
       foo: 123,
     &#125;)
   );
   console.log(obj.x);//1
   console.log(obj.foo);//123
</code></pre>
</li>
</ol>
<h3 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__属性"></a>__proto__属性</h3><p><code>__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。该属性没有写入 ES6 的正文，而是写入了附录，原因是<code>__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6（<code>__proto__</code>调用的是<code>Object.prototype.__proto__</code>）。简易使用使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p>
<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p>Object.setPrototypeOf方法的作用与<code>__proto__</code>相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法：</p>
<pre><code>let proto = &#123;&#125;;
let obj = &#123; x: 10 &#125;;
Object.setPrototypeOf(obj, proto);

proto.y = 20;
proto.z = 40;

obj.x // 10
obj.y // 20
obj.z // 40
</code></pre>
<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果,但是第一个参数如果是undefined或null，就会报错。</p>
<pre><code>    Object.setPrototypeOf(1, &#123;&#125;) === 1 // true
    Object.setPrototypeOf(&#39;foo&#39;, &#123;&#125;) === &#39;foo&#39; // true
    Object.setPrototypeOf(true, &#123;&#125;) === true // true
</code></pre>
<h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。</p>
<pre><code>    function Obj()&#123;&#125;;
    const newObj=new Obj();
    console.log(Object.getPrototypeOf(newObj)===Obj.prototype);//true
    const prop=&#123;&#125;;
    Object.setPrototypeOf(newObj,prop)
    prop.x=1;
    console.log(newObj.x);//1
    console.log(Object.getPrototypeOf(newObj));//&#123;x: 1&#125;
</code></pre>
<p>如果参数不是对象，会被自动转为对象。如果是undefined或null，就会报错。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="http://es6.ruanyifeng.com/">阮一峰ES6入门</a></li>
<li><a href="https://my.oschina.net/u/2903254/blog/818796">ES6 的 Symbol 类型及使用案例</a></li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列-3-Iterator</title>
    <url>/ES6%E7%B3%BB%E5%88%97-3-Iterator/</url>
    <content><![CDATA[<p>遍历器（Iterator）是带有特殊接口的对象。含有一个next()方法，调用返回一个包含两个属性的对象，分别是value和done，value表示当前位置的值，done表示是否迭代完，当为true的时候，调用next就无效了。它可以为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。 </p>
<span id="more"></span>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。  </p>
<p>ES5中遍历集合通常都是 for循环，数组还有 forEach 方法，对象就是 for-in，ES6 中又添加了 Map 和 Set，而遍历器（Iterator）可以统一处理所有集合数据的方法。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>为各种数据结构，提供一个统一的、简便的访问接口；</li>
<li>使得数据结构的成员能够按某种次序排列；</li>
<li>ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费；</li>
</ol>
<h3 id="Iterator-的遍历过程"><a href="#Iterator-的遍历过程" class="headerlink" title="Iterator 的遍历过程"></a>Iterator 的遍历过程</h3><ol>
<li><p>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p>
</li>
<li><p>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</p>
</li>
<li><p>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</p>
</li>
<li><p>不断调用指针对象的next方法，直到它指向数据结构的结束位置。  </p>
</li>
</ol>
<p>下面是一个模拟next方法返回值的例子。</p>
<pre><code>    var it = makeIterator([&#39;a&#39;, &#39;b&#39;]);
    
    it.next() // &#123; value: &quot;a&quot;, done: false &#125;
    it.next() // &#123; value: &quot;b&quot;, done: false &#125;
    it.next() // &#123; value: undefined, done: true &#125;
    
    function makeIterator(array) &#123;
      var nextIndex = 0;
      return &#123;
        next: function() &#123;
          return nextIndex &lt; array.length ?
            &#123;value: array[nextIndex++], done: false&#125; :
            &#123;value: undefined, done: true&#125;;
        &#125;
      &#125;;
    &#125;
</code></pre>
<h2 id="默认-iterator-接口"><a href="#默认-iterator-接口" class="headerlink" title="默认 iterator 接口"></a>默认 iterator 接口</h2><p>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。ES6 规定，默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）。<br><code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。</p>
<p>原生具备 Iterator 接口的数据结构如下：</p>
<pre><code>Array
Map
Set
String
TypedArray
函数的 arguments 对象
NodeList 对象
</code></pre>
<p>下面的例子是Map结构的Symbol.iterator属性:</p>
<pre><code>const map=new Map([
  [&#39;name&#39;,&#39;jack&#39;],
  [&#39;age&#39;,&#39;45&#39;]
])
let iter = map[Symbol.iterator]();
//Symbol.iterator是一个表达式，返回Symbol对象的iterator属性，
//这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内

console.log(map)
console.log(iter.next())
console.log(iter.next())
console.log(iter.next())
</code></pre>
<p><img src="1.png"></p>
<p>对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，for…of循环会自动遍历它们。</p>
<pre><code>for(let key of map)&#123;
  console.log(key)
&#125;
//[&quot;name&quot;, &quot;jack&quot;]
//[&quot;age&quot;, &quot;45&quot;]
</code></pre>
<p>对于没有原生部署 Iterator 接口的数据结构（主要是对象），都需要自己在Symbol.iterator属性上面部署，这样才会被for…of循环遍历。  </p>
<p>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。<br>下面是另一个为对象添加 Iterator 接口的例子。</p>
<pre><code>let obj1 = &#123;name:&quot;1&quot;,age:2&#125;;
let obj2 = &#123;
  data: [ &#39;hello&#39;, &#39;world&#39; ],
  [Symbol.iterator]() &#123;
    const self = this;
    let index = 0;
    return &#123;
      next() &#123;
        if (index &lt; self.data.length) &#123;
          return &#123;
            value: self.data[index++],
            done: false
          &#125;;
        &#125; else &#123;
          return &#123; value: undefined, done: true &#125;;
        &#125;
      &#125;
    &#125;;
  &#125;
&#125;;

for(let key of obj2)&#123;
  console.log(key)；
  // hello
  // world
&#125;
for(let key of obj1)&#123;
  console.log(key);// 报错 Uncaught TypeError: obj1 is not iterable
&#125;
</code></pre>
<h2 id="调用-Iterator-接口的场合"><a href="#调用-Iterator-接口的场合" class="headerlink" title="调用 Iterator 接口的场合"></a>调用 Iterator 接口的场合</h2><p>除了<code>for...of</code>循环外，还有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法）：</p>
<ol>
<li><p>解构赋值<br>对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。</p>
<pre><code> let set = new Set().add(&#39;a&#39;).add(&#39;b&#39;).add(&#39;c&#39;);
 
 let [x,y] = set;
 // x=&#39;a&#39;; y=&#39;b&#39;
 
 let [first, ...rest] = set;
 // first=&#39;a&#39;; rest=[&#39;b&#39;,&#39;c&#39;];
</code></pre>
</li>
<li><p>扩展运算符<br>扩展运算符（…）也会调用默认的 Iterator 接口。</p>
<pre><code> // 例一
 var str = &#39;hello&#39;;
 [...str] //  [&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;]
 
 // 例二
 let arr = [&#39;b&#39;, &#39;c&#39;];
 [&#39;a&#39;, ...arr, &#39;d&#39;]
 // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
</code></pre>
<p>只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</p>
<pre><code> let arr = [...iterable];
</code></pre>
</li>
<li><p>yield*<br>yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口</p>
<pre><code> let generator = function* () &#123;
   yield 1;
   yield* [2,3,4]; 
   yield 5;
 &#125;;
 
 var iterator = generator();
 
 iterator.next() // &#123; value: 1, done: false &#125;
 // 如果yield后面没有带*号，那么直接会输出 &#123; value:[2,3,4], done: false &#125;
 iterator.next() // &#123; value: 2, done: false &#125;
 iterator.next() // &#123; value: 3, done: false &#125;
 iterator.next() // &#123; value: 4, done: false &#125;
 iterator.next() // &#123; value: 5, done: false &#125;
 iterator.next() // &#123; value: undefined, done: true &#125;
</code></pre>
</li>
<li><p>其他场合<br>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p>
<pre><code> for...of
 Array.from()
 Map(), Set(), WeakMap(), WeakSet()（比如new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])）
 Promise.all()
 Promise.race()
</code></pre>
</li>
</ol>
<h3 id="字符串的-Iterator-接口"><a href="#字符串的-Iterator-接口" class="headerlink" title="字符串的 Iterator 接口"></a>字符串的 Iterator 接口</h3><p>字符串是一个类似数组的对象，也原生具有 Iterator 接口。</p>
<pre><code>var someString = &quot;hi&quot;;
console.log(typeof someString[Symbol.iterator])
// &quot;function&quot;

var iterator = someString[Symbol.iterator]();

iterator.next()  // &#123; value: &quot;h&quot;, done: false &#125;
iterator.next()  // &#123; value: &quot;i&quot;, done: false &#125;
iterator.next()  // &#123; value: undefined, done: true &#125;
</code></pre>
<h3 id="Iterator-接口与-Generator-函数"><a href="#Iterator-接口与-Generator-函数" class="headerlink" title="Iterator 接口与 Generator 函数"></a>Iterator 接口与 Generator 函数</h3><p><code>Symbol.iterator</code>方法的最简单实现，还是使用 Generator 函数。<code>Symbol.iterator</code>方法几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可。</p>
<pre><code>let obj = &#123;
  * [Symbol.iterator]() &#123;
    yield &#39;hello&#39;;
    yield &#39;world&#39;;
  &#125;
&#125;;

for (let x of obj) &#123;
  console.log(x);
&#125;
// &quot;hello&quot;
// &quot;world&quot;
</code></pre>
<h3 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h3><p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。</p>
<p>for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p>
<pre><code>//数组结构
const arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;];

for(let key of arr) &#123;
  console.log(key); // red green blue
&#125;

//set结构
var engines = new Set([&quot;Gecko&quot;, &quot;Trident&quot;, &quot;Webkit&quot;, &quot;Webkit&quot;]);
for (let key of engines) &#123;
  console.log(key);
&#125;

//Map结构
let map = new Map().set(&#39;a&#39;, 1).set(&#39;b&#39;, 2);
for (let key of map) &#123;
  console.log(key);
&#125;

//计算生成的数据结构
//ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。
//entries() keys()  values() 返回的都是一个遍历器对象
let marr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
for (let key of marr.entries()) &#123;
  console.log(key);
&#125;

// 字符串
let str = &quot;hello&quot;;

for (let key of str) &#123;
  console.log(key); // h e l l o
&#125;

// DOM NodeList对象
let paras = document.querySelectorAll(&quot;li&quot;);
for (let key of paras) &#123;
  key.classList.add(&quot;test&quot;)
&#125;
//对应li节点上会添加 class=&quot;test&quot;

// arguments对象
function printArgs() &#123;
  for (let key of arguments) &#123;
    console.log(key);
  &#125;
&#125;
printArgs(&#39;a&#39;, &#39;b&#39;);
// &#39;a&#39;
// &#39;b&#39;
</code></pre>
<p>对象上如何使用<code>for...of</code>循环？对于普通的对象，for…of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。</p>
<p>方法1： 使用 Object.keys</p>
<pre><code>let es6 = &#123;
  edition: 6,
  committee: &quot;TC39&quot;,
  standard: &quot;ECMA-262&quot;
&#125;;

//for in 是可以直接使用的
for (let e in es6) &#123;
  console.log(e);
  // edition
  // committee
  // standard
&#125;

for (var key of Object.keys(es6)) &#123;
  console.log(key + &#39;: &#39; + es6[key]);
  //edition: 6
  //committee: TC39
  //standard: ECMA-262
&#125;
</code></pre>
<p>方法2：使用 Generator 函数将对象重新包装一下</p>
<pre><code>function* entries(obj) &#123;
  for (let key of Object.keys(obj)) &#123;
    yield [key, obj[key]];
  &#125;
&#125;

for (let [key, value] of entries(es6)) &#123;
  console.log(key, &#39;-&gt;&#39;, value);
&#125;
//edition -&gt; 6
//committee -&gt; TC39
//standard -&gt; ECMA-262
</code></pre>
<h2 id="for-of-与其他遍历语法的比较"><a href="#for-of-与其他遍历语法的比较" class="headerlink" title="for of 与其他遍历语法的比较"></a>for of 与其他遍历语法的比较</h2><p>以数组为例:</p>
<ol>
<li>for循环: 写法较为麻烦</li>
<li>数组内置的forEach方法：无法中途跳出forEach循环，break命令或return命令都不能奏效</li>
<li>for…in循环：主要是为遍历对象而设计的，不适用于遍历数组，数组中是以字符串作为键名“0”、“1”、“2”等等。</li>
</ol>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列-4-Proxy与Reflect</title>
    <url>/ES6%E7%B3%BB%E5%88%97-4-Proxy%E4%B8%8EReflect/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Proxy: 英文意思为：代理，读音为：[ˈprɒksi]。它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。</p>
<span id="more"></span>
<p>我们先看一个例子</p>
<pre><code>var obj = new Proxy(&#123;&#125;, &#123;
  get(target, key, receiver) &#123;
    console.log(`getting $&#123;key&#125;!`);
    return Reflect.get(target, key, receiver);
  &#125;,
  set(target, key, value, receiver) &#123;
    console.log(`setting $&#123;key&#125;!`);
    return Reflect.set(target, key, value, receiver);
  &#125;
&#125;);
</code></pre>
<p>运行下面代码：</p>
<pre><code>obj.name=&quot;mike&quot;
//setting name!

obj.name
//getting name!
</code></pre>
<p>可以看到ES6重载了点运算符，即用自己的定义覆盖了语言的原始定义。</p>
<h2 id="Proxy-对象"><a href="#Proxy-对象" class="headerlink" title="Proxy 对象"></a>Proxy 对象</h2><h3 id="Proxy-构造函数"><a href="#Proxy-构造函数" class="headerlink" title="Proxy 构造函数"></a>Proxy 构造函数</h3><p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>
<pre><code>var proxy = new Proxy(target, handler);
</code></pre>
<ul>
<li>target参数表示所要拦截的目标对象</li>
<li>handler参数也是一个对象，用来定制拦截行为</li>
</ul>
<p>我们在target对象上设置一层拦截：</p>
<pre><code>  var target = &#123;&#125;;
  var handler = &#123;
    get(target, property)&#123;
      return &#39;Li&#39;
    &#125;,
  &#125;;
  var proxy = new Proxy(target, handler);
</code></pre>
<p>当修改target对象时</p>
<pre><code>  target.name=&quot;jack&quot;;
</code></pre>
<p>可以看到proxy其实是接收到变化了<br><img src="1.jpg"></p>
<p>但当我们访问proxy下属性时，返回的依旧是<code>Li</code>:</p>
<pre><code>  proxy.name //&#39;Li&#39;
</code></pre>
<p>直接设置proxy.name,proxy返回的依旧是<code>Li</code>,target变为了<code>tom</code>:</p>
<pre><code>  proxy.name=&quot;tom&quot;
  proxy.name //&#39;Li&#39;
  target.name //&quot;tom&quot;
</code></pre>
<p>这很好理解，所有访问操作都会经过代理再处理一层，所以返回的永远是 <code>Li</code></p>
<h3 id="Proxy-实例"><a href="#Proxy-实例" class="headerlink" title="Proxy 实例"></a>Proxy 实例</h3><p>Proxy 实例也可以作为其他对象的原型对象（沿用上述例子）。</p>
<pre><code>  var target = &#123;&#125;;
  var handler = &#123;
    get(target, property)&#123;
      return &#39;Li&#39;
    &#125;,
  &#125;;
  var proxy = new Proxy(target, handler);
  var obj = Object.creat(proxy)
  console.log(obj.time);// &#39;Li&#39;
</code></pre>
<h2 id="Proxy-实例方法"><a href="#Proxy-实例方法" class="headerlink" title="Proxy 实例方法"></a>Proxy 实例方法</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>get方法用于拦截某个属性的读取操作，可以接受三个参数：</p>
<pre><code>get(target,propKey[,receiver])

- target: 目标对象
- propKey: 属性名
- receiver: proxy 实例本身,严格地说，是操作行为所针对的对象，可选
</code></pre>
<h4 id="拦截读取"><a href="#拦截读取" class="headerlink" title="拦截读取"></a>拦截读取</h4><pre><code>const person = &#123;
  name: &quot;张三&quot;
&#125;;

const proxy = new Proxy(person, &#123;
  get: function(target, propKey) &#123;
    if (propKey in target) &#123;
      return target[propKey];
    &#125; else &#123;
      throw new ReferenceError(&quot;propKey \&quot;&quot; + propKey + &quot;\&quot; does not exist.&quot;);
    &#125;
  &#125;
&#125;);
</code></pre>
<p>运行结果：</p>
<p><img src="2.jpg"></p>
<h4 id="拦截继承"><a href="#拦截继承" class="headerlink" title="拦截继承"></a>拦截继承</h4><pre><code>const Obj=new Proxy(&#123;&#125;, &#123;
  get: function(target, propKey, receiver) &#123;
      console.log(&quot;GET &quot;+propKey)
      console.log(receiver)
      return target[propKey];
  &#125;
&#125;);
const p1=Object.create(Obj)
</code></pre>
<p>运行结果：</p>
<pre><code> p1.name // GET name
</code></pre>
<h4 id="receiver-参数"><a href="#receiver-参数" class="headerlink" title="receiver 参数"></a>receiver 参数</h4><pre><code>const proxy = new Proxy(&#123;&#125;, &#123;
  get: function(target, propKey, receiver) &#123;
    return receiver;
  &#125;
&#125;);
const b=Object.create(proxy)
proxy.getReceiver === proxy;// true
b.a===b.c; //true
b.a===b; //true
</code></pre>
<p>  b对象本身没有a属性，所以读取b.a的时候，会去d的原型proxy对象找。这时，receiver就指向b，代表原始的读操作所在的那个对象。</p>
<h4 id="不可写配置且不可写属性的拦截"><a href="#不可写配置且不可写属性的拦截" class="headerlink" title="不可写配置且不可写属性的拦截"></a>不可写配置且不可写属性的拦截</h4><pre><code>const target = Object.defineProperties(&#123;&#125;, &#123;
  foo: &#123;
    value: 123,
    writable: false,
    configurable: false
  &#125;,
&#125;);


const proxy = new Proxy(target, &#123;
  get(target, propKey) &#123;
    return &#39;abc&#39;;
  &#125;
&#125;);
</code></pre>
<p>此时，访问<code>proxy.foo</code>会报错</p>
<p><img src="3.jpg"></p>
<p>这种情况下只能返回原属性本身：</p>
<pre><code>const proxy = new Proxy(target, &#123;
  get(target, propKey) &#123;
    return target[propKey]
  &#125;
&#125;);
</code></pre>
<h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p>set方法用来拦截某个属性的赋值操作，可以接受四个参数：</p>
<pre><code>set(target, propKey, value, receiver)

- target: 目标对象
- propKey: 属性名
- value: 属性值
- receiver: proxy 实例本身,严格地说，是操作行为所针对的对象，可选
</code></pre>
<h4 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h4><pre><code>const validator=&#123;
  set(target,propKey,value)&#123;
    if(propKey===&quot;age&quot;)&#123;
    if(!Number.isInteger(value))&#123;
      throw new TypeError(&#39;The age is not an integer&#39;);
    &#125;else if(value&gt;100)&#123;
      throw new RangeError(&#39;The age seems invalid&#39;);
    &#125;
    &#125;
    target[propKey]=value
  &#125;
&#125;
const person=new Proxy(&#123;&#125;,validator)
</code></pre>
<p>运行结果：</p>
<p><img src="4.jpg"></p>
<p>这是数据验证的一种实现方法。利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM（Vue 3.x的版本采用此方法）</p>
<h4 id="receiver-参数-1"><a href="#receiver-参数-1" class="headerlink" title="receiver 参数"></a>receiver 参数</h4><pre><code>const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = receiver;
  &#125;
&#125;;
const proxy = new Proxy(&#123;&#125;, handler);

const b = &#123;&#125;;
Object.setPrototypeOf(b, proxy); 
//Object.setPrototypeOf 将一个指定的对象的原型设置为另一个对象
// 等同于 const b = Object.create(proxy)
</code></pre>
<p>运行结果：</p>
<pre><code>  b.a ===b;  //false
  b.a = &#39;bar&#39;;//&quot;bar&quot;
  b.a ===b; //true
</code></pre>
<p>设置b.a属性的值时，b并没有a属性，因此引擎会到b的原型链去找a属性。b的原型对象proxy是一个 Proxy 实例，设置它的a属性会触发set方法。这时，第四个参数receiver就指向原始赋值行为所在的对象b</p>
<h4 id="不可写配置且不可写属性的拦截-1"><a href="#不可写配置且不可写属性的拦截-1" class="headerlink" title="不可写配置且不可写属性的拦截"></a>不可写配置且不可写属性的拦截</h4><pre><code>  const obj = &#123;&#125;;
  Object.defineProperty(obj, &#39;foo&#39;, &#123;
    value: &#39;bar&#39;,
    writable: false,
  &#125;);

  const handler = &#123;
    set: function(obj, prop, value, receiver) &#123;
      obj[prop] = &#39;baz&#39;;
    &#125;
  &#125;;

  const proxy = new Proxy(obj, handler);
</code></pre>
<p>运行结果：</p>
<pre><code>  proxy.foo = &#39;baz&#39;;
  proxy.foo // &quot;bar&quot;
</code></pre>
<p>obj.foo属性不可写，所以代理不生效，并且不会报错</p>
<p><strong>注意，严格模式下，set代理必须返回true，否则就会报错。</strong></p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p>apply方法拦截函数的调用、call和apply操作, apply方法可以接受三个参数:</p>
<pre><code>apply(target, object, args)

- target: 目标对象
- object: 目标对象的上下文对象（this）
- args: 目标对象的参数数组
</code></pre>
<p>拦截 Proxy 实例作为函数调用的操作，比如 proxy(…args)、 proxy.call(object, …args) 、proxy.apply(…)、Reflect.apply(proxy,…)都会被拦截。</p>
<pre><code>const foo=()=&gt;&#123;
  return &#39;I am the target&#39;;
&#125;
const p= new Proxy(foo,&#123;
  apply(target, ctx, args)&#123;
    console.log(target===foo)
    console.log([...args])
    return &quot;I am Proxy apply&quot;
  &#125;
&#125;)
p(1,2,3);
</code></pre>
<p>运行结果：</p>
<pre><code>true
[1, 2, 3]
&quot;I am Proxy apply&quot;
</code></pre>
<h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p>has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。可以接受两个参数，</p>
<pre><code>has(target, propKey)

- target: 目标对象
- propKey: 需查询的属性名
</code></pre>
<p>拦截 propKey in proxy的操作，返回一个布尔值。典型的操作就是in运算符。</p>
<pre><code>var handler = &#123;
  has (target, key) &#123;
    if (key[0] === &#39;_&#39;) &#123;
      return false;
    &#125;
    return key in target;
  &#125;
&#125;;
var target = &#123; _prop: &#39;foo&#39;, prop: &#39;bar&#39; &#125;;
var proxy = new Proxy(target, handler);
&#39;_prop&#39; in proxy; //false
&#39;prop&#39; in proxy;//true
</code></pre>
<p>has方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has方法不判断一个属性是对象自身的属性，还是继承的属性。</p>
<p>虽然for…in循环也用到了in运算符，但是has拦截对for…in循环不生效</p>
<pre><code>for(let k in proxy)&#123;
  console.log(k);
    //_prop
    // prop
&#125;
</code></pre>
<h3 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h3><p>construct方法用于拦截new命令，可以接受两个参数:</p>
<pre><code>construct(target, args)
- target：目标对象
- args：构造函数的参数对象
</code></pre>
<p>拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</p>
<pre><code>var p = new Proxy(function () &#123;&#125;, &#123;
  construct: function(target, args) &#123;
    console.log(&#39;called: &#39; + args.join(&#39;, &#39;));
    return &#123; value: args[0] * 10 &#125;;
  &#125;
&#125;);

(new p(1)).value 
 //called: 1
 // 10
</code></pre>
<p>construct方法返回的必须是一个对象，否则会报错。</p>
<h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><p>deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。</p>
<pre><code>  deleteProperty(target, propKey)
  
  - target：目标对象
  - propKey：要删除的属性名
</code></pre>
<p>删除”_”开头的属性会报错：</p>
<pre><code>  var handler = &#123;
    deleteProperty (target, propKey) &#123;
    if(propKey.match(/^_/))&#123;
      throw new Error(&quot;unable delect &quot;+propKey)
    &#125;else&#123;
      delete target[propKey];
    &#125;
      return true;
    &#125;
  &#125;;
  const person=&#123;
    name:&quot;Tom&quot;,
    _age:&quot;10&quot;
  &#125;
var proxy=new Proxy(person,handler)
delete proxy._age;//报错
</code></pre>
<p>注意，目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错。</p>
<h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h3><blockquote>
<p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象</p>
</blockquote>
<p>defineProperty方法会拦截Object.defineProperty 和 Object.defineProperties操作。返回一个布尔值</p>
<pre><code>defineProperty (target, propKey, descriptor)

- target：目标对象
- propKey：要删除的属性名
- descriptor: 将被定义或修改的属性的描述符，参见Object.defineProperty中的描述符
</code></pre>
<p>例如：</p>
<pre><code>var handler = &#123;
  defineProperty (target, key, descriptor) &#123;
    return false;
  &#125;
&#125;;
var target = &#123;&#125;;
var proxy = new Proxy(target, handler);
proxy.foo = &#39;bar&#39; // 不会生效
</code></pre>
<p>上面代码中，defineProperty方法返回false，导致添加新属性总是无效。</p>
<h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h3><blockquote>
<p>Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）<br>Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符</p>
</blockquote>
<p>getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。</p>
<pre><code>getOwnPropertyDescriptor (target, propKey)

- target：目标对象
- propKey：目标属性名
</code></pre>
<h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h3><blockquote>
<p>Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值</p>
</blockquote>
<p>getPrototypeOf方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。</p>
<pre><code>Object.prototype.__proto__
Object.prototype.isPrototypeOf()
Object.getPrototypeOf()
Reflect.getPrototypeOf()
instanceof
</code></pre>
<p>方法所需参数：<br>    getPrototypeOf (target)</p>
<pre><code>- target：目标对象
</code></pre>
<p>下面是一个例子。</p>
<pre><code>var proto = &#123;&#125;;
var p = new Proxy(&#123;&#125;, &#123;
  getPrototypeOf(target) &#123;
    return proto;
  &#125;
&#125;);
Object.getPrototypeOf(p) === proto // true
</code></pre>
<p>上面代码中，getPrototypeOf方法拦截Object.getPrototypeOf()，返回proto对象。该方法的返回值必须是对象或者null，否则报错。</p>
<h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h3><blockquote>
<p>Object.isExtensible() 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。</p>
</blockquote>
<p>isExtensible方法拦截Object.isExtensible操作</p>
<p>方法所需参数：</p>
<pre><code>isExtensible (target)

- target：目标对象
</code></pre>
<p>举个例子：</p>
<pre><code>var p = new Proxy(&#123;&#125;, &#123;
  isExtensible(target) &#123;
    console.log(&quot;called&quot;);
    return true;
  &#125;
&#125;);

Object.isExtensible(p)
// &quot;called&quot;
// true
</code></pre>
<p>上面代码设置了isExtensible方法，在调用Object.isExtensible时会输出called。</p>
<p>注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。</p>
<p>这个方法有一个强限制，它的返回值必须与目标对象的isExtensible属性保持一致，否则就会抛出错误，即：</p>
<pre><code>Object.isExtensible(proxy) === Object.isExtensible(target);//true
</code></pre>
<h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h3><blockquote>
<p>Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组<br>Object.getOwnPropertySymbols() 方法返回一个给定对象自身的所有 Symbol 属性的数组。<br>Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 。</p>
</blockquote>
<p>ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p>
<pre><code>Object.getOwnPropertyNames()
Object.getOwnPropertySymbols()
Object.keys()
for...in循环
</code></pre>
<p>方法所需参数：</p>
<pre><code>ownKeys (target)

- target：目标对象
</code></pre>
<p>举个例子：</p>
<pre><code>let obj = &#123;
  a: 1,
  b: 2,
  c: 3,
  [Symbol.for(&#39;d&#39;)]:4
&#125;;
var proxy = new Proxy(obj, &#123;
  ownKeys: function(target) &#123;
    return [&#39;a&#39;, &#39;b&#39;, Symbol.for(&#39;d&#39;)];
  &#125;
&#125;);

Object.getOwnPropertyNames(proxy); //[&quot;a&quot;, &quot;b&quot;]
Object.keys(proxy); //[&quot;a&quot;, &quot;b&quot;]
Object.getOwnPropertySymbols(proxy); //[Symbol(d)]
for (let key in proxy) &#123;
  console.log(key); // a // b
&#125;
</code></pre>
<p>注：Symbol 作为属性名，遍历对象的时候，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回，只能通过Object.getOwnPropertySymbols()方法获取。</p>
<h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h3><blockquote>
<p>Object.preventExtensions()方法让一个对象变的不可扩展，也就是永远不能再添加新的属性</p>
</blockquote>
<p>preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。</p>
<pre><code>preventExtensions (target)

- target：目标对象
</code></pre>
<p>例子：</p>
<pre><code>var proxy = new Proxy(&#123;&#125;, &#123;
  preventExtensions: function(target) &#123;
    return true;
  &#125;
&#125;);

Object.preventExtensions(proxy);//报错
</code></pre>
<p>这个方法有一个限制，只有目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true，否则会报错。</p>
<h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h3><blockquote>
<p>Object.setPrototypeOf() 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或  null。</p>
</blockquote>
<p>setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。</p>
<pre><code>setPrototypeOf (target, propKey)

- target：目标对象
- propKey：目标属性名
</code></pre>
<p>修改目标对象的原型：</p>
<pre><code>var handler = &#123;
  setPrototypeOf (target, proto) &#123;
    throw new Error(&#39;Changing the prototype is forbidden&#39;);
  &#125;
&#125;;
var proto = &#123;&#125;;
var target = function () &#123;&#125;;
var proxy = new Proxy(target, handler);
Object.setPrototypeOf(proxy, proto);
// Error: Changing the prototype is forbidden
</code></pre>
<p>只要修改target的原型对象，就会报错；注意，该方法只能返回布尔值，否则会被自动转为布尔值。</p>
<h2 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h2><p>Proxy.revocable方法返回一个可取消的 Proxy 实例。</p>
<pre><code>  let target = &#123;&#125;;
  let handler = &#123;&#125;;

  let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);

  proxy.foo = 123;
  proxy.foo // 123

  revoke();
  proxy.foo // TypeError: Revoked
</code></pre>
<p>Proxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<h2 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h2><p>Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理:</p>
<pre><code>  const target = &#123;
    m: function () &#123;
      console.log(this === proxy);
    &#125;
  &#125;;
  const handler = &#123;&#125;;

  const proxy = new Proxy(target, handler);

  target.m() // false
  proxy.m()  // true
</code></pre>
<h2 id="Reflect-对象"><a href="#Reflect-对象" class="headerlink" title="Reflect 对象"></a>Reflect 对象</h2><p>Reflect对象的设计目的有如下几个：</p>
<ol>
<li><p>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</p>
</li>
<li><p>修改某些Object方法的返回结果，让其变得更合理：</p>
<pre><code>Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误
Reflect.defineProperty(obj, name, desc)则会返回false
</code></pre>
</li>
<li><p>让Object操作都变成函数行为。</p>
<pre><code>const obj=&#123;name:&quot;Jack&quot;&#125;;
// 老写法
name in obj // true
delete obj[name]

 // 新写法
 Reflect.has(obj, &#39;name&#39;) // true
 Reflect.deleteProperty(obj, name);//true
</code></pre>
</li>
<li><p>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法</p>
<pre><code> var loggedObj = new Proxy(obj, &#123;
   get(target, name) &#123;
     console.log(&#39;get&#39;, target, name);
     return Reflect.get(target, name);
   &#125;,
   deleteProperty(target, name) &#123;
     console.log(&#39;delete&#39; + name);
     return Reflect.deleteProperty(target, name);
   &#125;,
   has(target, name) &#123;
     console.log(&#39;has&#39; + name);
     return Reflect.has(target, name);
   &#125;
 &#125;);
 //每一个Proxy对象的拦截操作（get、delete、has），内部都调用对应的Reflect方法，保证原生行为能够正常执行。同时每一个操作输出一行日志。
 //也就是说:无论Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为
</code></pre>
</li>
</ol>
<h2 id="Reflect-静态方法"><a href="#Reflect-静态方法" class="headerlink" title="Reflect 静态方法"></a>Reflect 静态方法</h2><h3 id="Reflect-get"><a href="#Reflect-get" class="headerlink" title="Reflect.get()"></a>Reflect.get()</h3><p>用来读取一个对象的属性：<br>      Reflect.get(target, propKey [, receiver])</p>
<pre><code>  - target：目标对象
  - propKey：目标属性名称
  - receiver：可选，如果propKey的getter函数里面有this值，那么receiver就是这个this所代表的上下文
</code></pre>
<p>例子：</p>
<pre><code>  var myObject = &#123;
    foo: 1,
    bar: 2,
    get baz() &#123;
      return this.foo + this.bar;
    &#125;,
  &#125;;
  Reflect.get(myObject, &#39;foo&#39;);//1
  Reflect.get(myObject, &#39;baz&#39;);//3
  Reflect.get(myObject, &#39;baz&#39;,&#123;foo:5,bar:40&#125;);//45
</code></pre>
<h3 id="Reflect-set"><a href="#Reflect-set" class="headerlink" title="Reflect.set()"></a>Reflect.set()</h3><p>在一个对象身上设置一个属性：</p>
<pre><code>  Reflect.set(target, propKey, value[, receiver])
  
  - target：目标对象
  - propKey：目标属性名称
  - value：要设置的属性值
  - receiver：可选，如果在设置值的时候遇到setter函数，那么receiver值表示的就是setter函数中的this值。这个函数会返回一个Boolean值，表示在目标对象上设置属性是否成功
</code></pre>
<p>例子：</p>
<pre><code>  var myObject=&#123;
    foo: 1,
    set bar(value) &#123;
      return this.foo = value;
    &#125;,
  &#125;
  myObject.foo;//1
  Reflect.set(myObject, &#39;foo&#39;, 2);//true
  myObject.foo;//2
  Reflect.set(myObject, &#39;bar&#39;, 100);//true
  myObject.foo;//100
</code></pre>
<h3 id="Reflect-apply"><a href="#Reflect-apply" class="headerlink" title="Reflect.apply()"></a>Reflect.apply()</h3><p>通过指定的参数列表，来调用函数target，等同于Function.prototype.apply.call(func, thisArg, args)</p>
<pre><code>  Reflect.apply(target, thisArg, args)

  - target：目标函数
  - thisArg：target函数调用的时候绑定的this对象
  - args：函数的参数列表
</code></pre>
<p>一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)，采用Reflect对象可以简化这种操作。</p>
<p>例子：</p>
<pre><code> const ages = [11, 33, 12, 54, 18, 96];

// 旧写法
const youngest = Math.min.apply(Math, ages);
const oldest = Math.max.apply(Math, ages);
const type = Object.prototype.toString.call(youngest);

// 新写法
const youngest = Reflect.apply(Math.min, Math, ages);
const oldest = Reflect.apply(Math.max, Math, ages);
const type = Reflect.apply(Object.prototype.toString, youngest, []);
</code></pre>
<h3 id="Reflect-has"><a href="#Reflect-has" class="headerlink" title="Reflect.has()"></a>Reflect.has()</h3><p>检查一个对象上是否含有特定的属性。Reflect.has方法对应name in obj里面的in运算符。</p>
<pre><code>  Reflect.has(target, propKey)

  - target：目标对象
  - propKey：目标属性
</code></pre>
<p>例子：</p>
<pre><code>  var myObject = &#123;
    foo: 1,
  &#125;;

  // 旧写法
  &#39;foo&#39; in myObject // true

  // 新写法
  Reflect.has(myObject, &#39;foo&#39;) // true
</code></pre>
<p>如果Reflect.has()方法的第一个参数不是对象，会报错。</p>
<h3 id="Reflect-construct-target-args"><a href="#Reflect-construct-target-args" class="headerlink" title="Reflect.construct(target, args)"></a>Reflect.construct(target, args)</h3><p>Reflect.construct方法等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。</p>
<pre><code>  Reflect.construct(target, args)

  - target：运行的目标函数
  - args：调用构造函数传递的参数数组或者伪数组
</code></pre>
<p>例子：</p>
<pre><code>  function Greeting(name) &#123;
    this.name = name;
  &#125;

  // new 的写法
  const instance = new Greeting(&#39;张三&#39;);

  // Reflect.construct 的写法
  const instance = Reflect.construct(Greeting, [&#39;张三&#39;]);
</code></pre>
<h3 id="Reflect-deleteProperty-target-name"><a href="#Reflect-deleteProperty-target-name" class="headerlink" title="Reflect.deleteProperty(target, name)"></a>Reflect.deleteProperty(target, name)</h3><p>用于删除一个对象上的属性，等同于delete obj[name]，用于删除对象的属性。</p>
<pre><code>  Reflect.deleteProperty(target, propKey)

  - target：目标对象
  - propKey：目标属性名称
</code></pre>
<p>例子：</p>
<pre><code>  const myObj = &#123; foo: &#39;bar&#39; &#125;;

  // 旧写法
  delete myObj.foo;

  // 新写法
  Reflect.deleteProperty(myObj, &#39;foo&#39;);
</code></pre>
<p>该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false。  </p>
<p>如果Reflect.deleteProperty()方法的第一个参数不是对象，会报错。</p>
<h3 id="Reflect-defineProperty-target-name-desc"><a href="#Reflect-defineProperty-target-name-desc" class="headerlink" title="Reflect.defineProperty(target, name, desc)"></a>Reflect.defineProperty(target, name, desc)</h3><p>Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。</p>
<pre><code>  Reflect.defineProperty(target, propKey, desc)

  - target：目标对象
  - propKey：目标属性名称
  - desc：将被定义或修改的属性的描述符，参见Object.defineProperty中的描述符
</code></pre>
<p>例子：</p>
<pre><code>    function MyDate() &#123;
      /*…*/
    &#125;

    // 旧写法
    Object.defineProperty(MyDate, &#39;now&#39;, &#123;
      value: () =&gt; Date.now()
    &#125;);

    // 新写法
    Reflect.defineProperty(MyDate, &#39;now&#39;, &#123;
      value: () =&gt; Date.now()
    &#125;);
</code></pre>
<h3 id="Reflect-getOwnPropertyDescriptor"><a href="#Reflect-getOwnPropertyDescriptor" class="headerlink" title="Reflect.getOwnPropertyDescriptor()"></a>Reflect.getOwnPropertyDescriptor()</h3><p>Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。</p>
<pre><code>  Reflect.getOwnPropertyDescriptor(target, propKey)

  - target：目标对象
  - propKey：目标属性
</code></pre>
<p>例子：</p>
<pre><code>  var myObject = &#123;&#125;;
  Object.defineProperty(myObject, &#39;hidden&#39;, &#123;
    value: true,
    enumerable: false,
  &#125;);

  // 旧写法
  var theDescriptor = Object.getOwnPropertyDescriptor(myObject, &#39;hidden&#39;);

  // 新写法
  var theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, &#39;hidden&#39;);
</code></pre>
<h3 id="Reflect-getPrototypeOf-target"><a href="#Reflect-getPrototypeOf-target" class="headerlink" title="Reflect.getPrototypeOf(target)"></a>Reflect.getPrototypeOf(target)</h3><p>用于读取对象的__proto__属性, 等同Object.getPrototypeOf方法，都是返回一个对象的原型</p>
<pre><code>  Reflect.getPrototypeOf(target)

  - target：目标对象
</code></pre>
<p>例子：</p>
<pre><code>const myObj = new FancyThing();

// 旧写法
Object.getPrototypeOf(myObj) === FancyThing.prototype;

// 新写法
Reflect.getPrototypeOf(myObj) === FancyThing.prototype;
</code></pre>
<h3 id="Reflect-isExtensible-target"><a href="#Reflect-isExtensible-target" class="headerlink" title="Reflect.isExtensible(target)"></a>Reflect.isExtensible(target)</h3><p>方法等同Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。</p>
<pre><code>  Reflect.isExtensible(target)

  - target：目标对象
</code></pre>
<p>例子：</p>
<pre><code>  const myObject = &#123;&#125;;

  // 旧写法
  Object.isExtensible(myObject) // true

  // 新写法
  Reflect.isExtensible(myObject) // true
</code></pre>
<h3 id="Reflect-ownKeys-target"><a href="#Reflect-ownKeys-target" class="headerlink" title="Reflect.ownKeys(target)"></a>Reflect.ownKeys(target)</h3><p>用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和</p>
<pre><code>  Reflect.ownKeys(target)

  - target：目标对象
</code></pre>
<p>例子：</p>
<pre><code>  var myObject = &#123;
    foo: 1,
    bar: 2,
    [Symbol.for(&#39;baz&#39;)]: 3,
    [Symbol.for(&#39;bing&#39;)]: 4,
  &#125;;

  // 旧写法
  Object.getOwnPropertyNames(myObject)
  // [&#39;foo&#39;, &#39;bar&#39;]

  Object.getOwnPropertySymbols(myObject)
  //[Symbol(baz), Symbol(bing)]

  // 新写法
  Reflect.ownKeys(myObject)
  // [&#39;foo&#39;, &#39;bar&#39;, Symbol(baz), Symbol(bing)]
  如果Reflect.ownKeys()方法的第一个参数不是对象，会报错。
</code></pre>
<h3 id="Reflect-preventExtensions-target"><a href="#Reflect-preventExtensions-target" class="headerlink" title="Reflect.preventExtensions(target)"></a>Reflect.preventExtensions(target)</h3><p>对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。</p>
<pre><code>  Reflect.preventExtensions(target)

  - target：目标对象
</code></pre>
<p>例子：</p>
<pre><code>  var myObject = &#123;&#125;;

  // 旧写法
  Object.preventExtensions(myObject) // Object &#123;&#125;

  // 新写法
  Reflect.preventExtensions(myObject) // true
</code></pre>
<h3 id="Reflect-setPrototypeOf"><a href="#Reflect-setPrototypeOf" class="headerlink" title="Reflect.setPrototypeOf()"></a>Reflect.setPrototypeOf()</h3><p>用于设置目标对象的原型（prototype），对应Object.setPrototypeOf(obj, newProto)方法。它返回一个布尔值，表示是否设置成功。</p>
<pre><code>  Reflect.setPrototypeOf(target, propKey)

  - target：目标对象，
  - propKey：目标属性
</code></pre>
<p>例子：</p>
<pre><code>  const myObj = &#123;&#125;;

  // 旧写法
  Object.setPrototypeOf(myObj, Array.prototype);

  // 新写法
  Reflect.setPrototypeOf(myObj, Array.prototype);

  myObj.length // 0
</code></pre>
<p>如果无法设置目标对象的原型（比如，目标对象禁止扩展），<code>Reflect.setPrototypeO</code>f方法返回false。</p>
<pre><code>    Reflect.setPrototypeOf(&#123;&#125;, null)
    // true
    Reflect.setPrototypeOf(Object.freeze(&#123;&#125;), null)
    // false
</code></pre>
<p><code>Object.setPrototypeOf</code>与<code>Reflect.setPrototypeOf</code>差异：</p>
<pre><code>    /* 如果第一个参数不是对象，Object.setPrototypeOf会返回第一个参数本身，而Reflect.setPrototypeOf会报错。*/

    Object.setPrototypeOf(1, &#123;&#125;) // 1

    Reflect.setPrototypeOf(1, &#123;&#125;) // TypeError: Reflect.setPrototypeOf called on non-object
    
    
    /* 如果第一个参数是undefined或null，Object.setPrototypeOf和Reflect.setPrototypeOf都会报错。*/

    Object.setPrototypeOf(null, &#123;&#125;) // TypeError: Object.setPrototypeOf called on null or undefined

    Reflect.setPrototypeOf(null, &#123;&#125;) // TypeError: Reflect.setPrototypeOf called on non-object
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://es6.ruanyifeng.com/#docs/proxy">阮一峰ES6入门</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/24778807">知乎专栏-ES6 Reflect</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/50547367">知乎专栏-使用Proxy实现Vue数据劫持</a></li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列-5-Class与Module</title>
    <url>/ES6%E7%B3%BB%E5%88%97-5-Class%E4%B8%8EModule/</url>
    <content><![CDATA[<p>本篇介绍ES6的 Class（类）与 ES6的模块化方案</p>
<span id="more"></span>
<h2 id="Class-（类）"><a href="#Class-（类）" class="headerlink" title="Class （类）"></a>Class （类）</h2><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数实现的，但这种写法跟传统面向对象的语法（c++/java）等差异很大，ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>通过class关键字，可以定义类，这样更优雅，易于理解。</p>
<pre><code>class Person&#123;
  constructor(x) &#123;
    this.name = x;
  &#125;

  toSayHi() &#123;
    return &#39;Hello &#39;+this.name;
  &#125;
&#125;
const p1=new Person(&quot;jack&quot;);
p1.name; //&quot;jack&quot;
p1.toSayHi();//&quot;Hello jack&quot;
console.log(Object.keys(Person.prototype));//[] toSayHi方法是Person类内部定义的方法，它是不可枚举的
</code></pre>
<p>上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，this关键字则代表实例对象。<strong>注意：</strong>定义“类”的方法不需要function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。<br>上述代码等同于：</p>
<pre><code>function Person(x)&#123;
  this.name = x;
&#125;
Person.prototype.toSayHi=function()&#123;
  return &#39;Hello &#39;+this.name;
&#125;

const p1=new Person(&quot;jack&quot;);
p1.name; //&quot;jack&quot;
p1.toSayHi();//&quot;Hello jack&quot;
console.log(Object.keys(Person.prototype));//[&quot;toSayHi&quot;] ES5写法下，toSayHi方法是可以枚举的，
//注意ES6和ES5下此处的行为不一致
</code></pre>
<p>以上两种模式都满足：</p>
<pre><code>//等式1
p1.constructor===Person;//true  

//等式2
Person===Person.prototype.constructor;//true 

//等式3
p1.constructor===Person.prototype.constructor;//true
</code></pre>
<p>说明：</p>
<ol>
<li>每个实例对象都有一个 constructor（构造函数）属性，该属性指向创建它的构造函数，也就是说constructor始终指向创建当前对象的构造函数，所以等式1成立；</li>
<li>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针，即指向函数本身。所以等式2成立（参见下图）；<br><img src="1.png"></li>
<li>将等式1和等式2合并即可得到等式3成立。</li>
</ol>
<p>另外：类的内部所有定义的方法，都是不可枚举的（demo代码中已经标明）。  </p>
<p><strong>可以看到：</strong>ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<p>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。<code>Object.assign</code>方法可以很方便地一次向类添加多个方法：</p>
<pre><code>class Person&#123;
  constructor(x) &#123;
    this.name = x;
  &#125;
&#125;
Object.assign(Person.prototype,&#123;
  toSayHi() &#123;
    return &#39;Hello &#39;+this.name;
  &#125;,
  toValue()&#123;
    return &#39;value &#39; +this.name
  &#125;
&#125;)
const p1=new Person(&quot;jack&quot;);
console.log(p1.toSayHi()); //&quot;Hello jack&quot;
console.log(p1.toValue()); //&quot;value jack&quot;
</code></pre>
<h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h3><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加:</p>
<pre><code>function Person(x)&#123;
  this.name = x;
&#125;
console.log(Person.prototype)
class Person2&#123;
 
&#125;
console.log(Person2.prototype)
</code></pre>
<p><img src="2.png"></p>
<h3 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h3><p>同ES5一致，生成类的实例的写法，也是使用new命令。实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）</p>
<pre><code>//定义类
class Point &#123;

  constructor(x, y) &#123;
    this.x = x;
    this.y = y;
  &#125;

  toString() &#123;
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  &#125;

&#125;

var point = new Point(2, 3);

point.toString() // (2, 3)

point.hasOwnProperty(&#39;x&#39;) // true
point.hasOwnProperty(&#39;y&#39;) // true
point.hasOwnProperty(&#39;toString&#39;) // false
point.__proto__.hasOwnProperty(&#39;toString&#39;) // true
</code></pre>
<h3 id="取值函数（getter）和存值函数（setter）"><a href="#取值函数（getter）和存值函数（setter）" class="headerlink" title="取值函数（getter）和存值函数（setter）"></a>取值函数（getter）和存值函数（setter）</h3><p>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<pre><code>class Person&#123;
    constructor()&#123;
    &#125;
    get name()&#123;
        return &quot;getter&quot;
    &#125;
    set name(val)&#123;
        console.log(&quot;setter&quot;)
    &#125;
&#125;
const p = new Person()
console.log(p.name) ;// getter
p.name=&quot;x&quot;;// setter
console.log(Object.getOwnPropertyDescriptor(Person.prototype, &#39;name&#39;))
</code></pre>
<p>存值函数和取值函数是设置在属性的 Descriptor 对象上的:<br><img src="3.jpg"></p>
<h3 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h3><p>类的属性名，可以采用表达式。</p>
<pre><code>let methodName = &#39;getArea&#39;;

class Square &#123;
  constructor(length) &#123;
    // ...
  &#125;

  [methodName]() &#123;
    // ...
  &#125;
&#125;
</code></pre>
<h3 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h3><pre><code>  const MyPerson = class Person &#123;
  getClassName() &#123;
    return Person.name;
  &#125;
  &#125;;
const p =new MyPerson();
console.log(p.getClassName());//&quot;Person&quot;
const p1 =new Person(); // 报错 Uncaught ReferenceError: Person is not defined
</code></pre>
<p>类的名字是Person，但是Person只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用MyPerson引用;</p>
<p>如果类内部用不到 Person ，完全可以省略不写，也可以采用 Class 表达式，可以写出立即执行的 Class：  </p>
<pre><code>const p = new class &#123;
    constructor(name) &#123;
        this.name = name;
      &#125;
    getClassName() &#123;
      console.log(this.name)
    &#125;
  &#125;(&#39;张三&#39;);
p.getClassName();//&quot;张三&quot;
</code></pre>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><p>不存在提升</p>
<pre><code> new Person();
 class Person&#123;&#125;;
 //会报错

 new Person();
 function Person()&#123;&#125;
 //运行正常
</code></pre>
</li>
<li><p>name属性：<br>name属性总是返回紧跟在class关键字后面的类名：这点同ES5一样。</p>
</li>
<li><p>this 的指向<br>类的方法内部如果含有this，它默认指向类的实例。但如果单独使用该方法，那么很可能报错。推荐使用箭头函数：</p>
<pre><code> class Logger &#123;
   constructor() &#123;
     this.printName = (name = &#39;there&#39;) =&gt; &#123;
       this.print(`Hello $&#123;name&#125;`);
     &#125;;
   &#125;
 
   // ...
 &#125;
</code></pre>
</li>
</ol>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是<strong>直接通过类来调用</strong>，这就称为“静态方法”。</p>
<pre><code>    class Person &#123;
      static bar() &#123;
          this.baz();
        &#125;
      static baz() &#123;
          console.log(&#39;hello&#39;);
        &#125;
        baz() &#123;
          console.log(&#39;world&#39;);
        &#125;
    &#125;
    const p = new Person();
    Person.baz() // &#39;hello&#39;
    p.baz() //&#39;world&#39;
    Person.bar(); //hello 静态方法的this指的是类，而不是实例！！！
    p.bar() //报错 p.bar is not a function
</code></pre>
<p>可以看到：静态方法中的this关键字，指的是类，而不是实例。<br>父类的静态方法，可以被子类继承。</p>
<pre><code>    class Foo &#123;
      static classMethod() &#123;
        return &#39;hello&#39;;
      &#125;
    &#125;
    
    class Bar extends Foo &#123;
    &#125;
    
    Bar.classMethod() // &#39;hello&#39;
</code></pre>
<h3 id="实例属性的新写法"><a href="#实例属性的新写法" class="headerlink" title="实例属性的新写法"></a>实例属性的新写法</h3><p>实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性：</p>
<pre><code>class foo &#123;
  bar = &#39;hello&#39;;
  baz = &#39;world&#39;;

  constructor() &#123;
    // ...
  &#125;
&#125;
</code></pre>
<p>ps：上述写法目前在chrome中直接运行会报错。2019-02-24标注</p>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。  </p>
<pre><code>class Foo &#123;
&#125;

Foo.prop = 1;
Foo.prop // 1
</code></pre>
<p>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。  </p>
<p>现在有一个提案提供了类的静态属性，写法是在实例属性法的前面，加上static关键字(目前chrome未实现)：</p>
<pre><code>class Foo &#123;
  static prop=1
&#125;
</code></pre>
<h3 id="私有方法和私有属性"><a href="#私有方法和私有属性" class="headerlink" title="私有方法和私有属性"></a>私有方法和私有属性</h3><p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。<br>具体实现方法可参见，目前还没有特别完美的方案<a href="http://es6.ruanyifeng.com/#docs/class#%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%92%8C%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7">私有属性和方法</a>，新版的提案（前面加#号）暂时还未实现。</p>
<h3 id="new-target-属性"><a href="#new-target-属性" class="headerlink" title="new.target 属性"></a>new.target 属性</h3><p>new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<pre><code>function Person(name) &#123;
  if (new.target !== undefined) &#123;
    this.name = name;
  &#125; else &#123;
    throw new Error(&#39;必须使用 new 命令生成实例&#39;);
  &#125;
&#125;

// 另一种写法
function Person(name) &#123;
  if (new.target === Person) &#123;
    this.name = name;
  &#125; else &#123;
    throw new Error(&#39;必须使用 new 命令生成实例&#39;);
  &#125;
&#125;

var person = new Person(&#39;张三&#39;); // 正确
var notAPerson = Person.call(person, &#39;张三&#39;);  // 报错
</code></pre>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p>Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多：</p>
<pre><code>class Animal&#123;
  constructor()&#123;
    this.food=&quot;meat&quot;
  &#125;
  sayHi()&#123;
    console.log(&quot;I am animal, I eat &quot;+ this.food)
  &#125;
  food()&#123;
    return this.food
  &#125;
&#125;

class Cat extends Animal&#123;
  constructor()&#123;
    super(); //子类必须在constructor方法中调用super方法，否则新建实例时会报错
    this.color=&quot;black&quot;;
  &#125;
  sayHi()&#123;
    console.log(&quot;I am cat, I eat &quot;+ super.food() + &quot;, my color is &quot;+this.color )
    console.log(&quot;I am cat, I eat &quot;+ this.food + &quot;, my color is &quot;+this.color );
    //继承了父级的food属性
    // 子类方法中调用父类方法，必须通过super关键字，super.food()
  &#125;
&#125;
const cat=new Cat();
const ani= new Animal();
ani.sayHi(); //I am animal, I eat meat
cat.sayHi(); //I am cat, I eat meat, my color is black    I am cat, I eat meat, my color is black
</code></pre>
<p>注意：  </p>
<ol>
<li><p>子类方法中super关键字的调用：子类必须在constructor方法中调用super方法，否则新建实例时会报错。子类方法中如果需要调用父级的方法，需通过super关键字。  </p>
</li>
<li><p>ES6继承机制同ES5完全不同：先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。而ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（<code>Parent.apply(this)</code>）</p>
</li>
<li><p>不管有没有显式定义，任何一个子类都有constructor方法（会被默认添加）。</p>
<pre><code> class ColorPoint extends Point &#123;
 &#125;
 
 // 等同于
 class ColorPoint extends Point &#123;
   constructor(...args) &#123;
     super(...args);
   &#125;
 &#125;
</code></pre>
</li>
<li><p>通过子类创建的实例，同时是Cat和Animal两个类的实例，这与 ES5 的行为完全一致。</p>
<pre><code> const cat=new Cat();
 cat instanceof Cat;//true
 cat instanceof Animal; //true
</code></pre>
</li>
<li><p>父类的静态方法，也会被子类继承。</p>
<pre><code> class A &#123;
   static hello() &#123;
     console.log(&#39;hello world&#39;);
   &#125;
 &#125;
 
 class B extends A &#123;
 &#125;
 
 B.hello()  // hello world
</code></pre>
<h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3></li>
</ol>
<p>Object.getPrototypeOf方法可以用来从子类上获取父类，可以使用这个方法判断，一个类是否继承了另一个类：</p>
<pre><code>Object.getPrototypeOf(Cat) === Animal
</code></pre>
<h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><p>super这个关键字，既可以当作函数使用，也可以当作对象使用： </p>
<ol>
<li><p>super作为函数调用时，代表父类的构造函数。并且<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p>
</li>
<li><p>super作为对象时（在普通方法中）：指向父类的原型对象（<code>A.prototype</code>）；</p>
<pre><code> class A &#123;
   p() &#123;
     return 2;
   &#125;
 &#125;
 
 class B extends A &#123;
   constructor() &#123;
     super();
     console.log(super.p()); // 2  相当于A.prototype.p()。
   &#125;
 &#125;
 
 let b = new B();
 b.m // undefined  super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。
</code></pre>
<p>ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。</p>
<pre><code> class A &#123;
   constructor() &#123;
     this.x = 1;
   &#125;
   print() &#123;
     console.log(this.x);
   &#125;
 &#125;
 
 class B extends A &#123;
   constructor() &#123;
     super();
     this.x = 2;
     super.x = 3;
     console.log(super.x); // undefined 
     console.log(this.x); // 3
   &#125;
   m() &#123;
     super.print();
   &#125;
 &#125;
 
 let b = new B();
 b.m() // 3  A.prototype.print()内部的this指向子类B的实例，而不是A.prototype
</code></pre>
<p>上面代码中可以看到：如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性：<code>super.x</code>赋值为3，这时等同于对<code>this.x</code>赋值为3。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回undefined。  </p>
</li>
<li><p>super作为对象时（在静态方法中）：指向父类。而不是父类的原型对象。</p>
<pre><code> class Parent &#123;
   static myMethod(msg) &#123;
     console.log(&#39;static&#39;, msg);
     //静态方法中的this指向Parent而不是Parent的实例
   &#125;
 
   myMethod(msg) &#123;
     console.log(&#39;instance&#39;, msg);
   &#125;
 &#125;
 
 class Child extends Parent &#123;
   static myMethod(msg) &#123;
     super.myMethod(msg);
   &#125;
 
   myMethod(msg) &#123;
     super.myMethod(msg);
   &#125;
 &#125;
 
 Child.myMethod(1); // static 1  父类直接调用，会返回静态方法
 
 var child = new Child();
 child.myMethod(2); // instance 2 实例调用，会返回父类的原型对象方法
</code></pre>
<p>在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。</p>
<pre><code> class A &#123;
   constructor() &#123;
     this.x = 1;
   &#125;
   static print() &#123;
     console.log(this.x);
   &#125;
 &#125;
 
 class B extends A &#123;
   constructor() &#123;
     super();
     this.x = 2;
   &#125;
   static m() &#123;
     super.print();
   &#125;
 &#125;
 
 B.x = 3;
 B.m() // 3  B.m里面，super.print指向父类的静态方法。这个方法里面的this指向的是B，而不是B的实例。
</code></pre>
</li>
<li><p>使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p>
</li>
<li><p>由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。</p>
</li>
</ol>
<h3 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h3><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。</p>
<pre><code>Boolean()
Number()
String()
Array()
Date()
Function()
RegExp()
Error()
Object()
</code></pre>
<p>ES6之前这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。<br>    function MyArray() {<br>        Array.apply(this, arguments);<br>      }</p>
<pre><code>  MyArray.prototype = Object.create(Array.prototype, &#123;
    constructor: &#123;
      value: MyArray,
      writable: true,
      configurable: true,
      enumerable: true
    &#125;
  &#125;);

  var colors = new MyArray();
  colors[0] = &quot;red&quot;;
  colors.length  // 0
</code></pre>
<p>但是，在ES6中，通过class关键字可以实现原生构造函数的继承：</p>
<pre><code>class MyArray extends Array &#123;
  constructor(...args) &#123;
    super(...args);
  &#125;
&#125;

var arr = new MyArray();
arr[0] = 12;
arr.length // 1

arr.length = 0;
arr[0] // undefined
</code></pre>
<p>extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。</p>
<h3 id="补充-实例-构造函数和原型链"><a href="#补充-实例-构造函数和原型链" class="headerlink" title="补充: 实例/构造函数和原型链"></a>补充: 实例/构造函数和原型链</h3><p>简单回顾一下构造函数、原型和实例的关系：<strong>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针</strong></p>
<pre><code>class Person&#123;
  constructor(x) &#123;
    this.name = x;
  &#125;

  toSayHi() &#123;
    return &#39;Hello &#39;+this.name;
  &#125;
&#125;
const p1=new Person(&quot;jack&quot;);

//每个构造函数都有一个原型对象(prototype)
console.log(0,Person.prototype);
    //0,&#123;
    //  constructor: class Person
    //    toSayHi: ƒ toSayHi()
    //    __proto__: Object
    //    &#125;

//原型对象都包含一个指向构造函数的指针(constructor)
console.log(1,Person===Person.prototype.constructor);

//实例都包含一个指向原型对象的内部指针(这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间)
console.log(2,p1.__proto__===Person.prototype);//true
 
</code></pre>
<p><img src="4.jpg"></p>
<p>同时以上代码还满足</p>
<pre><code>//实例会自动含有一个constructor属性，指向它们的构造函数,
console.log(3,p1.constructor===Person);//true

// instanceof运算符，验证原型对象与实例对象之间的关系。
console.log(4,p1 instanceof Person); //true
console.log(5,p1 instanceof Object); //true
</code></pre>
<h2 id="Module-的语法"><a href="#Module-的语法" class="headerlink" title="Module 的语法"></a>Module 的语法</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>ES6 模块的设计思想是尽量的静态化，而commonJS则是使用“运行时加载”，因为只有运行时才能得到这个对象。</p>
<pre><code>// CommonJS模块
let &#123; stat, exists, readFile &#125; = require(&#39;fs&#39;);

// 等同于
let _fs = require(&#39;fs&#39;);
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
</code></pre>
<p>上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”。</p>
<p><strong>ES6 模块不是对象</strong>，而是通过export命令显式指定输出的代码，再通过import命令输入。</p>
<pre><code>// ES6模块
import &#123; stat, exists, readFile &#125; from &#39;fs&#39;;
</code></pre>
<p>上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。同时这也使得静态分析成为可能（如引入宏或类型检验）。</p>
<p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”。</p>
<p>import和export命令只能在模块的顶层，不能在代码块之中。</p>
<h3 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h3><ol>
<li><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p>
<pre><code> //写法一
 // profile.js
 export var firstName = &#39;Michael&#39;;
 export var lastName = &#39;Jackson&#39;;
 export var multiply = function (x, y) &#123;
       return x * y;
 &#125;;

 //写法二
 var firstName = &#39;Michael&#39;;
 var lastName = &#39;Jackson&#39;;
 var multiply = function (x, y) &#123;
       return x * y;
 &#125;;
 
 export &#123;firstName, lastName, multiply&#125;;
</code></pre>
</li>
<li><p>as关键字重命名:通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。</p>
<pre><code> function v1() &#123; ... &#125;
 function v2() &#123; ... &#125;
 
 export &#123;
   v1 as streamV1,
   v2 as streamV2,
   v2 as streamLatestVersion
 &#125;;
</code></pre>
<p>上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。</p>
</li>
<li><p>export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。(这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新)。  </p>
</li>
<li><p>export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错。</p>
</li>
</ol>
<h3 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h3><p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。</p>
<pre><code>// main.js
import &#123;firstName, lastName, year&#125; from &#39;./profile.js&#39;;
</code></pre>
<ol>
<li><p>如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。</p>
<pre><code> import &#123; lastName as surname &#125; from &#39;./profile.js&#39;;
</code></pre>
</li>
<li><p>import命令输入的变量都是只读的，不允许在加载模块的脚本里面，改写接口。</p>
<pre><code> import &#123;a&#125; from &#39;./xxx.js&#39;
 a = &#123;&#125;; // Syntax Error : &#39;a&#39; is read-only;不允许重新赋值
 a.foo = &#39;hello&#39;; // 合法操作，改写属性是允许的
</code></pre>
</li>
<li><p>import命令具有提升效果，会提升到整个模块的头部，会首先执行。</p>
<pre><code> foo();
 
 import &#123; foo &#125; from &#39;my_module&#39;;
</code></pre>
</li>
<li><p>由于import是静态执行，所以不能使用表达式和变量</p>
<pre><code> // 报错
 import &#123; &#39;f&#39; + &#39;oo&#39; &#125; from &#39;my_module&#39;;
</code></pre>
</li>
<li><p>import语句会执行所加载的模块：</p>
<pre><code> import &#39;lodash&#39;;
</code></pre>
</li>
<li><p>如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。</p>
<pre><code> import &#39;lodash&#39;;
 import &#39;lodash&#39;;
</code></pre>
</li>
<li><p>模块加载时会自动判断：</p>
<pre><code> import &#123; foo &#125; from &#39;my_module&#39;;
 import &#123; bar &#125; from &#39;my_module&#39;;
 
 // 等同于
 import &#123; foo, bar &#125; from &#39;my_module&#39;;
</code></pre>
</li>
<li><p>模块的整体加载</p>
<pre><code> import * as circle from &#39;./circle&#39;;
 console.log(&#39;圆面积：&#39; + circle.area(4));
 console.log(&#39;圆周长：&#39; + circle.circumference(14));
 

 // 下面两行都是不允许的！！！！，因为是静态执行，所以不允许运行时改变
 circle.foo = &#39;hello&#39;;
 circle.area = function () &#123;&#125;;
</code></pre>
</li>
</ol>
<h3 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h3><p>该命令可以为模块指定默认输出：</p>
<pre><code>// export-default.js
export default function () &#123;
  console.log(&#39;foo&#39;);
&#125;
</code></pre>
<p>其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</p>
<pre><code>// import-default.js
import customName from &#39;./export-default&#39;; //需要注意的是，这时import命令后面，不使用大括号。!!!!!!
customName(); // &#39;foo&#39;
</code></pre>
<p>一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令。  </p>
<p>export default命令的本质是将后面的值，赋给default变量，所以可以直接将一个值写在export default之后：</p>
<pre><code>// 正确
export var a = 1;

// 正确
var a = 1;
export default a;

// 正确
export default 42;

// 错误
export default var a = 1;


// 报错
export 42;
</code></pre>
<p>也可以在一条import语句中，同时输入默认方法和其他接口：</p>
<pre><code>import _, &#123; each, forEach &#125; from &#39;lodash&#39;;
</code></pre>
<h3 id="export-与-import-的复合写法"><a href="#export-与-import-的复合写法" class="headerlink" title="export 与 import 的复合写法"></a>export 与 import 的复合写法</h3><p>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。</p>
<pre><code>export &#123; foo, bar &#125; from &#39;my_module&#39;;

// 可以简单理解为
import &#123; foo, bar &#125; from &#39;my_module&#39;;
export &#123; foo, bar &#125;;
</code></pre>
<p>写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致<strong>当前模块不能直接使用foo和bar</strong>。  </p>
<p>模块的接口改名和整体输出，也可以采用这种写法:</p>
<pre><code>// 接口改名
export &#123; foo as myFoo &#125; from &#39;my_module&#39;;

// 整体输出
export * from &#39;my_module&#39;;
</code></pre>
<p>默认接口、具名接口改为默认接口、默认接口改名为具名接口的写法如下：</p>
<pre><code>//默认接口
export &#123; default &#125; from &#39;foo&#39;;

//具名接口改默认
export &#123; es6 as default &#125; from &#39;./someModule&#39;;

// 等同于
import &#123; es6 &#125; from &#39;./someModule&#39;;
export default es6;

//默认接口改为具名接口
export &#123; default as es6 &#125; from &#39;./someModule&#39;;
</code></pre>
<h3 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h3><p>模块之间也可以继承。<br>假设有一个circleplus模块，继承了circle模块:</p>
<pre><code>// circleplus.js

export * from &#39;circle&#39;;
export var e = 2.71828182846;
export default function(x) &#123;
  return Math.exp(x);
&#125;
</code></pre>
<p>上面代码中的<code>export *</code>，表示再输出circle模块的所有属性和方法。注意，<code>export *</code>命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。</p>
<h3 id="跨模块常量"><a href="#跨模块常量" class="headerlink" title="跨模块常量"></a>跨模块常量</h3><p>如果一个值要被多个模块共享，可以采用下面的写法：</p>
<pre><code>// constants/db.js
export const db = &#123;
  url: &#39;http://my.couchdbserver.local:5984&#39;,
  admin_username: &#39;admin&#39;,
  admin_password: &#39;admin password&#39;
&#125;;

// constants/user.js
export const users = [&#39;root&#39;, &#39;admin&#39;, &#39;staff&#39;, &#39;ceo&#39;, &#39;chief&#39;, &#39;moderator&#39;];
</code></pre>
<p>将这些文件输出的常量，合并在index.js里面:</p>
<pre><code>// constants/index.js
export &#123;db&#125; from &#39;./db&#39;;
export &#123;users&#125; from &#39;./users&#39;;
</code></pre>
<p>最后使用的使用直接加载index.js就可以了：</p>
<pre><code>// script.js
import &#123;db, users&#125; from &#39;./constants/index&#39;;
</code></pre>
<h3 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h3><p>因为import和export命令只能在模块的顶层，不能在代码块之中。所以，如果ES6要取代Node的require方法（require是运行时加载模块），是无法实现的：</p>
<pre><code>const path = &#39;./&#39; + fileName;
const myModual = require(path);
</code></pre>
<p>因此，有一个提案，建议引入<code>import()</code>函数，完成动态加载：</p>
<pre><code>//import()返回一个 Promise 对象：

const main = document.querySelector(&#39;main&#39;);

import(`./section-modules/$&#123;someVariable&#125;.js`)
  .then(module =&gt; &#123;
    module.loadPageInto(main);
  &#125;)
  .catch(err =&gt; &#123;
    main.textContent = err.message;
  &#125;);
</code></pre>
<h2 id="Module-的加载实现"><a href="#Module-的加载实现" class="headerlink" title="Module 的加载实现"></a>Module 的加载实现</h2><p>浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间，所以会造成浏览器堵塞。所以浏览器很早就已经支持脚本的异步加载了：</p>
<pre><code>&lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt;
&lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt;
</code></pre>
<p>defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</p>
<h3 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h3><p>浏览器加载 ES6 模块，也使用<code>&lt;script&gt;</code>标签，但是要加入type=”module”属性。  </p>
<p>浏览器对于带有type=”module”的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的defer属性。</p>
<pre><code>&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot;&gt;&lt;/script&gt;
&lt;!--chrome下必须写相对引用地址，否则会有跨域提示警告，无法加载 --&gt;

&lt;!-- 等同于 --&gt;
&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot; defer&gt;&lt;/script&gt;
</code></pre>
<p><code>&lt;script&gt;</code>标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。</p>
<pre><code>&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot; async&gt;&lt;/script&gt;
</code></pre>
<p>一旦使用了async属性，<code>&lt;script type=&quot;module&quot;&gt;</code>就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。</p>
<p>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</p>
<pre><code>&lt;script type=&quot;module&quot;&gt;
  import utils from &quot;./utils.js&quot;;

  // other code
&lt;/script&gt;
</code></pre>
<p>此时需要几点：</p>
<ol>
<li>通过type=”module”加载的代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>
<li>模块之中，顶层的this关键字返回undefined，而不是指向window。</li>
<li>模块脚本自动采用严格模式，不管有没有声明use strict。</li>
<li>模块之中，可以使用import命令加载其他模块（.js后缀不可省略），也可以使用export命令输出对外接口。</li>
</ol>
<h3 id="与commonJS模块差异"><a href="#与commonJS模块差异" class="headerlink" title="与commonJS模块差异"></a>与commonJS模块差异</h3><p>它们有两个重大差异：</p>
<ol>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>
</ol>
<p>首先解释第一个差异：有如下两个js文件</p>
<pre><code>//lib.js
var counter = 3;
function incCounter() &#123;
  counter++;
&#125;
module.exports = &#123;
  counter: counter,
  incCounter: incCounter,
&#125;;

// main.js
var mod = require(&#39;./lib&#39;);

console.log(mod.counter);  // 3
mod.incCounter();
console.log(mod.counter); // 3
</code></pre>
<p>我们通过node运行后得到结果：</p>
<pre><code>$ node main.js
3
3
</code></pre>
<p>这说明CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p>
<pre><code>//lib.js
//同上，省略
module.exports = &#123;
  get counter() &#123;
    return counter
  &#125;,
  incCounter: incCounter,
&#125;;
</code></pre>
<p>我们再次通过node运行后得到结果：</p>
<pre><code>$ node main.js
3
4
</code></pre>
<p>而ES6 模块是动态引用，并且不会缓存值（通过chrome执行以下代码）</p>
<pre><code>//lib.js
let counter = 3;
let incCounter=function() &#123;
  counter++;
&#125;
export &#123;counter,incCounter&#125;

//main.js
import &#123; counter, incCounter &#125; from &#39;./lib.js&#39;;
console.log(counter); // 3
incCounter();
console.log(counter); // 4
</code></pre>
<p>第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p>
<h3 id="Node加载"><a href="#Node加载" class="headerlink" title="Node加载"></a>Node加载</h3><ol>
<li><p>Node 要求 ES6 模块采用.mjs后缀文件名。</p>
</li>
<li><p>require命令不能加载.mjs文件，会报错，只有import命令才可以加载.mjs文件。  </p>
</li>
<li><p>如果模块名不含路径，那么import命令会去node_modules目录寻找这个模块</p>
</li>
<li><p>Node 的import命令只支持加载本地模块（file:协议），不支持加载远程模块。</p>
<pre><code> 如果脚本文件省略了后缀名，比如import &#39;./foo&#39;，Node 会依次尝试四个后缀名：./foo.mjs、./foo.js、./foo.json、./foo.node。
 如果这些脚本文件都不存在，Node 就会去加载./foo/package.json的main字段指定的脚本。
 如果./foo/package.json不存在或者没有main字段，那么就会依次加载./foo/index.mjs、./foo/index.js、./foo/index.json、./foo/index.node。
 如果以上四个文件还是都不存在，就会抛出错误。
</code></pre>
</li>
</ol>
<h3 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h3><p>为了实现ES6 模块的通用性（浏览器环境和服务器环境通用）。Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量：</p>
<ol>
<li><p>this关键字：ES6 模块之中，顶层的this指向undefined；而CommonJS 模块的顶层this指向当前模块</p>
</li>
<li><p>以下顶层变量，在ES6的模块中也是不存在的</p>
<p> arguments<br> require<br> module<br> exports<br> __filename<br> __dirname</p>
<h3 id="ES6-模块-与-CommonJS-模块-互相加载"><a href="#ES6-模块-与-CommonJS-模块-互相加载" class="headerlink" title="ES6 模块 与 CommonJS 模块 互相加载"></a>ES6 模块 与 CommonJS 模块 互相加载</h3></li>
<li><p>ES6 模块加载 CommonJS 模块</p>
<pre><code> // a.js -- commonJS模块
 module.exports = &#123;
   foo: &#39;hello&#39;,
   bar: &#39;world&#39;
 &#125;;
 
 // 等同于
 export default &#123;
   foo: &#39;hello&#39;,
   bar: &#39;world&#39;
 &#125;;
</code></pre>
<p>故：一共有三种写法，可以拿到 CommonJS 模块的module.exports</p>
<pre><code> // 写法一
 import baz from &#39;./a&#39;;
 // baz = &#123;foo: &#39;hello&#39;, bar: &#39;world&#39;&#125;;
 
 // 写法二
 import &#123;default as baz&#125; from &#39;./a&#39;;
 // baz = &#123;foo: &#39;hello&#39;, bar: &#39;world&#39;&#125;;
 
 // 写法三
 import * as baz from &#39;./a&#39;;
 // baz = &#123;
 //   get default() &#123;return module.exports;&#125;,
 //   get foo() &#123;return this.default.foo&#125;.bind(baz),
 //   get bar() &#123;return this.default.bar&#125;.bind(baz)
 // &#125;
</code></pre>
</li>
<li><p>CommonJS 模块加载 ES6 模块</p>
<pre><code> // es.mjs
 let foo = &#123; bar: &#39;my-default&#39; &#125;;
 export default foo;

 // cjs.js
 const es_namespace = await import(&#39;./es.mjs&#39;);
 console.log(es_namespace.default);
</code></pre>
<p>不能使用require命令，而要使用import()函数。ES6 模块的所有输出接口，会成为输入对象的属性。</p>
</li>
</ol>
<h3 id="循环加载的处理机制"><a href="#循环加载的处理机制" class="headerlink" title="循环加载的处理机制"></a>循环加载的处理机制</h3><p>所谓“循环加载”（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。</p>
<ol>
<li><p>commonJS处理机制：  </p>
<pre><code> 首页，执行a.js，遇到加载b.js的代码就去执行b.js。此时a.js就挂起在那里，处于等待状态。
 接着，执行b.js的过程中，遇到加载a.js的部分系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。
 然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。
 最后，a.js接着往下执行，直到执行完毕。
</code></pre>
</li>
<li><p>ES6处理机制：</p>
<pre><code> 首先，执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.mjs。
 接着，执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。
 然后到跟a.mjs相关逻辑时，才发现这个接口根本没定义，因此报错
</code></pre>
</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="http://es6.ruanyifeng.com/">阮一峰ES6入门</a></li>
<li><a href="https://blog.csdn.net/u012443286/article/details/78823955">一句话总结JS构造函数、原型和实例的关系</a></li>
<li><a href="http://www.cnblogs.com/liyusmile/p/8820443.html">构造函数，原型对象，实例对象三者之间的关系</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/module-loader#%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD">循环加载</a></li>
</ol>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列-6-异步</title>
    <url>/ES6%E7%B3%BB%E5%88%97-6-%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<p>ES6 新增了多个异步编程解决方案，相比之前的callback地狱回调，ES6处理异步更加优雅。</p>
<span id="more"></span>
<h2 id="第一章-Promise"><a href="#第一章-Promise" class="headerlink" title="第一章 Promise"></a>第一章 Promise</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>promise</code>是异步编程的一种解决方案，英语意思就是“承诺”, 简单说就是一个容器，里面保存着某个未来才会结束的事件。</p>
<h4 id="Promise对象有以下两个特点："><a href="#Promise对象有以下两个特点：" class="headerlink" title="Promise对象有以下两个特点："></a>Promise对象有以下两个特点：</h4><ol>
<li>对象的状态不受外界影响：Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）<br>只有操作结果可以影响，其他手段无法改变。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果：只要状态改变，改变后的状态是凝固的，不会再变了，会一直保持这个结果，无论什么时候去添加回调函数，都会立即得到这个结果，这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
</ol>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>优点：有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</li>
<li>缺点：<br>1）无法取消Promise，一旦新建它就会立即执行，无法中途取消。<br>2）如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。<br>3）当处于pending状态时，无法得知目前进展到哪一个阶段。 </li>
</ol>
<p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>我们用promise封装一个异步请求图片的方法：</p>
<pre><code>function loadImageAsync(url) &#123;
  return new Promise(function(resolve, reject) &#123;
    const image = new Image();
    image.onload = function() &#123;
      resolve(image);
    &#125;;

    image.onerror = function(err) &#123;
      reject(err);
    &#125;;

    image.src = url;
  &#125;);
&#125;
</code></pre>
<p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用（可选）。</p>
<pre><code>loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_200_200.jpg&quot;).then((res)=&gt;&#123;
      console.log(res)
    &#125;,(err)=&gt;&#123;
      console.log(err)
    &#125;)
</code></pre>
<p>也可以通过catch方法进行改造：</p>
<pre><code>loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_200_200.jpg&quot;).then((res)=&gt;&#123;
  console.log(res)
&#125;).catch((err)=&gt;&#123;
  console.log(err)
&#125;)
</code></pre>
<p>Promise不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。</p>
<p>我们也可以这样写：</p>
<pre><code>const myPromise=loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_200_2002.jpg&quot;);
myPromise.then((res)=&gt;&#123;
  console.log(res)
&#125;)
myPromise.catch((err)=&gt;&#123;
  console.log(err)
&#125;)
</code></pre>
<p>控制台会有一个报错：<br><img src="1.png"><br>这就是上述优缺点板块中提到的缺点2，如果不设置回调，Promise内部抛出的错误，不会反应到外部。</p>
<p>我们也可以“等会”在去获取promise的结果：</p>
<pre><code>const myPromise=loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_200_2002.jpg&quot;);
setTimeout(()=&gt;&#123;
  myPromise.then((res)=&gt;&#123;
    console.log(res)
  &#125;).catch((err)=&gt;&#123;
    console.log(err)
  &#125;)
&#125;,2000)
</code></pre>
<p>通过控制台可以发现，刚开始会有一个报错，但2s后报错就会消失，打印结果同上。这就说明promise实例中确实“保存”了异步的结果，且状态是凝固的，无论什么时候去添加回调函数，都会立即得到这个结果。</p>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><pre><code>const myPromise=new Promise((resolve, reject)=&gt;&#123;
    console.log(&quot;Promise&quot;)
    resolve();
&#125;)
myPromise.then(()=&gt;&#123;
  console.log(&quot;resolve&quot;)
&#125;)
console.log(&#39;Hi!&#39;);
</code></pre>
<p>结果依次输出：<code>&quot;Promise&quot; &quot;Hi!&quot; &quot;resolve&quot;</code>。解释：Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。</p>
<h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<pre><code>  loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_200_2002.jpg&quot;).then((res)=&gt;&#123;
    console.log(res)
  &#125;).catch((err)=&gt;&#123;
    console.log(err)
  &#125;).finally(() =&gt; &#123;
    console.log(&quot;run over&quot;)
  &#125;);
</code></pre>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例，仍以异步加载图片为例：</p>
<pre><code>const myPromise1=loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_200_201.jpg&quot;);
const myPromise2=loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_200_200.jpg&quot;);
Promise.all([myPromise1, myPromise1]).then((res)=&gt;&#123;
   console.log(res)
&#125;).catch((err)=&gt;&#123;
  console.log(&quot;加载都失败了&quot;,err)
&#125;)
</code></pre>
<ol>
<li><p>只有myPromise1、myPromise2的状态都变成fulfilled（成功），Promise.all的状态才会变成fulfilled，此时myPromise1、myPromise2的返回值组成一个数组，传递给Promise.all的回调函数。</p>
</li>
<li><p>只要myPromise1、myPromise2之中有一个被rejected，pPromise.all的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给Promise.all的回调函数</p>
</li>
<li><p>如果myPromise1或者myPromise2有自己的reject回调处理，那么将不会触发Promise.all的回调函数</p>
<pre><code> const myPromise1=loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_200_201.jpg&quot;).catch(()=&gt;&#123;
   console.log(&quot;myPromise1 失败了&quot;)
 &#125;);
 const myPromise2=loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_200_200.jpg&quot;);
 Promise.all([myPromise1, myPromise2]).then((res)=&gt;&#123;
    console.log(res)
 &#125;).catch((err)=&gt;&#123;
   console.log(&quot;加载都失败了&quot;,err)
 &#125;)
</code></pre>
<p>运行结果为：   </p>
<pre><code> &#39;myPromise1 失败了&#39;
  (2) [undefined, img]
</code></pre>
</li>
<li><p>Promise.all方法接受一个数组作为参数，myPromise1、myPromise2、myPromise3都是 Promise 实例，如果不是，那么将会在Promise.resolve方法中将原数据返回（是否执行resolve方法依旧取决于其他实例共同的结果）</p>
</li>
</ol>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例，与<code>Promise.all</code> 不同的是只要myPromise1、myPromise2之中有一个实例率先改变状态，Promise.race的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给Promise.race的回调函数。</p>
<pre><code>const myPromise1=loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_200_202.jpg&quot;);
const myPromise2=loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_200_200.jpg&quot;);
Promise.race([myPromise1, myPromise2]).then((res)=&gt;&#123;
   console.log(res)
&#125;).catch((err)=&gt;&#123;
  console.log(&quot;加载都失败了&quot;,err)
&#125;)
//结果为：&lt;img src=&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_200_200&quot;&gt;
</code></pre>
<h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p>有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。</p>
<h4 id="1）-参数为-Promise-实例"><a href="#1）-参数为-Promise-实例" class="headerlink" title="1） 参数为 Promise 实例"></a>1） 参数为 Promise 实例</h4><p>Promise.resolve将不做任何修改、原封不动地返回这个实例。</p>
<h4 id="2）参数是一个thenable对象"><a href="#2）参数是一个thenable对象" class="headerlink" title="2）参数是一个thenable对象"></a>2）参数是一个thenable对象</h4><p>thenable对象指的是具有then方法的对象，比如下面这个对象：</p>
<pre><code>  const thenable = &#123;
    then: (resolve, reject)=&gt; &#123;
      resolve(42);
    &#125;
  &#125;;
  
  const p = Promise.resolve(thenable);
  p.then((value)=&gt; &#123;
    console.log(value);  // 42
  &#125;);
</code></pre>
<h4 id="3）参数不是具有then方法的对象，或根本就不是对象"><a href="#3）参数不是具有then方法的对象，或根本就不是对象" class="headerlink" title="3）参数不是具有then方法的对象，或根本就不是对象"></a>3）参数不是具有then方法的对象，或根本就不是对象</h4><pre><code>const p = Promise.resolve(&#39;Hello&#39;);

p.then((s)=&gt;&#123;
  console.log(s)
&#125;);
</code></pre>
<p>由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。</p>
<h4 id="4）不带有任何参数"><a href="#4）不带有任何参数" class="headerlink" title="4）不带有任何参数"></a>4）不带有任何参数</h4><p>Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。</p>
<p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve方法</p>
<pre><code>const p = Promise.resolve();

p.then(()=&gt; &#123;
  console.log(&quot;resolve&quot;)
&#125;);
//输出 resolve
</code></pre>
<p>我们再看下执行顺序：</p>
<pre><code>setTimeout(()=&gt; &#123;
  console.log(&#39;three&#39;);
&#125;, 0);

Promise.resolve().then(()=&gt; &#123;
  console.log(&#39;two&#39;);
&#125;);

console.log(&#39;one&#39;);
</code></pre>
<p>依次输出：one two three 解释：setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(‘one’)则是立即执行，因此最先输出。</p>
<h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。该方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致：</p>
<pre><code>const thenable = &#123;
  then: (resolve, reject)=&gt; &#123;
    resolve(42);
  &#125;
&#125;;
const p1 = Promise.reject(thenable);
const p2 = Promise.reject(&quot;hello&quot;);
const p3 = Promise.reject();
p1.catch((err)=&gt;&#123;
 console.log(err);//&#123;then: ƒ&#125;
&#125;);
p2.catch((err)=&gt;&#123;
  console.log(err);//hello
&#125;);
p3.catch((err)=&gt;&#123;
  console.log(err);//undefined
&#125;);
</code></pre>
<h2 id="第二章-Generator"><a href="#第二章-Generator" class="headerlink" title="第二章 Generator"></a>第二章 Generator</h2><p>generator的英语意思就是“发动机”, Generator函数是ES6提供的一种异步编程解决方案。语法行为与传统函数完全不同。 </p>
<h3 id="理解-Generator"><a href="#理解-Generator" class="headerlink" title="理解 Generator"></a>理解 Generator</h3><ol>
<li>语法上，可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</li>
<li>形式上，Generator函数是一个普通函数，但是有两个特征：   </li>
</ol>
<ol>
<li><p>function关键字与函数名之间有一个星号；    </p>
</li>
<li><p>函数体内部使用yield语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）</p>
<pre><code> function* helloWorldGenerator() &#123;
   console.log(&quot;start&quot;);
   yield &#39;hello&#39;;
   yield &#39;world&#39;;
   return &#39;ending&#39;;
 &#125;
</code></pre>
<p>Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象（遍历器对象:Iterator Object）。</p>
<pre><code> var hw = helloWorldGenerator();
 //必须先调用一下这个函数,但此时函数并不会执行。
 //只有通过next方法才会执行。
</code></pre>
<p>调用遍历器对象的next方法，使得指针移向下一个状态，直到遇到下一个yield表达式（或return语句，每个函数都有一个隐藏的 <code>return undefined</code> 语句）为止。</p>
<pre><code> hw.next()
 // &quot;start&quot;；此时才会执行函数体，遇到yield停止
 //&#123; value: &#39;hello&#39;, done: false &#125;
 
 hw.next()
 // &#123; value: &#39;world&#39;, done: false &#125;
 
 hw.next()
 // &#123; value: &#39;ending&#39;, done: true &#125;
 
 hw.next()
 // &#123; value: undefined, done: true &#125;
</code></pre>
<h3 id="yeild-语句"><a href="#yeild-语句" class="headerlink" title="yeild 语句"></a>yeild 语句</h3></li>
</ol>
<ol>
<li><p>由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。</p>
</li>
<li><p>yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行。</p>
</li>
<li><p>yield表达式与return语句既有相似之处，也有区别：<br>1）相似之处：都能返回紧跟在语句后面的那个表达式的值。<br>2）不同之处：yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能；<br>一个函数中只能执行一次return语句，但是可以执行多次yield表达式。<strong>Generator 函数可以返回一系列的值，因为可以有任意多个yield</strong>。也可以说 Generator 生成了一系列的值，这也就是它的名称的（“生成器”）来历。</p>
</li>
<li><p>Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。</p>
<pre><code> function* helloWorldGenerator() &#123;
   console.log(&quot;Hello world&quot;)
 &#125;
 
 var hw = helloWorldGenerator();
 setTimeout(()=&gt;&#123;
   hw.next()
 &#125;,1000)
</code></pre>
</li>
<li><p>yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。</p>
</li>
</ol>
<h3 id="与Iterator接口的关系"><a href="#与Iterator接口的关系" class="headerlink" title="与Iterator接口的关系"></a>与Iterator接口的关系</h3><p>我们知道，任意一个对象的<code>Symbol.iterator</code>方法，等于该对象的遍历器生成函数，调用该函数就会返回该对象的一个遍历器对象。由于Generator函数就是遍历器生成函数，因此可以把Generator赋值给对象的<code>Symbol.iterator</code>属性，从而使得该对象具有Iterator接口。</p>
<pre><code>const obj=&#123;&#125;
obj[Symbol.iterator]= function* ()&#123;
   yield &#39;1&#39;;
   yield &#39;2&#39;;
   yield &#39;3&#39;;
&#125;

for (let x of obj) &#123;
  console.log(x); 
  //1
  //2
  //3
&#125;
console.log([...obj]);// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;] ,只有具有Iterator接口才可以通过扩展运算符转化成数组
</code></pre>
<p>Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。</p>
<pre><code>function* gen()&#123;

&#125;
const g=gen();
console.log(g[Symbol.iterator]() === g); //true
</code></pre>
<h3 id="next方法的参数"><a href="#next方法的参数" class="headerlink" title="next方法的参数"></a>next方法的参数</h3><p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值</p>
<pre><code>function* f() &#123;
  for(var i = 0; true; i++) &#123;
    console.log(&quot;i value is: &quot; + i)
    var reset = yield i;
    //每次next方法，遇到yield就结束了，下次再执行next时，从此处开始
    if(reset) &#123;
       i = -1; 
      &#125;
  &#125;
&#125;

var g = f();

g.next() // i value is: 0    &#123; value: 0, done: false &#125;
g.next() // i value is: 1 &#123; value: 1, done: false &#125;
g.next(true) // i value is: 0 &#123; value: 0, done: false &#125;
// 传入参数true，执行next方法时，从上一个yield表达式开始，此时reset的返回值将为true，那么i被重置为-1
// 再执行一次+1操作变为0,于是就输出了 i value is: 0， 返回值为&#123; value: 0, done: false &#125;
</code></pre>
<p>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p>
<h3 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h3><ol>
<li><p>for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。</p>
</li>
<li><p>除了for…of循环以外，扩展运算符（…）、解构赋值和Array.from方法内部调用的，都是遍历器接口。它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。</p>
<pre><code> function* numbers () &#123;
   yield 1
   yield 2
   return 3
   yield 4
 &#125;
 
 // 扩展运算符
 [...numbers()] // [1, 2]
 
 // Array.from 方法
 Array.from(numbers()) // [1, 2]
 
 // 解构赋值
 let [x, y] = numbers();
 x // 1
 y // 2
 
 // for...of 循环
 for (let n of numbers()) &#123;
   console.log(n)
 &#125;
 // 1
 // 2
</code></pre>
</li>
</ol>
<h3 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h3><p>Generator 函数返回的遍历器对象，都有一个throw方法，可以在<strong>函数体外抛出错误</strong>，然后在 Generator <strong>函数体内捕获</strong></p>
<pre><code>var g = function* () &#123;
  try &#123;
    yield;
  &#125; catch (e) &#123;
    console.log(&#39;内部捕获&#39;, e);
  &#125;
&#125;;

var i = g();
i.next();

try &#123;
  i.throw(&#39;第一次抛出错误！&#39;);
  i.throw(&#39;第二次抛出错误！&#39;);
&#125; catch (e) &#123;
  console.log(&#39;外部捕获&#39;, e);
&#125;
//内部捕获 第一次抛出错误！
//外部捕获 第二次抛出错误！
</code></pre>
<p>遍历器对象i连续抛出两个错误。第一个错误被 Generator 函数体内的catch语句捕获。第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。。throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。  </p>
<p>如果 Generator 函数内部没有部署try…catch代码块，抛出的错误将直接被外部catch代码块捕获。</p>
<pre><code>var g = function* () &#123;
    yield;
&#125;;

var i = g();
i.next();

try &#123;
  i.throw(&#39;第一次抛出错误！&#39;);
  i.throw(&#39;第二次抛出错误！&#39;);
&#125; catch (e) &#123;
  console.log(&#39;外部捕获&#39;, e);
&#125;
//外部捕获 第一次抛出错误！ (不会运行第二次i.throw，被外部catch捕获后，直接跳出了try)
</code></pre>
<p>throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法(只执行Generator函数返回的只是一个Iterator接口)。  </p>
<p>throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。</p>
<pre><code>var gen = function* gen()&#123;
  try &#123;
    yield console.log(&#39;a&#39;);
  &#125; catch (e) &#123;
    console.log(&quot;内部捕获！&quot;)
  &#125;
  yield console.log(&#39;b&#39;);
  yield console.log(&#39;c&#39;);
&#125;

var g = gen();
g.next() // a

g.throw() 
// 内部捕获！ 
//b

g.next() // c
</code></pre>
<p><code>g.throw</code>方法被捕获以后，自动执行了一次next方法，所以会打印b。只要 Generator 函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。</p>
<h3 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h3><p>Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。</p>
<pre><code>function* gen() &#123;
  yield 1;
  yield 2;
  yield 3;
&#125;

var g = gen();

g.next()        // &#123; value: 1, done: false &#125;
g.return(&#39;foo&#39;) // &#123; value: &quot;foo&quot;, done: true &#125;
g.next()        // &#123; value: undefined, done: true &#125;
</code></pre>
<p>遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo（没有传参，则返回undefined）。并且，Generator 函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。  </p>
<p>如果 Generator 函数内部有try…finally代码块，且正在执行try代码块，那么return方法会推迟到finally代码块执行完再执行。</p>
<pre><code>function* numbers () &#123;
  yield 1;
  try &#123;
    yield 2;
    yield 3;
  &#125; finally &#123;
    yield 4;
    yield 5;
  &#125;
  yield 6;
&#125;
var g = numbers();
g.next() // &#123; value: 1, done: false &#125;
g.next() // &#123; value: 2, done: false &#125;
g.return(7) // &#123; value: 4, done: false &#125;
g.next() // &#123; value: 5, done: false &#125;
g.next() // &#123; value: 7, done: true &#125;
</code></pre>
<h3 id="next-、throw-、return-的共同点"><a href="#next-、throw-、return-的共同点" class="headerlink" title="next()、throw()、return() 的共同点"></a>next()、throw()、return() 的共同点</h3><p><code>next()、throw()、return()</code>这三个方法本质上是同一件事，它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式：</p>
<ol>
<li><code>next()</code>是将yield表达式替换成一个值。</li>
<li><code>throw()</code>是将yield表达式替换成一个throw语句。</li>
<li><code>return()</code>是将yield表达式替换成一个return语句。<h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h3></li>
</ol>
<p>从语法角度看，如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*表达式。  </p>
<p>如果想在一个 Generator 函数里面执行另一个 Generator 函数，这时就需要用到<code>yield*</code>表达式</p>
<pre><code>function* foo()&#123;
  yield &quot;a&quot;;
  yield &quot;b&quot;;
&#125;

function* bar() &#123;
  yield &#39;x&#39;;
  yield* foo();
  yield &#39;y&#39;;
&#125;
for(let key of bar())&#123;
  console.log(key)
&#125;
//x
//a
//b
//y
</code></pre>
<p>任何数据结构只要有 Iterator 接口，就可以被yield*遍历  </p>
<pre><code>function* concat(iter1, iter2) &#123;
  yield* iter1;
  yield* iter2;
&#125;
const p=concat([1,2,3],new Map([
  [&quot;name&quot;,&quot;jack&quot;],
  [&quot;age&quot;,&quot;28&quot;]
]))
for(let key of p)&#123;
  console.log(key)
&#125;
// 1
// 2
// 3
// [&quot;name&quot;, &quot;jack&quot;]
// [&quot;age&quot;, &quot;28&quot;]
</code></pre>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="作为对象属性的-Generator-函数"><a href="#作为对象属性的-Generator-函数" class="headerlink" title="作为对象属性的 Generator 函数"></a>作为对象属性的 Generator 函数</h4><p>如果一个对象的属性是 Generator 函数，可以简写成下面的形式。</p>
<pre><code>let obj = &#123;
  * myGeneratorMethod() &#123;
    ···
  &#125;
&#125;;
</code></pre>
<p>等同于：</p>
<pre><code>let obj = &#123;
  myGeneratorMethod: function* () &#123;
    // ···
  &#125;
&#125;;
</code></pre>
<h4 id="Generator-函数的this"><a href="#Generator-函数的this" class="headerlink" title="Generator 函数的this"></a>Generator 函数的this</h4><pre><code>function* Gen()&#123;
   this.attr=&quot;1&quot;
&#125;
Gen.prototype.hello=()=&gt;&#123;
  return &quot;hello world&quot;
&#125;
const gen=Gen();
console.log(gen.hello())  // hello world
console.log(gen instanceof Gen) // true
console.log(gen.attr)    // undefined
</code></pre>
<p>上面代码表明，Generator 函数Gen返回的遍历器gen，是Gen的实例，而且继承了Gen.prototype。这与构造函数很类似：</p>
<pre><code>function Animal()&#123;
    this.attr=&quot;1&quot;
&#125;
Animal.prototype.hello=()=&gt;&#123;
  return &quot;hello world&quot;
&#125;
const ani=new Animal();
console.log(ani.hello())      // hello world
console.log(ani instanceof Animal)// true
console.log(ani.attr)         // 1
</code></pre>
<p>但是，也可以看到如果把Gen当作普通的构造函数，并不会生效，因为Gen返回的总是遍历器对象，而不是this对象;所以通过<code>gen.attr</code>拿不到内部的属性。同时也不可以对Gen进行new操作，会报错：</p>
<pre><code>new Gen(); //Uncaught TypeError: Gen is not a constructor
</code></pre>
<p>也可以使 Generator 函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this，具体参见<a href="http://es6.ruanyifeng.com/#docs/generator">阮一峰ECMAScript 6 入门之17章：Generator 函数的语法</a>，此处不再赘述。</p>
<h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><p>譬如实现一个开关状态，我们之前需要这么写：</p>
<pre><code>let flag = true;
const switchs =()=&gt; &#123;
  flag?console.log(&quot;turn on&quot;):console.log(&quot;turn off&quot;)
  flag = !flag;
&#125;
switchs(); //turn on
switchs(); //turn off
switchs(); //turn on
switchs(); //turn off
</code></pre>
<p>通过Generate函数可以很方便的创建状态机，不再需要一个外部变量进行记录了：</p>
<pre><code>const switchg = function* ()&#123;
  while (true) &#123;
    console.log(&quot;turn on&quot;)
    yield;
    console.log(&quot;turn off&quot;)
    yield;
  &#125;
&#125;
const gen=switchg();
gen.next();//turn on
gen.next();//turn off
gen.next();//turn on
gen.next();//turn off
</code></pre>
<h3 id="Generate函数的应用"><a href="#Generate函数的应用" class="headerlink" title="Generate函数的应用"></a>Generate函数的应用</h3><h4 id="异步操作的同步化表达"><a href="#异步操作的同步化表达" class="headerlink" title="异步操作的同步化表达"></a>异步操作的同步化表达</h4><p>以ajax请求为例：</p>
<pre><code>//XMLHttpRequest对象封装
function myAjax(url,callback)&#123;
  const config=&#123;
    method:&quot;GET&quot;,
    url: url,
    data: &#39;&#39;,
    async: true,
    cache: true,
    contentType: &#39;application/x-www-form-urlencoded&#39;
  &#125;
  //1. 创建xml对象
  var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);
  //2.  同服务器建立联系，open方法
  xhr.open(config.method, url, config.async)

  //3. 向服务器发送请求 send方法
  if(config.method===&quot;GET&quot;)&#123;
    xhr.send()
  &#125;else&#123;
    xhr.setRequestHeader(&#39;content-Type&#39;,config.contentType)
    xhr.send(config.data)
  &#125;
  //4. 接收服务器返回请求内容，onreadystatechange
  xhr.onreadystatechange=function()&#123;
      if(xhr.readyState == 4)&#123;
        if(xhr.status===200)&#123;
          callback((xhr.responseText))
        &#125;else&#123;
          callback(JSON.stringify(&#123;
              data:&quot;请求出错&quot;,
              code:xhr.status
            &#125;))
        &#125;
      &#125;
  &#125;

&#125;
//请求操作
function request(url) &#123;
  myAjax(url, function(response)&#123;
    it.next(response);
  &#125;);
&#125;

//generate函数， 异步操作的同步化写法：
function* main() &#123;
  var result = yield request(&quot;http://oa.bxd365.com/api/questionnaire/gets?appid=a&amp;qid=4&quot;);
  var resp = JSON.parse(result);
  console.log(1,resp);
&#125;

var it = main();
it.next();
</code></pre>
<h4 id="部署-Iterator-接口"><a href="#部署-Iterator-接口" class="headerlink" title="部署 Iterator 接口"></a>部署 Iterator 接口</h4><pre><code>let obj = &#123;
  * [Symbol.iterator]() &#123;
    yield &#39;hello&#39;;
    yield &#39;world&#39;;
  &#125;
&#125;;

for (let x of obj) &#123;
  console.log(x);
&#125;
// &quot;hello&quot;
// &quot;world&quot;
</code></pre>
<h4 id="控制流管理（略）"><a href="#控制流管理（略）" class="headerlink" title="控制流管理（略）"></a>控制流管理（略）</h4><h4 id="作为数据结构（略）"><a href="#作为数据结构（略）" class="headerlink" title="作为数据结构（略）"></a>作为数据结构（略）</h4><h3 id="Generator-函数的异步应用"><a href="#Generator-函数的异步应用" class="headerlink" title="Generator 函数的异步应用"></a>Generator 函数的异步应用</h3><p>ES6 诞生以前，异步编程的方法，大概有下面四种：</p>
<ol>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ol>
<p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。这种情况就称为”回调函数地狱”（callback hell）。Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。  </p>
<p>Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。Generator函数应运而生。</p>
<h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>众多异步编程的解决方案中，有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。协程有点像函数，又有点像线程。它的运行流程大致如下：</p>
<pre><code>第一步，协程A开始执行。
第二步，协程A执行到一半，进入暂停，执行权转移到协程B。
第三步，（一段时间后）协程B交还执行权。
第四步，协程A恢复执行。
</code></pre>
<p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。  </p>
<p>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator 函数的执行方法如下。</p>
<pre><code>function* gen(x) &#123;
  var y = yield x + 2;
  return y;
&#125;

var g = gen(1);
g.next() // &#123; value: 3, done: false &#125;
g.next() // &#123; value: undefined, done: true &#125;
</code></pre>
<h4 id="Generator-函数的数据交换和错误处理"><a href="#Generator-函数的数据交换和错误处理" class="headerlink" title="Generator 函数的数据交换和错误处理"></a>Generator 函数的数据交换和错误处理</h4><p>Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p>
<p>next返回值的 value 属性，是 Generator 函数向外输出数据；next方法还可以接受参数，向 Generator 函数体内输入数据。</p>
<h4 id="Thunk-函数"><a href="#Thunk-函数" class="headerlink" title="Thunk 函数"></a>Thunk 函数</h4><p>Thunk 函数是自动执行 Generator 函数的一种方法，执行后所有异步操作可以自动完成，这样异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p>
<h4 id="co模块"><a href="#co模块" class="headerlink" title="co模块"></a>co模块</h4><p>co模块也是自动执行 Generator 函数的一种方法。</p>
<h2 id="第三章-async-和-await"><a href="#第三章-async-和-await" class="headerlink" title="第三章 async 和 await"></a>第三章 async 和 await</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。<code>async</code> 函数就是 <code>Generator</code> 函数的语法糖。<br>我们将Generate章节的ajax请求进行改进：</p>
<pre><code>//XMLHttpRequest对象封装
function myAjax(url,callback)&#123;
   ... //省略 同上
&#125;
//请求操作(封装为promise对象)
function request(url) &#123;
  return new Promise(function(resolve)&#123;
    myAjax(url, resolve);
  &#125;)
 
&#125;

//async函数， 同样是异步操作的同步化写法：
async function main() &#123;
  var result = await request(&quot;http://oa.bxd365.com/api/questionnaire/gets?appid=a&amp;qid=4&quot;);
  var resp = JSON.parse(result);
  console.log(1,resp);
&#125;
main();
</code></pre>
<p>一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已  </p>
<p>async函数对 Generator 函数的改进，体现在以下四点：</p>
<ol>
<li><strong>内置执行器</strong>：无需调用next方法，或者用co模块，async函数的执行，与普通函数一模一样，只要一行。</li>
<li><strong>更好的语义</strong>：async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li>
<li><strong>更广的适用性</strong>：async函数的await命令后面，可以是 Promise 对象和原始类型的值，而yield命令后面只能是 Thunk 函数或 Promise 对象</li>
<li><strong>返回值是 Promise</strong>：具体参见<strong>3.3 语法</strong> 部分的描述</li>
</ol>
<h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。<strong>当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句</strong>。</p>
<p>例子：</p>
<pre><code>const timeout=()=&gt;&#123;
  return new Promise((resolve,reject)=&gt;&#123;
    setTimeout(()=&gt;&#123;
      resolve(new Date().getTime())
    &#125;,1000)
  &#125;)
&#125;
async function getTime()&#123;
  let result= await timeout();
  return result+&quot;,&quot;+new Date().getTime()
&#125;
getTime().then((res)=&gt;&#123;
   console.log(res)
&#125;)
</code></pre>
<p>由于async函数返回的是 Promise 对象，可以作为await命令的参数。所以，上面的例子也可以写成下面的形式。</p>
<pre><code>    const timeout= async ()=&gt;&#123;
      return await new Promise((resolve,reject)=&gt;&#123;
        setTimeout(()=&gt;&#123;
          resolve(new Date().getTime())
        &#125;,1000)
      &#125;)
    &#125;
    async function getTime()&#123;
      let result= await timeout();
      return result+&quot;,&quot;+new Date().getTime()
    &#125;
    getTime().then((res)=&gt;&#123;
       console.log(res)
    &#125;)
</code></pre>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="返回-Promise-对象"><a href="#返回-Promise-对象" class="headerlink" title="返回 Promise 对象"></a>返回 Promise 对象</h4><p>async函数返回一个 Promise 对象，async函数内部return语句返回的值，会成为then方法回调函数的参数。async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。   </p>
<h4 id="Promise-对象的状态变化"><a href="#Promise-对象的状态变化" class="headerlink" title="Promise 对象的状态变化"></a>Promise 对象的状态变化</h4><p>async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。<br>仍以异步加载图片为例：</p>
<pre><code>async function loadMultiImage() &#123;
    let first = await loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_200_200.jpg&quot;);
    let second = await loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_400_400.jpg&quot;);
    let third = await loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_600_600.jpg&quot;);
    console.log(&quot;load over&quot;)
    return [first,second,third]
&#125;
loadMultiImage().then((res)=&gt;&#123;
 console.log(&quot;resolve 回调&quot;)
 console.log(res)
&#125;).catch((err)=&gt;&#123;
  console.log(&quot;reject 回调&quot;)
  console.log(err)console.log(&quot;存储历史记录&quot;);
&#125;)
</code></pre>
<p>都加载成功的情况下，会执行then方法，同时将<code>loadMultiImage</code>函数的返回值作为参数传入；只要有一个失败，那么将会执行<code>loadMultiImage</code>函数的catch方法。</p>
<h4 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h4><p>正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p>
<pre><code>async function fn() &#123;
  // 等同于
  // return 123;
  return await 123;
&#125;

fn().then(v =&gt; console.log(v))
</code></pre>
<p>await命令后面是一个thenable对象（即定义then方法的对象），那么await会将其等同于 Promise 对象，返回该Promise的resolve传入的值。  </p>
<pre><code>const foo = new Promise(function (resolve, reject) &#123;
  setTimeout(() =&gt; &#123;
    resolve(&quot;我是foo的reject值&quot;)
  &#125;, 100)
&#125;);
async function fn () &#123;
  const result = await foo;
  console.log(result) //我是foo的reject值
  return &quot;我是fn返回值&quot;
&#125;

fn().then(v =&gt; &#123;
    console.log(v)//我是fn返回值
&#125;) 
</code></pre>
<p>await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。</p>
<pre><code>async function fn() &#123;
   // 等同于  await Promise.reject(&#39;出错了&#39;);
  return await Promise.reject(&#39;出错了&#39;);
&#125;

fn()
.then(v =&gt; console.log(v))
.catch(e =&gt; console.log(e))
</code></pre>
<p>对于Promise对象的reject方法，无论await语句前面是否有return，reject方法的参数都会传入了catch方法的回调函数。但对于Promise对象的resolve方法则不是这样，有无return会影响回调的参数</p>
<pre><code>    async function fn() &#123;
        // 如果没有return 那么将会打印 &quot;undefined&quot;
        return await Promise.resolve(&#39;成功了&#39;);
    &#125;
    fn()
    .then(v =&gt; console.log(v))
    .catch(e =&gt; console.log(e))
</code></pre>
<p>我们仍以上面的加载图片为例：任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行：</p>
<pre><code>    async function loadMultiImage() &#123;
            let first = await loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_200_200.jpg&quot;);
            let second = await loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_400_401.jpg&quot;);
            let third = await loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_600_600.jpg&quot;);
            console.log(&quot;load over&quot;)
            return [first,second,third]
        &#125;
</code></pre>
<p>从控制台也可以看出，图片只加载到了第二张，第三张图片并没有加载<br><img src="2.png"></p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>如果我们希望前一个异步操作失败，也不要中断后面的异步操作，那么可以这样写：  </p>
<ol>
<li><p>利用 <code>try catch</code></p>
<pre><code> async function loadMultiImage() &#123;
   let first = await loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_200_200.jpg&quot;);
   let second =&quot;&quot;;
   try&#123;
     second = await loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_400_401.jpg&quot;);
   &#125;catch(err)&#123;
     console.log(&quot;加载出错&quot;)
   &#125;
     let third = await loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_600_600.jpg&quot;);
     console.log(&quot;load over&quot;);//(3) [&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_200_200.jpg&quot;, &quot;&quot;, &quot;http://s29.9956.cn/static/common/img/crowdsource_logo_600_600.jpg&quot;]
     return [first,second,third]
 &#125;
</code></pre>
</li>
<li><p>await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。</p>
<pre><code> async function loadMultiImage() &#123;
   let first = await loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_200_200.jpg&quot;);
   let second = await loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_400_401.jpg&quot;).catch(()=&gt;&#123;
     console.log(&quot;加载出错&quot;)
   &#125;);
   let third = await loadImageAsync(&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_600_600.jpg&quot;);
   console.log(&quot;load over&quot;);//(3) [&quot;http://s29.9956.cn/static/common/img/crowdsource_logo_200_200.jpg&quot;, undefined, &quot;http://s29.9956.cn/static/common/img/crowdsource_logo_600_600.jpg&quot;]
   return [first,second,third]
 &#125;
</code></pre>
</li>
</ol>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><p>await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中,防止前面的异步结果中断后面的操作</p>
</li>
<li><p>多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>
<pre><code> // 写法一
 let [foo, bar] = await Promise.all([getFoo(), getBar()]);
 
 // 写法二
 let fooPromise = getFoo();
 let barPromise = getBar();
 let foo = await fooPromise;
 let bar = await barPromise;
</code></pre>
</li>
<li><p>await命令只能用在async函数之中，如果用在普通函数，就会报错（esm模块加载器支持顶层await，即await命令可以不放在 async 函数里面，直接使用）</p>
</li>
<li><p>async 函数可以保留运行堆栈</p>
<pre><code>  const a = () =&gt; &#123;
   b().then(() =&gt; c());
 &#125;;
 //如果b()或c()报错，错误堆栈将不包括a()。b()执行完的时候，a()或许早就执行完了

 const A = async () =&gt; &#123;
   await B();
     C();
 &#125;;
 //一旦B()或C()，错误堆栈将包括A()。因为B()运行的时候，A()是暂停执行，上下文环境都保存着。
</code></pre>
</li>
</ol>
<h3 id="异步遍历器（Async-Iterator）"><a href="#异步遍历器（Async-Iterator）" class="headerlink" title="异步遍历器（Async Iterator）"></a>异步遍历器（Async Iterator）</h3><p>ES2018 引入了“异步遍历器”（Async Iterator）,为异步操作提供原生的遍历器接口，即value和done这两个属性都是异步产生。更多介绍请参见<a href="http://es6.ruanyifeng.com/#docs/async#%E5%BC%82%E6%AD%A5%E9%81%8D%E5%8E%86%E5%99%A8">async函数之异步遍历器</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="http://es6.ruanyifeng.com/">阮一峰ES6入门</a></li>
</ol>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Electron实现自动化答题</title>
    <url>/Electron%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E7%AD%94%E9%A2%98/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>近日对某网站的自动答题（此处不细说，估计有人能猜到）试着做下自动化功能，经过多日研究，终于完整实现，下面记录下此过程中遇到的一些问题与解决方案。</p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为工作中一直再基于electron做开发，所以第一时间想到的就是electron，可以很方便的preload脚本。扒拉下答题网站，发现是用基于react开发的，进入页面后会请求一个接口，接口中包含题目与答案，拿到数据后渲染页面，前端比较用户提交的答案，很容易就可以想到下面的流程：</p>
<pre><code>拦截接口数据 =&gt; 根据数据匹配出需要点击的选项 =&gt; 触发点击 =&gt; 提交
</code></pre>
<p>electron中对所有请求是可以做拦截的，但是却没有对返回内容做拦截的api。观察页面发现所有的请求都是基于XMLHttpRequest(XHR)对象来创建的，移动的Vconsole对请求的拦截也是通过改写全局的XMLHttpRequest（和Fetch）对象实现的，所以接下来，开始改写XMLHttpRequest内置对象。</p>
<h2 id="请求拦截"><a href="#请求拦截" class="headerlink" title="请求拦截"></a>请求拦截</h2><p>github上其实有比较成熟的库来实现:<a href="https://github.com/wendux/Ajax-hook">Ajax-hook</a>, 可以参考源码进行学习。</p>
<p><img src="./4.png"></p>
<h2 id="自动输入"><a href="#自动输入" class="headerlink" title="自动输入"></a>自动输入</h2><p>完成请求拦截后，又遇到了另外一个坑，如何触发input标签的oninput监听？<br>为input标签赋值很简单：<code>input.value=&#39;123&#39;</code>，但它只修改了input的value，并没有触发对应事件，我们拿<a href="https://so.toutiao.com/?need_open_window=1">头条的搜索</a>为例（react构建）</p>
<p><img src="./1.png"></p>
<p>我们需要做的不仅仅是赋值，还需要手动触发对应的事件，利用<code>new Event</code>来模拟input事件</p>
<pre><code>function inputVal(targetEle,val)&#123;
  targetEle.focus();
  targetEle.value=val;
  let event = new Event(&#39;input&#39;, &#123; bubbles: true &#125;);
  targetEle.dispatchEvent(event);
&#125;
</code></pre>
<p>运行结果如下：<br><img src="./2.png"><br>纳尼？？哪里不对？？，于是查阅资料发现有人提到过这个问题：<a href="https://blog.csdn.net/qq_23064433/article/details/112856303">js动态修改value，触发oninput事件的方法</a>，再次修改函数</p>
<pre><code>function inputVal(targetEle,val)&#123;
  targetEle.focus();
  targetEle.value=val;
  let event = new Event(&#39;input&#39;, &#123; bubbles: true &#125;);
  let tracker = targetEle._valueTracker;
  if (tracker) &#123;
    tracker.setValue(&#39;&#39;);
  &#125;
  targetEle.dispatchEvent(event);
&#125;
</code></pre>
<p>运行结果如下：<br><img src="./3.png"></p>
<p>终于可以了！！！网上也有很多通过<code>document.createEvent</code>实现的例子，当然也可以实现，只不过官方不再推荐使用而已：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createEvent">MDN DOC-Document.createEvent</a>:</p>
<pre><code>function inputVal(targetEle,val)&#123;
    console.log(targetEle)
    targetEle.focus();
    targetEle.value=val;
    const event=document.createEvent(&#39;HTMLEvents&#39;);//createEvent=创建windows事件
    event.initEvent(&#39;input&#39;, true, true);
    let tracker = targetEle._valueTracker;
    if (tracker) &#123;
      tracker.setValue(&#39;&#39;);
    &#125;
    targetEle.dispatchEvent(event);
  &#125;
</code></pre>
<h2 id="邮件通知"><a href="#邮件通知" class="headerlink" title="邮件通知"></a>邮件通知</h2><p>考虑到有时会发生一定概率的答案解析失败的情况，自动化脚本此时就会暂停运行，需要用户手动进行选择，我们总不能一直盯着看，那就失去自动化的意义了。最开始的想法是调用微信机器人给自己发一条微信消息，后来发现这些机器人很容易被官方封杀，那就用最原始的方案：发邮件，微信有QQ邮件提醒，收到邮件后手机还会收到相关提醒。这里我选用的是<a href="https://github.com/nodemailer/nodemailer">nodemailer</a>，配置如下（需要先开启邮箱的POP3/SMTP服务）：</p>
<pre><code>  const nodemailer = require(&quot;nodemailer&quot;);
  let transporter = nodemailer.createTransport(&#123;
    host: &quot;smtp.163.com&quot;,
    port: 465,
    secure: true, // true for 465, false for other ports
    auth: &#123; // 权限认证
      user: &#39;xxx@163.com&#39;, 
      pass: &#39;xxx&#39;  //POP3/SMTP开启成功后的密钥
    &#125;
  &#125;)
</code></pre>
<p>发消息的话调用下面的方法即可：</p>
<pre><code>transporter.sendMail(&#123;
    from: &#39;xxx@163.com&#39;, // 发邮件的账号
    to: &#39;xxx@qq.com&#39;, // 收邮件的账号
    subject: `【xx提醒】`, // 标题
    html: `&lt;html&gt;&lt;p&gt;xxx自动答题发生异常，异常原因：xxx&lt;br&gt;[来自nodemailer自动发送邮件]&lt;/p&gt;&lt;/html&gt;` // 邮寄的内容
  &#125;, (err, info) =&gt; &#123;
    console.log(content)
    if (!err) &#123;
      console.log(&#39;sendMail success&#39;)
    &#125;
  &#125;)
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>electron非常适合用来做一些网站自动化功能，期待一些更有趣的功能。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://juejin.cn/post/6844903470181384206">Ajax-hook原理解析</a></li>
<li><a href="https://github.com/wendux/Ajax-hook">github-Ajax-hook</a></li>
<li><a href="https://github.com/facebook/react/issues/11488#issuecomment-347775628">Trigger simulated input value change for React 16 (after react-dom 15.6.0 updated)?</a></li>
</ul>
]]></content>
      <categories>
        <category>Electron</category>
      </categories>
      <tags>
        <tag>electron</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>Fetch and XMLHttpRequest</title>
    <url>/Fetch-and-XMLHttpRequest/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文小探一下Fetch相关内容</p>
<span id="more"></span>
<h2 id="关于AJAX"><a href="#关于AJAX" class="headerlink" title="关于AJAX"></a>关于AJAX</h2><p>2005 年，Jesse James Garrett 发表了一篇在线文章，题为“Ajax: A new Approach to Web Applications”（<a href="http://www.adaptivepath.com/ideas/essays/archives/000385.php%EF%BC%89%E3%80%82%E4%BB%96%E5%9C%A8%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E9%87%8C%E4%BB%8B%E7%BB%8D%E4%BA%86%E4%B8%80%E7%A7%8D%E6%8A%80%E6%9C%AF%EF%BC%8C%E7%94%A8%E4%BB%96%E7%9A%84%E8%AF%9D%E8%AF%B4%EF%BC%8C%E5%B0%B1%E5%8F%AB">http://www.adaptivepath.com/ideas/essays/archives/000385.php）。他在这篇文章里介绍了一种技术，用他的话说，就叫</a> Ajax，是对 <code>Asynchronous JavaScript + XML</code> 的简写。这一技术能够向服务器请求额外的数据而无须卸载页面，会带来更好的用户体验。Garrett 还解释了怎样使用这一技术改变自从 Web 诞生以来就一直沿用的“单击，等待”的交互模式。</p>
<h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><p>Fetch API不同于XMLHttpRequest,他是一种全新设计的api用于发起获取资源的请求。目标就是要替代现有的XMLHttpRequest接口。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><pre><code>fetch(&quot;http://api.k780.com/?app=weather.today&amp;weaid=1&amp;appkey=10003&amp;sign=b59bc3ef6191eb9f747dd4e83c99f2a4&amp;format=json&quot;).then((res)=&gt;&#123;
      return  res.json()
    &#125;).then((data)=&gt; &#123;
    console.log(data);
  &#125;).catch((e)=&gt; &#123;
    console.log(e)
  &#125;);
</code></pre>
<p>用es7 中的async/await 改写后</p>
<pre><code>async function $fetch(url,params)&#123;
  try &#123;
    let response = await fetch(url,&#123;
      body:JSON.stringify(data),
      method: &#39;POST&#39;, 
    &#125;);
    let data = response.json();
    return data;
  &#125; catch(e) &#123;
    return e
  &#125;
&#125;
$fetch(&quot;http://api.k780.com/?app=weather.today&amp;weaid=1&amp;appkey=10003&amp;sign=b59bc3ef6191eb9f747dd4e83c99f2a4&amp;format=json&quot;).then((res)=&gt;&#123;
  console.log(res)
&#125;)
</code></pre>
<p>对比XMLHttpRequest可以看出来fetch的语法简洁，更加语义化，且基于标准 Promise 实现，支持 async/await</p>
<h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><h4 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h4><pre><code>  const myHeaders = new Headers(); //header的具体配置见参考3
  fetch(url, &#123;
      body: JSON.stringify(data), // must match &#39;Content-Type&#39; header
      cache: &#39;no-cache&#39;, // *default, no-cache, reload, force-cache, only-if-cached
      credentials: &#39;same-origin&#39;, // 为了让浏览器发送包含凭据的请求(chrome测试默认是包含的), include, same-origin, *omit
      headers: myHeaders,
      method: &#39;POST&#39;, // *GET, POST, PUT, DELETE, etc.
      mode: &#39;cors&#39;, // 跨域请求是否发送 no-cors, cors, *same-origin
      redirect: &#39;follow&#39;, // manual, *follow, error
      referrer: &#39;no-referrer&#39;, // *client, no-referrer
    &#125;)
</code></pre>
<h3 id="返回内容"><a href="#返回内容" class="headerlink" title="返回内容"></a>返回内容</h3><pre><code>Response.status — 整数(默认值为200) 为response的状态码.
Response.statusText — 字符串(默认值为&quot;OK&quot;),该值与HTTP状态码消息对应.
Response.ok — 如上所示, 该属性是来检查response的状态是否在200-299(包括200,299)这个范围内.该属性返回一个Boolean值.
Response.Body返回的是一个可读信息流（ReadableStream），所以需要先通过一次reslove处理成对应js数据，再进行解析。Response 下共有5个方法：

  1. arrayBuffer()
  2. blob()
  3. json()
  4. text()
  5. formData()

这些方法让非文本化的数据使用起来更加简单
</code></pre>
<h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h2><ol>
<li>没有abort方法，请求发出后无法阻止，不支持超时控制。</li>
<li>fetch没有办法原生监测请求的进度，而XHR可以。</li>
<li>无论请求返回时400，还是200，均会进入resolve处理，catch内捕获到的是resolve内发生的异常，譬如<code>Response.json()</code>的报错，所以，需要在resolve内判断<code>Response.status</code>或<code>Response.ok</code>来监测请求状态是否正常。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/fetch">MDN Fetch 教程</a></li>
<li><a href="https://segmentfault.com/a/1190000003810652">传统 Ajax 已死，Fetch 永生</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#Headers">MDN 使用 Fetch </a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html">XMLHttpRequest Level 2 使用指南</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的Number与精度</title>
    <url>/JavaScript%E4%B8%AD%E7%9A%84Number%E4%B8%8E%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们先思考如下问题：</p>
<ul>
<li>为什么0.1+0.2 != 0.3？</li>
<li>为什么会有Number.MAX_VALUE和Number.MAX_SAFE_INTEGER这两个常量同时存在？</li>
</ul>
<p>JavaScript的数字都是number类型的，不管是整数还是浮点数都以IEEE754标准中的双精度（64位）的格式存储在计算机中的。那为了找到上述问题的答案，我们就必须先从这个规则开始。</p>
<span id="more"></span>
<h2 id="IEEE754下的存储"><a href="#IEEE754下的存储" class="headerlink" title="IEEE754下的存储"></a>IEEE754下的存储</h2><p>IEEE754标准下存储示意如下：</p>
<p><img src="0.png"></p>
<ul>
<li>s表示符号位，当s=0，V为正数；当s=1，V为负数。</li>
<li>e表示指数位</li>
<li>f表示小数位</li>
</ul>
<p><img src="1.png"></p>
<p>在 64 位的二进制中，符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度</p>
<p>以<code>5.5</code>为例，其在IEEE754标准下的存储示意如下（<a href="http://bartaz.github.io/ieee754-visualization/">IEEE 754标准在线可视化</a>）：</p>
<p><img src="2.png"></p>
<p>我们来一步一步做下拆解：</p>
<pre><code>5.5 转二进制 ==&gt; 101.1 采用科学计数法 ==&gt; 1.011*2^2

按照IEEE 754标准存入计算机：  
符号位：0
指数位：2 加1023 ==&gt; 1025 转二进制 ==&gt; 10000000001
尾数位：1.011 隐去小数点左边的1 ==&gt; 011
</code></pre>
<p>小数部分转成二进制需要乘2取整，具体参考<a href="https://www.jianshu.com/p/7c636d8f18d5">此文</a>。指数位的计算按照上图公式：E表示实际偏移指数，e为存储值，64精度下的基准固定值为1023，所以e的值为<code>2+1023</code>；浮点数存储是52位尾数位。</p>
<h3 id="最大-最小正值：Number-MAX-VALUE-amp-amp-Number-MIN-VALUE"><a href="#最大-最小正值：Number-MAX-VALUE-amp-amp-Number-MIN-VALUE" class="headerlink" title="最大/最小正值：Number.MAX_VALUE &amp;&amp; Number.MIN_VALUE"></a>最大/最小正值：Number.MAX_VALUE &amp;&amp; Number.MIN_VALUE</h3><p>因为指数部分e的范围是 [0,2047]（2048表示Infinity），E的范围为[-1022,1023]</p>
<p>当符号位为0、指数取到1023、小数位全为1时，为可表示的最大正值</p>
<p><img src="3.png"></p>
<p>当符号位为0、指数取到-1022、小数位初最后一位全为0时，为可表示的最小正值 </p>
<p><img src="3-1.png"></p>
<p>最大正值为 2^1024-1，转换为科学计数保存在Number.MAX_VALUE下：</p>
<p><img src="4.png"></p>
<h3 id="最大-最小安全整数：Number-MAX-SAFE-INTEGER-amp-amp-Number-MIN-SAFE-INTEGER"><a href="#最大-最小安全整数：Number-MAX-SAFE-INTEGER-amp-amp-Number-MIN-SAFE-INTEGER" class="headerlink" title="最大/最小安全整数：Number.MAX_SAFE_INTEGER &amp;&amp; Number.MIN_SAFE_INTEGER"></a>最大/最小安全整数：Number.MAX_SAFE_INTEGER &amp;&amp; Number.MIN_SAFE_INTEGER</h3><p>为什么JS还存在一个最大安全整数Number.MAX_SAFE_INTEGER（注意说的是整数），<br>上面已经说过小数点可存储的位数共52位，实际偏移指数如果超过这个值就无法准确记录（上图中计算器计算的2^1024 与 Number.MAX_VALUE是不等的），所以实际偏移指数最多为52，将52个小数点部分也全部填为1，指数部分E为52，e=1023+52=1075</p>
<p><img src="8.png"></p>
<p>上述结果为： <code>2^53-1=9007199254740991</code>，转换符号则得到最小安全数：<code>-2^53-1=-9007199254740991</code></p>
<p>对于超过这个范围的整数，JavaScript 依旧可以进行运算，但却不保证运算结果的精度。</p>
<p>对于最大安全数字也可以这样理解：</p>
<p>双精度存储下，有效数字总是 1.xx…xx 的形式，其中 xx..xx 的部分保存在 64 位浮点数之中，最长为52位。隐藏位固定是1，所以，JavaScript 提供的有效数字最长为53个二进制位，53个二进制位全部为1时就等于：<code>2^53-1=9007199254740991</code></p>
<h3 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1+0.2 != 0.3"></a>0.1+0.2 != 0.3</h3><p>讲到此处估计已经明白为什么会这样了，一切其实都是IEEE 754标准下的双精度长度问题，对于有些小数，转换成二进制时是无线循环的：</p>
<p><img src="5.png"></p>
<p><img src="6.png"></p>
<p>存储时因为精度有限会进行一些0 舍 1 入情况，故二者就不会完全相等。</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>JavaScript 将数字存储为 64 位浮点数，但所有按位运算都以 32 位二进制数执行。在执行位运算之前，JavaScript 将数字转换为 32 位有符号整数。<br>执行按位操作后，结果将转换回 64 位 JavaScript 数。</p>
<p>位运算包含：</p>
<ul>
<li>按位或（|）</li>
<li>按位与（&amp;）</li>
<li>按位非（~）</li>
<li>按位异或（^）</li>
<li>左移（&lt;&lt;）</li>
<li>有符号右移（&gt;&gt;）</li>
<li>无符号右移（&gt;&gt;&gt;）</li>
</ul>
<p>下面介绍几种位运算的妙用</p>
<h3 id="按位与（-amp-）判断奇偶"><a href="#按位与（-amp-）判断奇偶" class="headerlink" title="按位与（&amp;）判断奇偶"></a>按位与（&amp;）判断奇偶</h3><p>由于偶数的最低位是0，奇数的最低位是1，所以可以使用&amp;运算符可以判断一个数的奇偶</p>
<pre><code>num &amp; 1 === 1 ? &#39;奇数&#39; : &#39;偶数&#39;
</code></pre>
<h3 id="按位非（-）判断值是否大于-1"><a href="#按位非（-）判断值是否大于-1" class="headerlink" title="按位非（~）判断值是否大于-1"></a>按位非（~）判断值是否大于-1</h3><p>执行非运算时 <code>~x = -(x+1)</code>，只要x=-1的时候<code>~x</code>才会为0：</p>
<pre><code>  if(~arr.indexof(item)) &#123;
      // TODO
  &#125;
</code></pre>
<h3 id="按位异或（-）判断相等与值交换"><a href="#按位异或（-）判断相等与值交换" class="headerlink" title="按位异或（^）判断相等与值交换"></a>按位异或（^）判断相等与值交换</h3><p>1.任意一个变量X与其自身进行异或运算，结果为0，即X^X=0</p>
<p>2.任意一个变量X与0进行异或运算，结果不变，即X^0=X</p>
<p>3.异或运算具有可结合性，即a^b^c=（a^b）^c=a^（b^c）</p>
<p>4.异或运算具有可交换性，即a^b=b^a</p>
<p>所以，可以用位异或来判断两个数值是否相等：</p>
<pre><code>Math.pow(2,3)^8  //0 表示二者相等
</code></pre>
<p>也可以将两个数据做交换：</p>
<pre><code>a = a ^ b;
b = a ^ b;
a = a ^ b;
</code></pre>
<p>具体原理参考：<a href="https://blog.csdn.net/heathyhuhu/article/details/12744407">异或运算实现两个数的交换</a></p>
<h3 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h3><p>由于0与任何数相或，都不会改变原数，而位运算会将数字转为整数，故：</p>
<pre><code>5.65 | 0  // 5
</code></pre>
<p>两次按位非（~~），原理基本相同：</p>
<pre><code>~~5.65 //5
</code></pre>
<p>左移（&lt;&lt;）与有符号右移（&gt;&gt;）也会将数字转为整数</p>
<pre><code>5.65 &lt;&lt; 0  //5
5.65 &gt;&gt; 0  //5
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/IEEE_754#64%E4%BD%8D%E9%9B%99%E7%B2%BE%E5%BA%A6">维基百科-IEEE 754</a></li>
<li><a href="https://segmentfault.com/a/1190000008268668">IEEE754 浮点数格式 与 Javascript number 的特性</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/66949640">知乎-前端应该知道的JavaScript浮点数和大数的原理</a></li>
<li><a href="https://www.w3school.com.cn/js/pro_js_operators_bitwise.asp">ECMAScript 位运算符</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>精度</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的设计模式</title>
    <url>/JavaScript%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC/MVP/MVVM的个人理解</title>
    <url>/MVC-MVP-MVVM%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MVC / MVP / MVVM 等软件领域的设计模式，相信大家就算不知道是什么，也听说过。对于这些设计模式，我们可以不知道，不了解，也不会影响日常的开发，但如果你想走的更远，这些是绕不过去的坎。前端作为软件行业的新兴领域，对这些设计模式在又该怎么理解，本文记录一下自己的理解，不一定都对，按需选用。</p>
<span id="more"></span>
<h2 id="软件领域的发展史"><a href="#软件领域的发展史" class="headerlink" title="软件领域的发展史"></a>软件领域的发展史</h2><p>变成领域发展最初是没有交互界面的，当时的“程序员”主要是一些数学家，他们依靠计算机实现复杂运算的。随着机器的发展和软件的需求扩大和细化，开始出现了用户界面（User Interface）。因为有了更高UI的需求，所以代码才正式被分化为描述做什么（业务逻辑）和有什么（UI）的两部分。</p>
<p>当需求变得庞大，解决方案也会变得庞大；当解决方案变得庞大，就会出现细分；软件从处理一件事务发展到了要处理许多事务，各事务间有包含、顺序、主次等等的关系，变得越来越复杂。因为数据与逻辑庞大了，所以数据与逻辑就分离了，然后事件和业务分离了，大致可以分化成以下原子：</p>
<ul>
<li>界面</li>
<li>数据</li>
<li>事件</li>
<li>业务</li>
</ul>
<h2 id="MVC的出现"><a href="#MVC的出现" class="headerlink" title="MVC的出现"></a>MVC的出现</h2><p>MVC全名是Model View Controller，它是Xerox PARC在二十世纪八十年代为编程语言Smalltalk－80发明的一种软件设计模式：</p>
<ul>
<li>Model（模型）表示应用程序核心（如数据库）</li>
<li>View（视图）显示效果（HTML页面）</li>
<li>Controller（控制器）处理输入（业务逻辑）</li>
</ul>
<p>首先要明确的一点就是：<strong>MVC只是一个设计上的指导原则，并没有明确的架构</strong>。一个经典的设计模式如下：</p>
<p><img src="./6.png"></p>
<p>MVC 模型有很多变种和数据流动方式，最传统的 MVC 模型把视图渲染和数据处理做了隔离，通过控制器接收 View 操作，传递给数据模型，数据 ready 后由数据模型驱动视图渲染。但因为 View 的更新由 Model 处理，所以 Model 难免要和 View 的实现耦合，于是就有了改良版MVP的出现。</p>
<h2 id="MVP来了"><a href="#MVP来了" class="headerlink" title="MVP来了"></a>MVP来了</h2><p>MVP 是 Model View Presenter 的缩写，相比MVC而言，View与Model没有变化，将Controller换成了Presenter，同时改变了通信方向</p>
<p><img src="./3.png"></p>
<p>View 和 Model 完全隔离，Model 不再负责业务逻辑和视图变化，只负责底层数据处理。</p>
<p>譬如，在Egg.js中，它的模型设计更贴近MVP：</p>
<pre><code>egg-project
├── package.json
├── app.js (可选)
├── agent.js (可选)
├── app
|   ├── router.js
│   ├── controller
│   |   └── home.js
│   ├── service (可选)
│   |   └── user.js
│   ├── middleware (可选)
│   |   └── response_time.js
│   ├── schedule (可选)
│   |   └── my_task.js
│   ├── public (可选)
│   |   └── reset.css
│   ├── view (可选)
│   |   └── home.tpl
│   └── extend (可选)
├── config
└── test
</code></pre>
<ul>
<li>View：作为用户的<strong>视图表现</strong>部分，常见的展示形式如浏览器作为载体的网页、原生APP应用界面、桌面应用界面等，用于提供用户界面以便收集、响应用户行为产生的数据；</li>
<li>Controller：作为<strong>控制器层</strong>部分，控制用户界面（View）的数据流转途径，主要行为包含接收用户数据请求、发送请求至业务层（Service）、获取业务层（Service）数据响应，将响应数据发送至用户界面（View），或生成相应的模板界面发送至用户；</li>
<li>Service：作为<strong>业务处理层</strong>部分，主要负责收集及对数据进行相应的运算处理，主要行为包含收集控制器请求数据、数据有效性验证、运算、请求数据模型（Model）、接收数据模型（Model）响应消息、响应结果至控制器等；</li>
<li>Model：作为<strong>数据模型层</strong>部分，主要用于将数据持久化（OUT）、查询持久化数据（IN），常见行为如对数据库进行操作、缓存数据库数据等；</li>
</ul>
<p><img src="./8.png"></p>
<p>可以看出 MVP 相对于 MVC 数据与视图分离做的更为出色，在大部分时候使用 MVC 其实是在使用 MVP。</p>
<h2 id="MVVM的时代"><a href="#MVVM的时代" class="headerlink" title="MVVM的时代"></a>MVVM的时代</h2><p>MVVM由微软架构师Ken Cooper和Ted Peters开发，它是马丁·福勒的PM（Presentation Model）设计模式的变体</p>
<p><img src="./9.png"></p>
<p>MVVM 也被称为 model-view-binder。MVVM 中，VM 是 ViewModel。View 与 ViewModel 之间采用数据绑定，绑定是双向的，避免了开发人员写一些同步 ViewModel 和 View 的重复逻辑。通过数据绑定，View 发生变化会自动反映到 ViewModel，ViewModel 产生的变化也会自动更新 View。</p>
<p>对于Vue.js，普遍认为他是基于MVVM设计的，我们一般都是这么划分的：</p>
<ul>
<li>Model：对应的是组件中的 data、props 属性</li>
<li>View：组件中 template 的部分</li>
<li>ViewModel。继承自 Vue 类的组件实例</li>
</ul>
<p>但官网有这么一句话：</p>
<p><img src="./1.jpg"></p>
<p>对于这个问题，可以参考这里：<a href="https://www.zhihu.com/question/327050991">为什么尤雨溪尤大说VUE没有完全遵循MVVM？</a>。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>架构是一个演变的过程。它指的不是随着历史的演变，而是随着项目演变的。其实不比过于纠结到底是MVC,MVP,还是MVVM, 对于这种设计思想可以统称为MV*模式，在不同的项目中，能救解决实际问题他就有可能成为最佳实践的范本。</p>
<p>并且在实际框架中，组成成分之间都不会泾渭分明，几种组成成分之间常常有难以划分的模糊地带。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://eggjs.org/zh-cn/basics/structure.html">Egg官方文档</a></li>
<li><a href="https://www.jianshu.com/p/aa9bdaf7c929">Egg 框架简述 (一)：简单的骨架认知</a></li>
<li><a href="https://www.cnblogs.com/winter-cn/archive/2012/09/16/2687184.html">winter-Web前端开发：为何选择MVVM而非MVC</a></li>
<li><a href="https://zh.wikipedia.org/wiki/MVC">维基百科-MVC</a></li>
<li><a href="https://www.yuque.com/sunluyong/node/mvc">语雀-MVC、MVP、MVVM</a></li>
<li><a href="https://www.jianshu.com/p/9037026513a2">简书-关于 Vue、React 与 MVVM</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>MVVM</tag>
        <tag>MVP</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs系列-1-基础</title>
    <url>/Nodejs%E7%B3%BB%E5%88%97-1-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Nodejs是什么？"><a href="#Nodejs是什么？" class="headerlink" title="Nodejs是什么？"></a>Nodejs是什么？</h2><p>官网是这样介绍Nodejs的：Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时。  </p>
<p>那么，NodeJs、 V8 和JavaScript 三者之前到底是怎样一种关系？这些我们经常挂在嘴边的东西，本文我们再一次进行梳理。</p>
<span id="more"></span>
<h3 id="JavaScript-运行时"><a href="#JavaScript-运行时" class="headerlink" title="JavaScript 运行时"></a>JavaScript 运行时</h3><p>运行时是一种面向对象的编程语言（面向对象编程）的运行环境。如chrome、火狐、Edge或者Safari等浏览器每个浏览器都有一个JS运行时环境。浏览器对外暴露的供开发者使用的Web API就位于其中。除此之外，用来解析代码的Javascript引擎也是位于JS运行时环境中的。  </p>
<p>我们可以把JS的运行时环境（浏览器V8引擎为例）看作一个大的容器，里面有一些其他的小容器。当JS引擎解析代码时，就是把代码片段分发到不同的容器里：</p>
<ul>
<li><strong>堆</strong>: V8引擎遇到变量声明和函数声明的时候，就把它们存储在堆里面;</li>
<li><strong>栈</strong>：当引擎遇到像函数调用之类的可执行单元，就会把它们推入调用栈;</li>
<li><strong>web API 容器</strong>：事件监听函数、HTTP／AJAX请求、定时器函数等;</li>
<li>**回调队列(event loop)**：回调队列会按照添加的顺序存储所有的回调函数，然后等待执行栈为空。当执行栈为空的时候，回调队列会把队列首部的那个回调函数推入执行栈。当执行栈再次为空的时候，再将此时队列首部函数推入;</li>
<li>**事件循环(callback queue)**：事件循环可以被看作是JS运行时环境中的这样的一个东西：它的工作是持续的检测调用栈和回调队列，如果检测到调用栈为空，它就会通知回调队列把队列中的第一个回调函数推入执行栈。更详细可参考<a href="https://blog.mhwang.club/Nodejs%E7%B3%BB%E5%88%97-2-EventLoop/#more/">Nodejs系列-2-EventLoop</a>;</li>
<li><strong>阻塞与非阻塞I/O</strong>: 如HTTP请求处理模式;</li>
</ul>
<p>而Node.js为Javascript提供了一个完全不一样的运行时环境. Node.js 不会提供DOM树、AJAX、以及其他的Web API。但是，在Node环境下你可以安装你需要的包来构建你的程序。</p>
<h3 id="JavaScript-调用栈（Call-Stack）"><a href="#JavaScript-调用栈（Call-Stack）" class="headerlink" title="JavaScript 调用栈（Call Stack）"></a>JavaScript 调用栈（Call Stack）</h3><p>JavaScript 是一门单线程的语言，这意味着它只有一个调用栈，因此，它同一时间只能做一件事。   </p>
<p>调用栈是一种数据结构，它记录了我们在程序中的位置。如果我们运行到一个函数，它就会将其放置到栈顶。当从这个函数返回的时候，就会将这个函数从栈顶弹出，这就是调用栈做的事情(ps：堆栈执行顺序是先进后出，就像往桶里面放东西)。 </p>
<p>当达到调用栈最大的大小的时候就会发生这种情况(chrome中)：</p>
<p><img src="2.png"></p>
<p>单线程执行代码是无法充分利用CPU资源，使得运行效率低。由于JavaScript只有一个调用栈，为了提高JavaScript的执行效率，解决方案就是采用异步调用，而内部处理执行机制就是利用事件循环-<a href="https://blog.mhwang.club/Nodejs%E7%B3%BB%E5%88%97-2-EventLoop/#more/">EventLoop</a></p>
<h3 id="V8-概述"><a href="#V8-概述" class="headerlink" title="V8 概述"></a>V8 概述</h3><p>V8 作为一个 JavaScript 引擎，最初是服役于 Google Chrome 浏览器的。它随着 Chrome 的第一版发布而发布以及开源。现在它除了 Chrome 浏览器，已经有很多其他的使用者了。诸如 NodeJS、MongoDB、CouchDB 等。</p>
<p>V8使用C++开发, 最主要的工作就是「把 JavaScript 直译成机器码，然后运行」。采用的是即时编译技术（JIT：just-in-time compiler），并没有产生二进制码或其他的中间码。</p>
<h3 id="V8-In-NodeJS"><a href="#V8-In-NodeJS" class="headerlink" title="V8 In NodeJS"></a>V8 In NodeJS</h3><pre><code>├── ...
├── deps
│   ├── ...
│   ├── v8
│   ├── ...
├── ...
├── lib
│   ├── ...
│   ├── buffer.js
│   ├── child_process.js
│   ├── console.js
│   ├── ...
├── node -&gt; out/Release/node
├── ...
├── out
│   ├── ...
│   ├── Release
|         ├── node
|         ├── node.d
|         ├── obj
|             └── gen
|                 ├── ...
|                 ├── node_natives.h
|                 ├── ...
│   ├── ...
├── src
│   ├── ...
│   ├── debug-agent.cc
│   ├── debug-agent.h
│   ├── env-inl.h
│   ├── env.cc
│   ├── ...
├── 
...
</code></pre>
<p>需要关注的几个目录和文件：</p>
<ul>
<li><p><code>/deps/v8</code>：这里是V8源码所在文件夹，你会发现里面的目录结构跟V8源码十分相似。NodeJS除了移植V8源码，还在增添了一些内容。</p>
</li>
<li><p><code>/src</code>：由C/C++编写的核心模块所在文件夹，由C/C++编写的这部分模块被称为「Builtin Module」</p>
</li>
<li><p><code>/lib</code>：由JavaScript编写的核心模块所在文件夹，这部分被称为「Native Code」，在编译Node源码的时候，会采用V8附带的js2c.py工具，把所有内置的JavaScript代码转换成C++里面的数组，生成out/Release/obj/gen/node_natives.h文件。有些 Native Module 需要借助于 Builtin Module 实现背后的功能。</p>
</li>
<li><p><code>/out</code>：该目录是Node源码编译(命令行运行make)后生成的目录，里面包含了Node的可执行文件。当在命令行中键入node xxx.js，实际就是运行了out/Release/node文件。</p>
</li>
</ul>
<p>V8在NodeJs运行时的整体过程:</p>
<p><img src="1.png"></p>
<p>Node在启动的时候，就已经把 Native Module，Builtin Module 加载到内存里面了。后来的 JavaScript 代码，就需要通过 V8 进行动态编译解析运行。</p>
<h3 id="Nodejs-概述"><a href="#Nodejs-概述" class="headerlink" title="Nodejs 概述"></a>Nodejs 概述</h3><p>Node.js是一个Javascript运行环境(runtime)。实际上它是对Chrome V8引擎进行了封装。V8引擎执行Javascript的速度非常快，性能非常好。但是NodeJS并不是提供简单的封装，然后提供API调用，Node对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。如增加Buffer类来处理二进制数据等。</p>
<h2 id="NodeJs的REPL"><a href="#NodeJs的REPL" class="headerlink" title="NodeJs的REPL"></a>NodeJs的REPL</h2><p>REPL（Read-Eval-Print Loop） 中文的话有翻译成：交互式解释器 或 交互式编程环境。  </p>
<p>交互式解释器（REPL）既可以作为一个独立的程序运行，也可以很容易地包含在其他程序中作为整体程序的一部分使用。REPL为运行JavaScript脚本与查看运行结果提供了一种交互方式，通常REPL交互方式可以用于调试、测试以及试验某种想法。</p>
<p>基本上所有的脚本语言有REPL的。</p>
<p>Node.js 自身也使用 repl 模块为执行 JavaScript 代码提供交互接口。</p>
<p><img src="4.png"></p>
<p>也可以在在一个 Node.js 实例中启动多个 REPL 实例（引入nodejs 内置的repl模块）：</p>
<pre><code>//repl-demo.js 
const repl = require(&#39;repl&#39;);
const msg = &#39;message&#39;;

repl.start(&#39;&gt; &#39;).context.m = msg;
</code></pre>
<p>运行结果：</p>
<p><img src="5.png"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://segmentfault.com/a/1190000014722508">JavaScript、Node.js与V8的关系</a></li>
<li><a href="https://juejin.im/post/5c7be69e51882555a8223325">【译】JS运行时环境</a></li>
</ul>
]]></content>
      <categories>
        <category>Nodejs 系列</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs系列-10-global全局变量</title>
    <url>/Nodejs%E7%B3%BB%E5%88%97-10-global%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>类似浏览器全局对象 window，但是 node（ECMAScript） 环境中是没有window的（本质上，浏览器的window 其实就是扩展自ECMAScript中的 global），但有些变量虽然看起来是全局的，但其实并不是。 它们仅存在于模块范围内，如 文件路径类 和 模块对象类</p>
<span id="more"></span>

<h2 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h2><pre><code>console对象
</code></pre>
<h2 id="文件路径类"><a href="#文件路径类" class="headerlink" title="文件路径类"></a>文件路径类</h2><p>当前文件（模块）所在目录</p>
<pre><code>__dirname
</code></pre>
<p>当前文件（模块）的文件名称（包含文件绝对路径）</p>
<pre><code>__filename
</code></pre>
<h2 id="定时器类"><a href="#定时器类" class="headerlink" title="定时器类"></a>定时器类</h2><pre><code>setTimeout()/clearTimeout()
setInterval()/clearInterval()
setImmediate()/clearImmediate()
</code></pre>
<h2 id="模块对象类"><a href="#模块对象类" class="headerlink" title="模块对象类"></a>模块对象类</h2><pre><code>module
exports
require
</code></pre>
<h2 id="进程类"><a href="#进程类" class="headerlink" title="进程类"></a>进程类</h2><pre><code>process
</code></pre>
<h2 id="文件buffer"><a href="#文件buffer" class="headerlink" title="文件buffer"></a>文件buffer</h2><pre><code>Buffer    
</code></pre>
]]></content>
      <categories>
        <category>Nodejs 系列</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs系列-11-os模块</title>
    <url>/Nodejs%E7%B3%BB%E5%88%97-11-os%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>os 模块提供了操作系统相关的实用方法</p>
<span id="more"></span>

<h2 id="os-EOL"><a href="#os-EOL" class="headerlink" title="os.EOL"></a>os.EOL</h2><p>一个字符串常量，定义操作系统相关的行末标志：</p>
<p>在 Windows 系统上为<code>\r\n </code>,POSIX 系统上为<code>\n </code>。</p>
<h2 id="os-arch"><a href="#os-arch" class="headerlink" title="os.arch"></a>os.arch</h2><p>返回一个字符串，表明 Node.js 二进制编译所用的操作系统 CPU 架构</p>
<h2 id="os-hostname"><a href="#os-hostname" class="headerlink" title="os.hostname"></a>os.hostname</h2><p>以字符串的形式返回操作系统的主机名。</p>
<h2 id="os-homedir"><a href="#os-homedir" class="headerlink" title="os.homedir"></a>os.homedir</h2><p>以字符串的形式返回当前用户的主目录。</p>
<h2 id="os-tmpdir"><a href="#os-tmpdir" class="headerlink" title="os.tmpdir"></a>os.tmpdir</h2><p>返回一个字符串，表明操作系统的默认临时文件目录。</p>
<h2 id="os-platform"><a href="#os-platform" class="headerlink" title="os.platform"></a>os.platform</h2><p>返回一个字符串，指定 Node.js 编译时的操作系统平台。</p>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><pre><code>const os =require(&quot;os&quot;)
console.log(os.EOL===&#39;\r\n&#39;)
console.log(os.arch())
console.log(os.hostname())
console.log(os.homedir())
console.log(os.tmpdir())
console.log(os.platform())
</code></pre>
<p>运行结果：</p>
<pre><code>true
x64
DESKTOP-00N6PT9
C:\Users\wmh
C:\Users\wmh\AppData\Local\Temp
win32
</code></pre>
]]></content>
      <categories>
        <category>Nodejs 系列</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs系列-12-net模块</title>
    <url>/Nodejs%E7%B3%BB%E5%88%97-12-net%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="net-模块"><a href="#net-模块" class="headerlink" title="net 模块"></a>net 模块</h2><p>net 模块提供了创建基于流的 TCP 或 IPC 服务器(<code>net.createServer</code>)和客户端(<code>net.createConnection</code>) 的异步网络 API</p>
<span id="more"></span>

<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="服务端创建"><a href="#服务端创建" class="headerlink" title="服务端创建"></a>服务端创建</h3><p>  new net.Server()<br>  net.createServer([port[, host]])</p>
<p>  server.listen(端口, [ip])<br>    - 端口：<br>    -    ip：默认为0.0.0.0，表示所有</p>
<h3 id="客户端-创建"><a href="#客户端-创建" class="headerlink" title="客户端 创建"></a>客户端 创建</h3><pre><code>new net.Socket()
    net.createConnection(port[, host][, connectListener])
</code></pre>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="service-部分"><a href="#service-部分" class="headerlink" title="service 部分"></a>service 部分</h3><pre><code>  const net = require(&#39;net&#39;);
  const server = net.createServer( () =&gt; &#123;
      // 这个函数其实就是connection事件绑定的函数
  &#125;);
  // 当有客户端连接的时候触发
  server.on(&#39;connection&#39;, socket =&gt; &#123;
      // socket =&gt; 当前连接的 socket 对象
      console.log(&#39;连接建立了&#39;);
      socket.on(&#39;data&#39;, data =&gt; &#123;
          socket.write(&#39;show me the money&#39;);
          console.log(data.toString(), socket.remoteAddress, socket.remotePort);
      &#125;);

  &#125;);
  // 0.0.0.0 : * 通配
  server.listen(8080, &#39;0.0.0.0&#39;);
</code></pre>
<h3 id="client-部分"><a href="#client-部分" class="headerlink" title="client 部分"></a>client 部分</h3><pre><code>  const net = require(&#39;net&#39;);

  /**
  * 创建客户端与udp不同
  *  net.Socket 类
  * 
  *  1. new net.Socket()
  *  2. net.createConnection()
  */

  // 要连接的目标主机的地址以及端口号
  const clientSocket = net.createConnection(8080, &#39;127.0.0.1&#39;);
  clientSocket.write(&#39;hello&#39;);

  // 监听数据传输
  clientSocket.on(&#39;data&#39;, data =&gt; &#123;
      console.log(&#39;服务器返回：&#39;, data.toString());
  &#125;);

  // 当数据包接收完成的时候触发
  clientSocket.on(&#39;end&#39;, () =&gt; &#123;
      console.log( &#39;数据包接收完成&#39; );
  &#125;);
</code></pre>
<h2 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h2><p>在数据传输过程中不仅仅只有主体数据（你要发送的主要内容），还包括了一些其他的数据信息，比如发送端的IP、端口等，以方便接受者对数据进行处理与回复。 </p>
<p>如果发送的数据比较大的话，还会对发送的数据进行分包，每一个包中包含有一部分主体数据以及上面提到的额外信息，接收方在接收到数据以后会数据包进行整合等一系列操作。  </p>
<p>这种传输规则就是数据传输协议中的规定，不同的协议对传输规则有不同的规定。</p>
<h2 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h2><p>二者均为传输层协议，但又有一些不同之处。</p>
<h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><ul>
<li>可靠的、面向连接的协议、传输效率低</li>
<li>效率要求相对低，但对准确性要求相对高的场景</li>
<li>文件传输、接受邮件、远程登录</li>
</ul>
<h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><ul>
<li>不可靠的、无连接的服务、传输效率高</li>
<li>效率要求相对高，对准确性要求相对低的场景</li>
<li>在线视频、网络语音电话</li>
</ul>
<h2 id="net-模块与-http-模块"><a href="#net-模块与-http-模块" class="headerlink" title="net 模块与 http 模块"></a>net 模块与 http 模块</h2><p>NodeJs的net 模块用于创建基于流的 TCP 或 IPC 的服务器，而http模块主要是用来创建HTTP服务; TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议,日常中接触的更多。关于网络协议部分具体的可参考<a href="https://blog.mhwang.club/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF6-%E6%B5%8F%E8%A7%88%E5%99%A8%E9%83%A8%E5%88%86-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-%E8%AF%B7%E6%B1%82/">重学前端-浏览器部分-工作流程-请求/</a></p>
]]></content>
      <categories>
        <category>Nodejs 系列</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs系列-13-dgram模块</title>
    <url>/Nodejs%E7%B3%BB%E5%88%97-13-dgram%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>dgram模块提供了 UDP 数据包 socket 的实现</p>
<span id="more"></span>

<h2 id="创建scoket实例"><a href="#创建scoket实例" class="headerlink" title="创建scoket实例"></a>创建scoket实例</h2><pre><code>  new dgram.Socket()
  dgram.createSocket(type[, callback]) //type: &#39;udp4&#39; 或 &#39;udp6&#39; 
</code></pre>
<h2 id="scoket实例下方法"><a href="#scoket实例下方法" class="headerlink" title="scoket实例下方法"></a>scoket实例下方法</h2><ul>
<li><p>绑定（监听）端口</p>
<pre><code>  server.bind([port][, address][, callback])
  - prot: 未指定则由系统分配
  - address: 默认 0.0.0.0，表示所有地址/IP
  - callback: 绑定成功后的回调
</code></pre>
</li>
<li><p>发送数据</p>
<pre><code>   server.send(msg, port, [address])
   - msg: 发送的数据（字符串/Buffer）
</code></pre>
</li>
<li><p>关闭服务</p>
<pre><code>server.close()
</code></pre>
</li>
<li><p>可监听事件</p>
<pre><code>- close
- error
- listening
- message
</code></pre>
</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="service-部分"><a href="#service-部分" class="headerlink" title="service 部分"></a>service 部分</h3><pre><code>const dgram = require(&#39;dgram&#39;);
const serverSocket = dgram.createSocket(&#39;udp4&#39;);    //udp4 =&gt; ipv4

serverSocket.on(&#39;listening&#39;, () =&gt; &#123;
    console.log(&#39;服务器开启成功，等待数据：&#39;);
&#125;);

// 当接收到数据的时候出发
serverSocket.on(&#39;message&#39;, data =&gt; &#123;
    console.log(&#39;接收到了数据：&#39;, data.toString());
&#125;)

/**
* 监听指定的地址以及端口
*/
serverSocket.bind(8080, &#39;127.0.0.1&#39;);
</code></pre>
<h3 id="client-部分"><a href="#client-部分" class="headerlink" title="client 部分"></a>client 部分</h3><pre><code>const dgram = require(&#39;dgram&#39;);

const clientSocket = dgram.createSocket(&#39;udp4&#39;);

/**
* 发送数据
* UDP，无连接协议，不需要连接到服务器，然后再发数据
*/

clientSocket.send(&#39;hello&#39;, 8080, &#39;127.0.0.1&#39;);
</code></pre>
]]></content>
      <categories>
        <category>Nodejs 系列</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs系列-14-http模块</title>
    <url>/Nodejs%E7%B3%BB%E5%88%97-14-http%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="Http概述"><a href="#Http概述" class="headerlink" title="Http概述"></a>Http概述</h2><p>http模块主要用于搭建HTTP服务。大体上可以分为两个部分：客户端http请求 与 服务端http响应</p>
<span id="more"></span>

<h2 id="客户端http请求"><a href="#客户端http请求" class="headerlink" title="客户端http请求"></a>客户端http请求</h2><p>利用http模块向服务器发送http请求：</p>
<h3 id="http-request"><a href="#http-request" class="headerlink" title="http.request"></a>http.request</h3><pre><code>http.request(url[, options][, callback])
</code></pre>
<p>我们将远端js文件下载到本地</p>
<pre><code>  const http = require(&quot;http&quot;);
  const fs=require(&quot;fs&quot;);
  const path=require(&quot;path&quot;);
  const options = &#123;
    hostname: &#39;s29.9956.cn&#39;,
    port: 80,
    path: &#39;/static/common/js/vue.min.js?v=1549865000&#39;,
    method: &#39;GET&#39;,
    headers: &#123;
      &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,
    &#125;
  &#125;;
  let filename = path.resolve(&#39;vue.js&#39;);
  let writeStream = fs.createWriteStream(filename,&#123;encoding:&#39;utf8&#39;&#125;);
  const req = http.request(options, (res) =&gt; &#123;
    console.log(`状态码: $&#123;res.statusCode&#125;`);
    console.log(`响应头: $&#123;JSON.stringify(res.headers)&#125;`);
    res.setEncoding(&#39;utf8&#39;);
    res.on(&#39;data&#39;, (chunk) =&gt; &#123;
      console.log(`数据写入中...`);
      writeStream.write(chunk)
    &#125;);
    res.on(&#39;end&#39;, () =&gt; &#123;
      console.log(&#39;响应中已无数据&#39;);
      writeStream.end();
    &#125;);
  &#125;);

  req.on(&#39;error&#39;, (e) =&gt; &#123;
    console.error(`请求遇到问题: $&#123;e.message&#125;`);
  &#125;);
  req.end(); //使用 http.request() 时，必须始终调用 req.end() 来表示请求的结束，即使没有数据被写入请求主体。
</code></pre>
<p>运行结果：</p>
<pre><code>  状态码: 200
  响应头: &#123;&quot;server&quot;:&quot;Tengine&quot;,&quot;content-type&quot;:&quot;application/javascript; charset=utf-8&quot;,&quot;content-length&quot;:&quot;85310&quot;,&quot;connection&quot;:&quot;close&quot;,&quot;vary&quot;:&quot;Accept-Encoding&quot;,&quot;date&quot;:&quot;Fri, 16 Aug 2019 11:19:19 GMT&quot;,&quot;last-modified&quot;:&quot;Thu, 27 Jun 2019 02:03:26 GMT&quot;,&quot;etag&quot;:&quot;\&quot;5d1423ee-14d3e\&quot;&quot;,&quot;accept-ranges&quot;:&quot;bytes&quot;,&quot;ali-swift-global-savetime&quot;:&quot;1565954359&quot;,&quot;via&quot;:&quot;cache21.l2cn1807[0,200-0,H], cache22.l2cn1807[0,0], kunlun4.cn698[0,200-0,H], kunlun2.cn698[0,0]&quot;,&quot;age&quot;:&quot;5519659&quot;,&quot;x-cache&quot;:&quot;HIT TCP_MEM_HIT dirn:11:519083382&quot;,&quot;x-swift-savetime&quot;:&quot;Mon, 09 Sep 2019 10:23:15 GMT&quot;,&quot;x-swift-cachetime&quot;:&quot;7776000&quot;,&quot;timing-allow-origin&quot;:&quot;*&quot;,&quot;eagleid&quot;:&quot;3da864a015714740181924794e&quot;&#125;
  数据写入中...
  数据写入中...
  数据写入中...
  响应中已无数据
</code></pre>
<p>最终文件被下载到本地</p>
<h3 id="http-get"><a href="#http-get" class="headerlink" title="http.get"></a>http.get</h3><p>由于大多数请求都是没有主体的 GET 请求，因此 Node.js 提供了这个便捷的方法。 这个方法与 http.request() 的唯一区别是它将方法设置为 GET 并自动调用 req.end()：</p>
<pre><code>http.get(url[, options][, callback])
</code></pre>
<p>例子：</p>
<pre><code>const http = require(&quot;http&quot;);
http.get(&quot;http://pv.sohu.com/cityjson?ie=utf-8&quot;,(res)=&gt;&#123;
  res.setEncoding(&#39;utf8&#39;);
  let rawData = &#39;&#39;;
  res.on(&#39;data&#39;, (chunk) =&gt; &#123; rawData += chunk; &#125;);
  res.on(&#39;end&#39;, () =&gt; &#123;
    console.log(rawData)
  &#125;);
&#125;).on(&#39;error&#39;, (e) =&gt; &#123;
  console.error(`出现错误: $&#123;e.message&#125;`);
&#125;);
</code></pre>
<p>运行结果：</p>
<pre><code>var returnCitySN = &#123;&quot;cip&quot;: &quot;115.60.61.16&quot;, &quot;cid&quot;: &quot;410100&quot;, &quot;cname&quot;: &quot;河南省郑州市&quot;&#125;;
</code></pre>
<h3 id="http-ClientRequest"><a href="#http-ClientRequest" class="headerlink" title="http.ClientRequest"></a>http.ClientRequest</h3><p>http.ClientRequest是由http.request或者是http.get返回产生的对象，表示一个已经产生而且正在进行中的HTPP请求。</p>
<p>一般会显式地在这个对象上绑定监听函数来监听整个请求的状态，如：<code>req.on(&quot;error&quot;)</code> 监听异常，<code>req.end()</code>结束发起的http请求</p>
<h2 id="服务端http响应"><a href="#服务端http响应" class="headerlink" title="服务端http响应"></a>服务端http响应</h2><p>通过http模块在服务端创建http服务，处理客户端的请求返回对应相应数据</p>
<h3 id="http-Server"><a href="#http-Server" class="headerlink" title="http.Server"></a>http.Server</h3><p>通过实例化http.Server即可创建http服务, http.Server是一个基于事件的服务器，它是继承自EventEmitter，http.Server提供的事件如下：</p>
<pre><code>- request：当客户端请求到来时，该事件被触发，提供两个参数req和res，表示请求和响应信息，是最常用的事件
- connection：当TCP连接建立时，该事件被触发，提供一个参数socket，是net.Socket的实例
- close：当服务器关闭时，触发事件（注意不是在用户断开连接时） 
- listen：启动一个服务器来监听连接，listen存在多个可能的参数
    server.listen(handle[, backlog][, callback])
    server.listen(options[, callback])
    server.listen(path[, backlog][, callback]) 用于 IPC 服务器。
    server.listen([port[, host[, backlog]]][, callback]) 用于 TCP 服务器。
</code></pre>
<p>例子：</p>
<pre><code>  const http=require(&quot;http&quot;);
  const server=new http.Server();
  server.listen(8080)
  server.on(&quot;request&quot;,function(req,res)&#123;
      res.writeHead(200,&#123;
          &quot;content-type&quot;:&quot;text/plain&quot;
      &#125;);
      res.write(&quot;hello nodejs&quot;);
      res.end();
  &#125;);
  server.on(&quot;close&quot;,()=&gt;&#123;
    console.log(&quot;http服务关闭&quot;)
  &#125;)

  server.on(&quot;connection&quot;,()=&gt;&#123;
    console.log(&quot;TCP连接建立&quot;)
  &#125;)
  setTimeout(()=&gt;&#123;
    server.close()
  &#125;,5000)
</code></pre>
<p>打开本机浏览器访问<code>http://localhost:8080/</code>,得到内容：</p>
<pre><code>  hello nodejs
</code></pre>
<p>服务端运行结果：</p>
<pre><code>  TCP连接建立
  http服务关闭
</code></pre>
<h3 id="http-createServer"><a href="#http-createServer" class="headerlink" title="http.createServer"></a>http.createServer</h3><p>我们也可以使用http.createServer方法来创建服务，塔返回了一个http.Server对象</p>
<pre><code>http.createServer([options][, requestlistener])
</code></pre>
<p>参数说明：</p>
<pre><code>- options &lt;Object&gt;
  IncomingMessage &lt;http.IncomingMessage&gt; 指定要使用的 IncomingMessage 类。用于扩展原始的 IncomingMessage。默认值: IncomingMessage。
  ServerResponse &lt;http.ServerResponse&gt; 指定要使用的 ServerResponse 类。用于扩展原始 ServerResponse。默认值: ServerResponse。
- requestListener &lt;Function&gt;
</code></pre>
<p>我们在本地开启一个http服务，且根据不同地址返回不同的内容，根目录请求返回一个本地文件：</p>
<pre><code>const http = require(&#39;http&#39;);
const fs = require(&#39;fs&#39;);

const service=http.createServer( (request, response)=&gt;&#123;
  if (request.url == &quot;/&quot;) &#123;
    response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/html&quot; &#125;);
    fs.createReadStream(`$&#123;__dirname&#125;/index.html`).pipe(response);
  &#125;else&#123;
    response.writeHead(404, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);
    response.end(&quot;404 error! File not found.&quot;);
  &#125;
  
&#125;)
service.listen(8080);
console.log(&#39;Server running on port 8080.&#39;);
</code></pre>
<h3 id="http-ServerResponse"><a href="#http-ServerResponse" class="headerlink" title="http.ServerResponse"></a>http.ServerResponse</h3><p>http.ServerResponse是返回给客户端的信息，决定了用户最终看到的内容，一般也由http.Server的request事件发送，并作为第二个参数传递，它有三个重要的成员函数，</p>
<ul>
<li>res.writeHead(statusCode,[heasers])：向请求的客户端发送响应头，该函数在一个请求中最多调用一次，如果不调用，则会自动生成一个响应头</li>
<li>res.write(data,[encoding])：想请求的客户端发送相应内容，data是一个buffer或者字符串，如果data是字符串，则需要制定编码方式，默认为utf-8，在res.end调用之前可以多次调用</li>
<li>res.end([data],[encoding])：结束响应，告知客户端所有发送已经结束，当所有要返回的内容发送完毕时，该函数必需被调用一次，两个可选参数与res.write()相同。如果不调用这个函数，客户端将用于处于等待状态。</li>
</ul>
<p>上述例子均有调用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jianshu.com/p/ab2741f78858">浅析nodejs的http模块</a></li>
</ul>
]]></content>
      <categories>
        <category>Nodejs 系列</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs系列-15-child_process模块</title>
    <url>/Nodejs%E7%B3%BB%E5%88%97-15-child_process%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Nodejs天生是单线程单进程的，child_process模块可以用于新建子进程。子进程的运行结果储存在系统缓存之中（最大200KB），等到子进程运行结束以后，主进程再用回调函数读取子进程的运行结果。</p>
<span id="more"></span>

<h2 id="exec-amp-amp-execSync"><a href="#exec-amp-amp-execSync" class="headerlink" title="exec &amp;&amp; execSync"></a>exec &amp;&amp; execSync</h2><p>用来执行shell命令</p>
<pre><code>  child_process.exec(command[, options][, callback])
</code></pre>
<p>参数说明：</p>
<pre><code>- command &lt;string&gt; 要运行的命令，并带上以空格分隔的参数。
- options &lt;Object&gt; 参见官网
- callback &lt;Function&gt; 当进程终止时调用并带上输出。
  error &lt;Error&gt;
  stdout &lt;string&gt; | &lt;Buffer&gt;
  stderr &lt;string&gt; | &lt;Buffer&gt;
</code></pre>
<p>例子，我们通过命令行来进行文件夹拷贝</p>
<pre><code>  const child_process = require(&#39;child_process&#39;);
  child_process.exec(&#39;cp -rf static static1&#39;, (err, stdout, stderr) =&gt; &#123;
    if (err) &#123;
      console.log(&#39;error:&#39; + stderr);
    &#125; else &#123;
      console.log(&#39;success&#39;);
    &#125;
  &#125;)
</code></pre>
<p>execSync是exec的同步执行版本</p>
<h2 id="execFile"><a href="#execFile" class="headerlink" title="execFile"></a>execFile</h2><p>execFile方法直接执行特定的程序，参数作为数组传入，不会被bash解释，因此具有较高的安全性</p>
<pre><code>child_process.execFile(file[, args][, options][, callback])
</code></pre>
<p>参数说明：</p>
<pre><code>- file &lt;string&gt; 要运行的可执行文件的名称或路径。
- args &lt;string[]&gt; 字符串参数的列表。
- options &lt;Object&gt; 参见官网
- callback &lt;Function&gt; 当进程终止时调用并带上输出。
  error &lt;Error&gt;
  stdout &lt;string&gt; | &lt;Buffer&gt;
  stderr &lt;string&gt; | &lt;Buffer&gt;
</code></pre>
<p>例子：子进程执行本地2.js</p>
<pre><code>const &#123; execFile &#125; = require(&#39;child_process&#39;);
const child = execFile(&#39;node&#39;, [&#39;2.js&#39;], (error, stdout, stderr) =&gt; &#123;
  if (error) &#123;
    throw error;
  &#125;
  console.log(stdout);
&#125;);

//2.js 内容
console.log(&quot;Hello!&quot;)
</code></pre>
<p>输出：</p>
<pre><code>Hello!
</code></pre>
<h2 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h2><p>spawn方法创建一个子进程来执行特定命令，用法与execFile方法类似，但是没有回调函数，只能通过监听事件，来获取运行结果。它属于异步执行，适用于子进程长时间运行的情况。</p>
<pre><code>  child_process.spawn(command[, args][, options])
</code></pre>
<p>参数说明：</p>
<pre><code>- command &lt;string&gt; 要运行的命令。
- args &lt;string[]&gt; 字符串参数的列表。
- options &lt;Object&gt; 参见官网
</code></pre>
<p>例子，我们依旧通过子进程执行本地2.js</p>
<pre><code>const child_process = require(&#39;child_process&#39;);
ls=child_process.spawn(&#39;node&#39;, [&#39;2.js&#39;])
ls.stdout.on(&#39;data&#39;,  (data)=&gt; &#123;
  console.log(&#39;stdout: &#39; + data);
&#125;);

ls.stderr.on(&#39;data&#39;, (data)=&gt;&#123;
  console.log(&#39;stderr: &#39; + data);
&#125;);

ls.on(&#39;close&#39;, (code)=&gt;&#123;
  console.log(&#39;child process exited with code &#39; + code);
&#125;);
</code></pre>
<p>运行结果：</p>
<pre><code>stdout: Hello!

child process exited with code 0
</code></pre>
<p>也可通过spawn实现文件夹复制功能（windows下powershell执行有问题）</p>
<pre><code>  const child_process = require(&#39;child_process&#39;);
  child_process.spawn(&#39;cp&#39;, [&#39;-rf&#39;, &#39;static&#39;, &#39;static2&#39;])
</code></pre>
<h2 id="fork-与-send"><a href="#fork-与-send" class="headerlink" title="fork 与 send"></a>fork 与 send</h2><p>fork方法直接创建一个子进程，执行Node脚本。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。</p>
<pre><code>child_process.fork(modulePath[, args][, options])
</code></pre>
<p>例子：1.js 与 2.js 进行通信：</p>
<pre><code>const child_process = require(&#39;child_process&#39;);
const n = child_process.fork(&#39;./2.js&#39;);
n.on(&#39;message&#39;, (m)=&gt; &#123;
  console.log(&#39;PARENT got message:&#39;, m);
&#125;);
n.send(&#123; hello: &#39;world&#39; &#125;);
</code></pre>
<p>2.js中内容：</p>
<pre><code>process.on(&#39;message&#39;,(m)=&gt; &#123;
  console.log(&#39;CHILD got message:&#39;, m);
&#125;);
process.send(&#123; foo: &#39;bar&#39; &#125;);
</code></pre>
<p>运行结果：</p>
<pre><code>CHILD got message: &#123; hello: &#39;world&#39; &#125;
PARENT got message: &#123; foo: &#39;bar&#39; &#125;
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://javascript.ruanyifeng.com/nodejs/child-process.html">child-process模块</a></li>
</ul>
]]></content>
      <categories>
        <category>Nodejs 系列</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs系列-2-EventLoop</title>
    <url>/Nodejs%E7%B3%BB%E5%88%97-2-EventLoop/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>从诞生最初，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>
<p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
<span id="more"></span>
<h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>js中所有的任务可以分为两种：一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</p>
<p>同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务； 异步任务：不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行(被放入队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，主线程处于闲置状态时，才会去执行任务队列)。</p>
<p>PS: 异步任务一定会有两个线程参加，但异步任务不是指两个线程执行任务。而是指某个线程中执行的两个动作，前一个动作立即执行，后一个动作在未来某个时刻执行的这种模式。譬如ajax请求，代码执行到发起请求的时候是同步的，但结果返回是在未来的某个时刻，所以这部分是异步的。</p>
<p>简单记录下看到一道面试题而引发的一些思考。</p>
<p>任务队列的执行机制如下：</p>
<p>所有同步任务都在主线程上执行，形成一个执行栈（stack）。</p>
<p>主线程之外，还存在一个”任务队列”（queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</p>
<p>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p>
<p>主线程不断重复上面的第三步。</p>
<p>只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会不断重复<br><img src="./1-1.png"></p>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>主线程从“任务队列”中读取事件，这个过程是循环不断的，所以整个机制运作机制又成为EventLoop（事件循环）</p>
<p>下图是EventLoop机制示意图（转引自Philip Roberts的演讲《Help, I’m stuck in an event-loop》））</p>
<p><img src="./1-2.png"></p>
<p>主进程运行的时候会产生 堆(heap) 和 栈(stack), 栈中的代码会调用各种API，他们在任务队列中加入各种事件（click,load,done等），只要栈中的代码执行完毕，主线程就会去读取“任务队列”，依次执行那些事件对应的回调函数。</p>
<h2 id="宏任务（macroTask）和微任务（microTask）"><a href="#宏任务（macroTask）和微任务（microTask）" class="headerlink" title="宏任务（macroTask）和微任务（microTask）"></a>宏任务（macroTask）和微任务（microTask）</h2><p>EventLoop循环过程中，因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）：</p>
<p>以下事件属于宏任务：</p>
<pre><code>setInterval()
setTimeout()
setImmediate() （nodejs中才有）
</code></pre>
<p>以下事件属于微任务</p>
<pre><code>promise.then()
process.nextTick() （nodejs中才有，且preocess.nextTick优先级大于promise.then）
</code></pre>
<p>微任务总会在下一个宏任务之前执行，在本身所属的宏任务结束后立即执行。如果在微任务执行期间微任务队列加入了新的微任务，会将新的微任务加入队列尾部，之后也会被执行。</p>
<h2 id="nodejs的EventLoop与浏览器环境下的差异"><a href="#nodejs的EventLoop与浏览器环境下的差异" class="headerlink" title="nodejs的EventLoop与浏览器环境下的差异"></a>nodejs的EventLoop与浏览器环境下的差异</h2><p>在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。</p>
<p>process.nextTick 和 setImmediate<br>process.nextTick属于微任务，它指定的任务总是在下一个宏任务之前执行。</p>
<p>setImmediate属于宏任务。表示立即执行。但是它指定的任务执行顺序是不确定的：</p>
<pre><code>setTimeout(() =&gt; &#123;
console.log(&#39;timeout&#39;);
&#125;, 0);

setImmediate(() =&gt; &#123;
    console.log(&#39;immediate&#39;);
&#125;);
</code></pre>
<p>运行结果可能是immediate timeout，也可能是timeout immediate。但是，在一个I/O事件的回调中，可以准确判断两个方法回调的执行顺序：setImmediate先于setTimeout。</p>
<pre><code>setTimeout(() =&gt; &#123;
  setImmediate(() =&gt; &#123;
    console.log(&#39;setImmediate&#39;);
  &#125;);
  setTimeout(() =&gt; &#123;
    console.log(&#39;setTimeout&#39;);
  &#125;, 0);
&#125;, 0);
</code></pre>
<p>这种情况下setImmediate永远先于setTimeout。  </p>
<p>可以做如下总结：</p>
<ol>
<li>如果两者都在主模块中调用，那么执行先后取决于进程性能，也就是随机。</li>
<li>如果两者都不在主模块调用（被一个异步操作包裹），那么setImmediate的回调永远先执行。</li>
</ol>
<h3 id="libuv引擎中的事件循环的模型"><a href="#libuv引擎中的事件循环的模型" class="headerlink" title="libuv引擎中的事件循环的模型"></a>libuv引擎中的事件循环的模型</h3><pre><code>   ┌───────────────────────┐
┌─&gt;│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │&lt;──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
</code></pre>
<p>node中的事件循环的顺序：</p>
<p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段…</p>
<p>nodejs每一轮事件循环的六个阶段：</p>
<ul>
<li>timers: 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。</li>
<li>I/O callbacks: 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。</li>
<li>idle, prepare: 这个阶段仅在内部使用，可以不必理会。</li>
<li>poll: 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。</li>
<li>check: setImmediate()的回调会在这个阶段执行。</li>
<li>close callbacks: 例如socket.on(‘close’, …)这种close事件的回调。</li>
</ul>
<p>贴一张其他讲解中的nodejs下eventLoop的流程图</p>
<p><img src="./1-3.png"></p>
<h2 id="相关试题"><a href="#相关试题" class="headerlink" title="相关试题"></a>相关试题</h2><h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><pre><code>async function async1() &#123;
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
&#125;

async function async2() &#123;
  console.log(&quot;async2&quot;);
&#125;

console.log(&quot;script start&quot;);

setTimeout(function() &#123;
  console.log(&quot;setTimeout&quot;);
&#125;, 0);

async1();

new Promise(function(resolve) &#123;
  console.log(&quot;promise1&quot;);
  resolve();
&#125;).then(function() &#123;
  console.log(&quot;promise2&quot;);
&#125;);

console.log(&quot;script end&quot;);
</code></pre>
<p>执行结果：</p>
<pre><code>script start
async1 start---
async2
promise1
script end
async1 end
promise2
setTimeout
</code></pre>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol>
<li>主线程顺序执行，先输出 “script start” 没什么问题。</li>
<li>执行到setTimeout，这是一个异步任务，且为宏任务（macroTask），推入任务队列（queue）。继续执行主线程内代码。</li>
<li>接着执行async1函数，这是一个异步函数，执行过程与普通函数没区别，输出”async1 start”, 然后遇到了await。</li>
<li>await命令后面可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。此时会把async2函数转成 <code>return new Pomise((resolve)=&gt;&#123;console.log(&quot;async2&quot;);resolve(undefined)&#125;)</code>,因此会输出”async2”,然后跳出async1函数，继续执行主线程内的代码，发起一个微任务（microTask），等到异步操作完成，再接着执行函数体内后面的语句。</li>
<li>继续执行遇到了一个promise对象，输出”promise1”后，再发起一个微任务（microTask），跳出对象，继续执行主进程内的代码</li>
<li>遇到<code>console.log(&quot;script end&quot;)</code>,便输出”script end”,此时主进程代码执行完毕，主线程就会去读取“任务队列”，先执行微任务，再执行宏任务。</li>
<li>首先，进入async1函数，执行await后函数体内容，输出”async1 end”</li>
<li>然后，进入promise对象执行resole方法，输出”promise2”</li>
<li>最后，执行setTimeout宏任务,输出”setTimeout”</li>
</ol>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>其实对于上述第7和8步的执行顺序是存在争议的（promise2 和 async1 end 的顺序），具体可参照参考文章的<a href="https://juejin.im/post/5c0f73e4518825689f1b5e6c">关于 async 函数的理解</a>。<br>chrome 71之前的版本，await 执行时要额外创建出两个 promise（有时会是多个），会导致promise2先于async1执行，但这种方式创建多个Promise对象的开销很大，所以chrome73进行了优化，所以按正常流程理解就好，无需太纠结于异步任务的执行顺序，且async2函数有没有通过async声明执行结果都一致。</p>
<h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><pre><code>async function asyncTest1() &#123;
  console.log(&#39;2&#39;);
  await console.log(&#39;3&#39;);
&#125;
async function asyncTest2() &#123;
  await console.log(&#39;4&#39;);
  console.log(&#39;5&#39;);
&#125;
async function asyncTest3() &#123;
  await new Promise(function (resolve) &#123;
    console.log(&#39;6&#39;);
    resolve();
  &#125;).then(function () &#123;
    console.log(&#39;7&#39;);
  &#125;);
  console.log(&#39;8&#39;);
&#125;

console.log(&#39;1&#39;);

setTimeout(function () &#123;
  console.log(&#39;9&#39;);
  new Promise(function (resolve) &#123;
    console.log(&#39;10&#39;);
    resolve();
  &#125;).then(function () &#123;
    console.log(&#39;11&#39;);
  &#125;)
  asyncTest1();
&#125;);

asyncTest2();

asyncTest3();

new Promise(function (resolve) &#123;
  console.log(&#39;12&#39;);
  resolve();
&#125;).then(function () &#123;
  console.log(&#39;13&#39;);
&#125;);
</code></pre>
<p>可以按上面思路分析一下执行结果：</p>
<pre><code>1  4  6  12  5  7  13  8  9  10  2  3  11
</code></pre>
<h3 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h3><pre><code>console.log(&quot;start&quot;)
setTimeout(function () &#123;
  console.log(&#39;timeout1&#39;);
  process.nextTick(function () &#123;
    console.log(&#39;timeout1_nextTick&#39;);
  &#125;)
  new Promise(function (resolve) &#123;
    console.log(&#39;timeout1_promise&#39;);
    resolve();
  &#125;).then(function () &#123;
    console.log(&#39;timeout1_then&#39;)
  &#125;)
&#125;,0)

setTimeout(() =&gt; &#123;
  console.log(&#39;timeout2&#39;);
  process.nextTick(() =&gt; &#123;
      console.log(&#39;timeout2_nextTick1&#39;);
      process.nextTick(() =&gt; &#123;
          console.log(&#39;timeout2_nextTick2&#39;);
      &#125;);
  &#125;);
  process.nextTick(() =&gt; &#123;
      console.log(&#39;timeout2_nextTick3&#39;);
  &#125;);
  console.log(&#39;sync&#39;);
  setTimeout(() =&gt; &#123;
      console.log(&#39;timeout2_2&#39;);
  &#125;, 0);
&#125;, 0);
</code></pre>
<p>执行结果：</p>
<pre><code>start
timeout1
timeout1_promise
timeout1_nextTick
timeout1_then
timeout2
sync
timeout2_nextTick1
timeout2_nextTick3
timeout2_nextTick2
timeout2_2
</code></pre>
<p> 注意理解的是：微任务总会在下一个宏任务之前执行，宏任务内部的微任务执行完毕才会进入下一个宏任务执行；宏微任务内嵌套的微任务的执行顺序，timeout2_nextTick3 先于 timeout2_nextTick2执行。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://juejin.im/post/5c0f73e4518825689f1b5e6c">关于 async 函数的理解</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈Event Loop</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33058983">详解JavaScript中的Event Loop（事件循环）机制</a></li>
<li><a href="https://www.jianshu.com/p/12b9f73c5a4f">前端基础进阶（十二）：深入核心，详解事件循环机制</a></li>
<li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">nodejs官网之-event-loop-timers-and-nexttick</a></li>
</ul>
]]></content>
      <categories>
        <category>Nodejs 系列</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs系列-3-Module</title>
    <url>/Nodejs%E7%B3%BB%E5%88%97-3-Module/</url>
    <content><![CDATA[<p>模块化用来分割，组织和打包软件。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体，完成整个系统所要求的功能。  </p>
<p>本文介绍下nodejs的模块系统</p>
<span id="more"></span>
<h2 id="模块系统的组成"><a href="#模块系统的组成" class="headerlink" title="模块系统的组成"></a>模块系统的组成</h2><ul>
<li>定义模块</li>
<li>模块导入（依赖）</li>
<li>模块导出</li>
</ul>
<h2 id="node中的模块化"><a href="#node中的模块化" class="headerlink" title="node中的模块化"></a>node中的模块化</h2><ul>
<li>一个文件就是一个独立的模块</li>
<li>模块加载采用同步模式</li>
<li>通过 require 函数导入, exports 对象导出</li>
</ul>
<h2 id="CommonJs规范"><a href="#CommonJs规范" class="headerlink" title="CommonJs规范"></a>CommonJs规范</h2><p>node中的模块化规范为commonJs规范，规定:</p>
<ol>
<li>通过require引入模块: require(模块id/路径)</li>
<li>通过exports导出模块: exports 对象</li>
</ol>
<p>符合CommonJS规范的模块应该是这样：</p>
<pre><code>var react=require(./react.js);//引入模块

react.render();//使用模块

module.exports.x = x;//对外输出
</code></pre>
<h2 id="module全局对象"><a href="#module全局对象" class="headerlink" title="module全局对象"></a>module全局对象</h2><p>每个模块下都有一个module对象，它包含以下几个属性：</p>
<p><img src="1.jpg"></p>
<h3 id="exports与module-exports"><a href="#exports与module-exports" class="headerlink" title="exports与module.exports"></a>exports与module.exports</h3><p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</p>
<pre><code> var exports = module.exports;
</code></pre>
<p>我们可以在export对象下挂载属性和方法：</p>
<pre><code>exports.area = function (r) &#123;
  return Math.PI * r * r;
&#125;;
exports.x = &quot;hello world&quot;
</code></pre>
<p>注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</p>
<pre><code>exports = &#123;&#125;//不要这样做！！！！
</code></pre>
<h2 id="不同模块系统下的引入机制"><a href="#不同模块系统下的引入机制" class="headerlink" title="不同模块系统下的引入机制"></a>不同模块系统下的引入机制</h2><h3 id="文件模块"><a href="#文件模块" class="headerlink" title="文件模块"></a>文件模块</h3><p>如果按确切的文件名没有找到模块，则 Node.js 会尝试带上 .js、 .json 或 .node 拓展名再加载：</p>
<pre><code>优先级：.js &gt;.json &gt;.node
</code></pre>
<p>以 <code>/</code> 为前缀的模块是文件的绝对路径。 例如， <code>require(&#39;/home/marco/foo.js&#39;)</code> 会加载 <code>/home/marco/foo.js</code> 文件。</p>
<p>以 <code>./</code> 为前缀的模块是相对于调用 <code>require(./circle)</code> 的文件的。 也就是说， circle.js 必须和 foo.js 在同一目录下以便于 <code>require(&#39;./circle&#39;)</code> 找到它。</p>
<h3 id="目录作为模块"><a href="#目录作为模块" class="headerlink" title="目录作为模块"></a>目录作为模块</h3><p>当我们导入的模块名称是一个文件夹的时候（以 <code>/</code> 、 <code>../</code> 或 <code>./</code> 开头）：  </p>
<ol>
<li>读取该文件夹下的package.json文件</li>
<li>导入package.json文件中main选项指定的文件</li>
<li>如果不存在package.json或者main指定的文件，这默认自动导入模块文件夹下的index.js 或 index.node 文件</li>
</ol>
<h3 id="从-node-modules-目录加载"><a href="#从-node-modules-目录加载" class="headerlink" title="从 node_modules 目录加载"></a>从 node_modules 目录加载</h3><p>【按目录加载时】：如果传递给 require() 的模块标识符不是一个核心模块，也没有以  <code>/</code> 、 <code>../</code> 或 <code>./</code> 开头，则 Node.js 会从当前模块的父目录开始，尝试从它的 <code>/node_modules</code> 目录里加载模块；如果还是没有找到，则移动到再上一层父目录，直到文件系统的根目录。</p>
<p>在module对象有一个属性:paths，是一个数组，里面保存的就是这种非路径加载模式需要查找的路径列表（可参照【module全局对象】的截图）</p>
<p>【例子】如果在 <code>/home/ry/projects/foo.js</code> 文件里调用了 require(<code>bar.js</code>)，则 Node.js 会按以下顺序查找：</p>
<pre><code>/home/ry/projects/node_modules/bar.js
/home/ry/node_modules/bar.js
/home/node_modules/bar.js
/node_modules/bar.js
</code></pre>
<h3 id="从全局目录加载"><a href="#从全局目录加载" class="headerlink" title="从全局目录加载"></a>从全局目录加载</h3><p>【按目录加载时】：如果 NODE_PATH 环境变量被设为一个以冒号分割的绝对路径列表，则当在其他地方找不到模块时 Node.js 会搜索这些路径。</p>
<pre><code>  本机测试全局目录为：C:\Users\ThinkPad\AppData\Roaming\npm\node_modules
</code></pre>
<p>不过，不建议通过全局目录引用。</p>
<h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>【按目录加载时】：<code>require()</code> 总是会优先加载核心模块。核心模块定义在 Node.js 源代码的 <code>lib/</code> 目录下。<br>例如： <code>require(&#39;http&#39;)</code> 始终返回内置的 HTTP 模块，即使有同名文件。</p>
<h2 id="ECMAScript6-模块系统"><a href="#ECMAScript6-模块系统" class="headerlink" title="ECMAScript6 模块系统"></a>ECMAScript6 模块系统</h2><p>默认不支持，需要加入参数（<code>--experimental-modules</code>）才开启支持，且必须用<code>.mjs</code>后缀</p>
<h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><p>Nodejs庞大的生态系统中，各个模块依赖的安装与依赖处理是需要一个管理工具来进行管理的，npm全称为Node Package Manager，是一个基于Node.js的包管理器，也是整个Node.js社区最流行、支持的第三方模块最多的包管理器，并且已经成为了非官方的发布Node模块（包）的标准。Nodejs安装包中一般均集成了npm。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://www.jianshu.com/p/0f8ba68a04ec">npm命令配置技巧</a></li>
<li><a href="https://jingyan.baidu.com/article/2d5afd6937ad7785a2e28e98.html">nodejs require模块找不到怎么解决</a></li>
</ol>
]]></content>
      <categories>
        <category>Nodejs 系列</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs系列-4-Event模块</title>
    <url>/Nodejs%E7%B3%BB%E5%88%97-4-Event%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>事件是整个 Node.js 的核心，Node.js中大部分模块都使用或继承了该模块（类似 WebAPI 中的EventTarget）。所有能触发事件的对象都是 EventEmitter 类的实例。一般开发中我们可能用到的机会比较少，但很多模块底层均是依赖该模块实现的。</p>
<span id="more"></span>
<h2 id="Event-模块"><a href="#Event-模块" class="headerlink" title="Event 模块"></a>Event 模块</h2><p>例子，一个简单的 EventEmitter 实例，绑定了一个监听器。 eventEmitter.on() 用于注册监听器， eventEmitter.emit() 用于触发事件：</p>
<pre><code>const EventEmitter = require(&#39;events&#39;);

class MyEmitter extends EventEmitter &#123;&#125;

const myEmitter = new MyEmitter();
myEmitter.on(&#39;event&#39;, () =&gt; &#123;
  console.log(&#39;触发事件&#39;);
&#125;);
myEmitter.emit(&#39;event&#39;);
</code></pre>
<h2 id="延伸知识点"><a href="#延伸知识点" class="headerlink" title="延伸知识点"></a>延伸知识点</h2><p>document.body对象的原型链关系：</p>
<pre><code>document.body&gt;HTMLBodyElement&gt;HTMLElement&gt;Element&gt;Node&gt;EventTarget&gt;Object
</code></pre>
<p>可以看到Node对象其实都继承了 nodeEventTarget 这个事件对象，所以只要是元素都会有事件。</p>
]]></content>
      <categories>
        <category>Nodejs 系列</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs系列-5-Process模块</title>
    <url>/Nodejs%E7%B3%BB%E5%88%97-5-Process%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>process 对象是一个全局变量，它提供有关当前 Node.js 进程的信息并对其进行控制。 作为一个全局变量，它始终可供 Node.js 应用程序使用，无需使用 require()。 它也可以使用 require() 显式地访问。、</p>
<span id="more"></span>

<h2 id="常用属性和方法"><a href="#常用属性和方法" class="headerlink" title="常用属性和方法"></a>常用属性和方法</h2><h3 id="process-argv"><a href="#process-argv" class="headerlink" title="process.argv"></a>process.argv</h3><p>process.argv 属性返回一个数组，其中包含当启动 Node.js 进程时传入的命令行参数。 第一个元素是 process.execPath。 第二个元素将是正在执行的 JavaScript 文件的路径。 其余元素将是任何其他命令行参数：</p>
<pre><code> node 1.js --test1 -test2
</code></pre>
<p><img src="1.png"></p>
<h3 id="process-env"><a href="#process-env" class="headerlink" title="process.env"></a>process.env</h3><p>该属性返回包含用户环境的对象。可以修改此对象，但这些修改不会反映到 Node.js 进程之外。</p>
<p>在webpack中经常可以看到通过改写该属性来加载不同的配置：</p>
<pre><code>process.env.NODE_ENV === &#39;production&#39;
</code></pre>
<p>我们也可以为不同的机器设置不同的环境变量来区分测试和生产环境</p>
<h3 id="process-exit"><a href="#process-exit" class="headerlink" title="process.exit()"></a>process.exit()</h3><p>process.exit() 方法以退出状态 code 指示 Node.js 同步地终止进程。 如果省略 code，则使用成功代码 0</p>
<h3 id="process-cwd"><a href="#process-cwd" class="headerlink" title="process.cwd()"></a>process.cwd()</h3><p>方法返回 Node.js 进程的当前工作目录。</p>
<pre><code>console.log(`当前工作目录是: $&#123;process.cwd()&#125;`);
</code></pre>
<h3 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h3><p><code>process.stdout</code> and <code>process.stderr</code> 与 Node.js 中其他 streams 在重要的方面是不同的。<code>console.log()</code> 和 <code>console.error()</code> 内部分别是由它们实现的。</p>
<h4 id="process-stdout"><a href="#process-stdout" class="headerlink" title="process.stdout"></a>process.stdout</h4><pre><code>process.stdout.write(&quot;hello world&quot;,&#39;utf-8&#39;,()=&gt;&#123;
    console.log(&#39;\n输入完毕&#39;)
&#125;)
</code></pre>
<h4 id="process-stdin"><a href="#process-stdin" class="headerlink" title="process.stdin"></a>process.stdin</h4><p>用户输入两个值，最终算出结果：</p>
<pre><code>var  num1 =0,num2=0;
process.stdout.write(&quot;请输入num1的值：&quot;)

//process.stdin 继承了 EventEmitter，所以有了on方法

process.stdin.on(&#39;data&#39;, (chunk) =&gt; &#123;
    if(!num1)&#123;
      num1=Number(chunk);
      process.stdout.write(&quot;请输入num2的值：&quot;)
    &#125;else&#123;
        num2=Number(chunk);
        process.stdout.write(&quot;结果是：&quot;+(num1+num2))
    &#125;
&#125;);
</code></pre>
]]></content>
      <categories>
        <category>Nodejs 系列</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs系列-6-Steam模块</title>
    <url>/Nodejs%E7%B3%BB%E5%88%97-6-Steam%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>流（stream）是 Node.js 中处理流式数据的抽象接口。 stream 模块用于构建实现了流接口的对象。</p>
<p>Node.js 提供了多种流对象。 例如，HTTP 服务器的请求和 process.stdout 都是流的实例。</p>
<p>流可以是可读的、可写的、或者可读可写的。 所有的流都是 EventEmitter 的实例。</p>
<p>使用时，需要require引入;</p>
<span id="more"></span>

<h2 id="流的基本类型"><a href="#流的基本类型" class="headerlink" title="流的基本类型"></a>流的基本类型</h2><ul>
<li>Writable - 可写入数据的流（例如 fs.createWriteStream()）</li>
<li>Readable - 可读取数据的流（例如 fs.createReadStream()）</li>
<li>Duplex - 可读又可写的流（例如 net.Socket）         </li>
<li>Transform - 在读写过程中可以修改或转换数据的 Duplex 流（例如 zlib.createDeflate()）</li>
</ul>
<h2 id="stream-Writable-类"><a href="#stream-Writable-类" class="headerlink" title="stream.Writable 类"></a>stream.Writable 类</h2><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><pre><code>- writable.write(chunk[, encoding][, callback])
- writable.end([chunk][, encoding][, callback])
- writable.setDefaultEncoding(encoding)
</code></pre>
<h3 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h3><pre><code>- &#39;close&#39; 事件
- &#39;drain&#39; 事件
- &#39;error&#39; 事件
- &#39;finish&#39; 事件
- &#39;pipe&#39; 事件
- &#39;unpipe&#39; 事件
</code></pre>
<h2 id="stream-Readable-类"><a href="#stream-Readable-类" class="headerlink" title="stream.Readable 类"></a>stream.Readable 类</h2><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><pre><code>- readable.setEncoding(encoding)
- readable.read([size])
- readable..pipe(destination[, options])
- readable.pause()
- readable.resume()
</code></pre>
<h3 id="常用事件-1"><a href="#常用事件-1" class="headerlink" title="常用事件"></a>常用事件</h3><pre><code>- &#39;close&#39; 事件
- &#39;data&#39; 事件
- &#39;end&#39; 事件
- &#39;error&#39; 事件
- &#39;readable&#39; 事件
</code></pre>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>Node.js 中许多的对象都是提供了流的实现：fs文件操作、net、dgram、http、https等,这些模块在数据传输中会产生可消费的流对象，可写流，可读流或可读可写流，此时我们按自己的需求对数据流进行对应的操作即可。</p>
<p>stream 模块主要用于开发者创建新类型的流实例。 对于以消费流对象为主的开发者，极少需要直接使用 stream 模块。</p>
]]></content>
      <categories>
        <category>Nodejs 系列</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs系列-7-Buffer模块</title>
    <url>/Nodejs%E7%B3%BB%E5%88%97-7-Buffer%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>Buffer是用于操作二进制数据的类。  </p>
<span id="more"></span>
<p>JavaScript 语言没有用于读取或操作二进制数据流的机制。 Buffer 类是作为 Node.js API 的一部分引入的，用于在 TCP 流、文件系统操作、以及其他上下文中与八位字节流进行交互.</p>
<p>Buffer 类在 Node.js 中是一个全局变量，因此无需使用 require，因此无需使用 require(‘buffer’).Buffer。ps: <code>new Buffer</code> 已废弃</p>
<pre><code>var bf=Buffer.from([1,2,3,4,10]);
console.log(bf); 
// &lt;Buffer 01 02 03 04 0a&gt; 返回一个字节长度为5的Buffer，以16进制打印出来，1字节=8位
</code></pre>
<p>  // 转换成二进制来表示的话是这样： &lt;Buffer 00000001 00000010 00000011 00000100 00001010&gt;<br>    console.log(bf.length);//5</p>
<p>每个字节能表达的大小为0-255, 其他整数会通过 ＆ 255 操作强制转换到此范围。  </p>
<p>Buffer实例一旦创建，长度无法修改。</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><blockquote>
<p>buf为实例方法，Buffer为对象方法。</p>
</blockquote>
<ul>
<li><p>填充数据，可以设置起始点和编码方式</p>
<pre><code>buf.fill(value[, offset[, end]][, encoding])  
</code></pre>
</li>
<li><p>要写入 buf 的字符串，可以设置起始点，长度和编码方式</p>
<pre><code>buf.write(string[, offset[, length]][, encoding])
</code></pre>
</li>
<li><p>查找目标值是否存在</p>
<pre><code>buf.includes(value[, byteOffset][, encoding])
</code></pre>
</li>
<li><p>查找索引</p>
<pre><code>buf.indexOf(value[, byteOffset][, encoding])
</code></pre>
</li>
<li><p>比较两个buffer是否相等（数值是否相等，而非比较引用地址）</p>
<pre><code>buf.equals(otherBuffer)
</code></pre>
</li>
<li><p>拷贝一个buffer </p>
<pre><code>buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])
</code></pre>
</li>
<li><p>比较两个buffer大小 </p>
<pre><code>buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])
</code></pre>
</li>
<li><p>分配一个大小为 size 字节的新建的 Buffer 。</p>
<pre><code>Buffer.alloc(size[, fill[, encoding]])  
如果 fill 为 undefined ，则该 Buffer 会用 0 填充，encoding默认为 &#39;utf8&#39;
Buffer也有下标，可以通过 buf[index] 进行操作
length：字节长度（非字符长度）
</code></pre>
</li>
<li><p>返回字符串的实际字节长度（js中字符串长度获取的是字符长度）</p>
<pre><code>Buffer.byteLength(string[, encoding])  
</code></pre>
</li>
<li><p>比较两个buf的大小</p>
<pre><code>Buffer.compare(buf1, buf2)  
</code></pre>
</li>
<li><p>返回一个合并了 list 中所有 Buffer 实例的新 Buffer</p>
<pre><code>Buffer.concat(list[, totalLength])
</code></pre>
</li>
<li><p>使用八位字节数组 array 分配一个新的 Buffer。</p>
<pre><code>Buffer.from(array)
</code></pre>
</li>
<li><p>判断对象是否是一个 Buffer</p>
<pre><code>Buffer.isBuffer(obj)
</code></pre>
</li>
<li><p>判断Buffer支持的字符编码方式</p>
<pre><code>Buffer.isEncoding(encoding)  
encoding可选值有：ascii、utf8、utf16le、ucs2、base64、latin1、binary、hex
</code></pre>
</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>js弱类型语言，所以很少涉及到进制之前的转换，再补充一边相关内容，防止遗忘：</p>
<h3 id="ECMAScript-Numer类型"><a href="#ECMAScript-Numer类型" class="headerlink" title="ECMAScript-Numer类型"></a>ECMAScript-Numer类型</h3><p>ECMAScript中的基本数据类型Numer，最基本的数值字面量格式是十进制，除了以十进制表示外，整数还可以通过八进制（以8为基础）或十六进制（以16为基数）的字面值来表示。其中，八进制字面值的第一位必须是零（0），然后是八进制数字序列（0<del>7），十六进制字面值的前两位必须是0x，后跟任何十六进制数字（0</del>9及A<del>F）。其中字母A</del>F可以大写，也可以小写：</p>
<pre><code>var octalNum1 = 070;  // 八进制的56
var hexNum1 = 0xA;    // 十六进制的10
</code></pre>
<h3 id="位-字节-字"><a href="#位-字节-字" class="headerlink" title="位/字节/字"></a>位/字节/字</h3><ul>
<li>位（bit）:计算机中的最小单位，逻辑0或1就是一个位</li>
<li>字节（byte）:有8位组成一个字节</li>
<li>字（word）：16位为一个字，32位为双字</li>
</ul>
<p>C/C++语言中数据类型：大小（字节）</p>
<pre><code>double 8
float 4
long 4
int 2 （32位或64位系统下int的长度为4字节）
char 1
</code></pre>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">字符编码笔记：ASCII，Unicode 和 UTF-8</a> </li>
</ol>
]]></content>
      <categories>
        <category>Nodejs 系列</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs系列-8-fs模块</title>
    <url>/Nodejs%E7%B3%BB%E5%88%97-8-fs%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>fs模块提供了一些与文件系统进行交互的 API，所有文件系统操作都具有同步和异步的形式。作为nodejs开发中最常用的模块之一，下面我们介绍一些常见API用法。</p>
<span id="more"></span>

<h2 id="fs-readFile-amp-amp-fs-readFileSync"><a href="#fs-readFile-amp-amp-fs-readFileSync" class="headerlink" title="fs.readFile &amp;&amp; fs.readFileSync"></a>fs.readFile &amp;&amp; fs.readFileSync</h2><p>readFile方法用于异步读取数据。</p>
<pre><code>fs.readFile(path[, options], callback)
</code></pre>
<p>参数解释：</p>
<pre><code>- path: 文件路径（相对或绝对），相对路径是相对于当前进程（process.cwd()）所在的路径
- options &lt;Object&gt; | &lt;string&gt;
    encoding &lt;string&gt; | &lt;null&gt; 默认值: null。
    flag &lt;string&gt; 参阅支持的文件系统标志。默认值: &#39;r&#39;。
- callback &lt;Function&gt;
</code></pre>
<p>示例：</p>
<pre><code>const fs= require(&quot;fs&quot;);
fs.readFile(&quot;demo.text&quot;,&quot;utf8&quot;,(err,data)=&gt;&#123;
  if (err) &#123;
    console.log(err)
    return;
  &#125;;
  console.log(data);
&#125;)
</code></pre>
<p>运行结果：</p>
<pre><code>My name is Jack!
</code></pre>
<p>如果不指定编码方式，返回的是Buffer数据：</p>
<pre><code>&lt;Buffer 89 50 4e 47 0d 0a 1a 0a 00 00 00 0d 49 48 44 52 00 00 01 c9 00 00 00 ff 08 06 00 00 00 9a 6b 2d 75 00 00 03 bc 49 44 41 54 78 9c ed d5 a1 11 c0 20 00 ... &gt;
</code></pre>
<p><code>readFileSync</code>与<code>readFile</code>类似，只是执行过程换成了同步模式。</p>
<h2 id="fs-writeFile-amp-amp-fs-writeFileSync"><a href="#fs-writeFile-amp-amp-fs-writeFileSync" class="headerlink" title="fs.writeFile &amp;&amp; fs.writeFileSync"></a>fs.writeFile &amp;&amp; fs.writeFileSync</h2><p>writeFile方法用于写入文件。</p>
<pre><code>fs.writeFile(file, data[, options], callback)
</code></pre>
<p>参数解释：</p>
<pre><code>- file &lt;string&gt; | &lt;Buffer&gt; | &lt;URL&gt; | &lt;integer&gt; 文件名或文件描述符。
- data &lt;string&gt; | &lt;Buffer&gt; | &lt;TypedArray&gt; | &lt;DataView&gt;
- options &lt;Object&gt; | &lt;string&gt;
  encoding &lt;string&gt; | &lt;null&gt; 默认值: &#39;utf8&#39;。
  mode &lt;integer&gt; 默认值: 0o666。
  flag &lt;string&gt; 参阅支持的文件系统标志。默认值: &#39;w&#39;。
- callback &lt;Function&gt;
</code></pre>
<p>例子1，写入数据为字符串时，需指定字符编码，缺省时为utf8</p>
<pre><code>fs.writeFile(&quot;./demo-1.txt&quot;,&quot;My job is coding&quot;,&quot;utf8&quot;,(err)=&gt;&#123;
  if(err)&#123;
    console.log(&quot;写入失败&quot;)
    return;
  &#125;
  console.log(&quot;写入成功&quot;)
&#125;)
</code></pre>
<p>例子2, 写入数据为二进制数据时，encoding 选项会被忽略, 我们将一个图片的base64字符串保存到本地</p>
<pre><code>const base64Img=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAE0lEQVQImWN8Eyz6nwEImBigAAAkPwJXo01dBgAAAABJRU5ErkJggg==&quot;
const base64Data = base64Img.replace(/^data:image\/\w+;base64,/, &quot;&quot;);//过滤掉标识
const data=Buffer.from(base64Data, &#39;base64&#39;);
fs.writeFile(&quot;./red.png&quot;,data,(err)=&gt;&#123;
  if(err)&#123;
    console.log(&quot;写入失败&quot;)
    return;
  &#125;
  console.log(&quot;写入成功&quot;)
&#125;)
</code></pre>
<p>我们将一个gif图写入本地,图片二进制数据参见：<a href="http://www.matthewflickinger.com/lab/whatsinagif/bits_and_bytes.asp">点我访问</a></p>
<pre><code>const arr=[0x47,0x49,0x46,0x38,0x39,0x61,0x0A,0x00,0x0A,0x00,0x91,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x21,0xF9,0x04,0x00,0x00,0x00,0x00,0x00,0x2C,0x00,0x00,0x00,0x00,0x0A,0x00,0x0A,0x00,0x00,0x02,0x16,0x8C,0x2D,0x99,0x87,0x2A,0x1C,0xDC,0x33,0xA0,0x02,0x75,0xEC,0x95,0xFA,0xA8,0xDE,0x60,0x8C,0x04,0x91,0x4C,0x01,0x00,0x3B];
const data=Buffer.from(arr);
fs.writeFile(&quot;./red.gif&quot;,data,(err)=&gt;&#123;
  if(err)&#123;
    console.log(&quot;写入失败&quot;);
    return;
  &#125;
  console.log(&quot;写入成功&quot;)
&#125;)
</code></pre>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>在文件描述符的情况下，文件不会被替换！ 数据不一定写入到文件的开头，文件的原始数据可以保留在新写入的数据之前和/或之后，行为几乎与直接调用 <code>fs.write</code> 类似：</p>
<pre><code>fs.open(&#39;./demo-1.txt&#39;, &#39;a+&#39;, (err,fd)=&gt;&#123;
  if(err)&#123;
    console.log(&quot;打开失败&quot;)
  &#125;
  fs.writeFileSync(fd,&quot;锄禾日当午;&quot;)
  fs.writeFileSync(fd,&quot;汗滴禾下土&quot;)
  fs.close(fd,function(err)&#123;
    if(err)&#123;
      console.log(&quot;关闭失败&quot;)
      return;
    &#125;
    console.log(&#39;file closed&#39;);
  &#125;)
&#125;)
</code></pre>
<p>运行结果：</p>
<pre><code>锄禾日当午;汗滴禾下土
</code></pre>
<p>下面例子也可以实现同样的功能：</p>
<pre><code>fs.writeFileSync(&quot;./demo-1.txt&quot;,&quot;;&quot;+new Date().getTime().toString(),&#123;
  flag:&quot;a+&quot;
&#125;)
fs.writeFileSync(&quot;./demo-1.txt&quot;,&quot;;&quot;+new Date().getTime().toString(),&#123;
  flag:&quot;a+&quot;
&#125;)
</code></pre>
<p>运行结果：</p>
<pre><code>;1570873714714;1570873714715
</code></pre>
<p><code>writeFileSync</code>与<code>writeFile</code>类似</p>
<h2 id="fs-mkdir-amp-amp-fs-mkdirSync"><a href="#fs-mkdir-amp-amp-fs-mkdirSync" class="headerlink" title="fs.mkdir &amp;&amp; fs.mkdirSync"></a>fs.mkdir &amp;&amp; fs.mkdirSync</h2><p>mkdir方法用于新建目录</p>
<pre><code>fs.mkdir(path[, options], callback)
</code></pre>
<p>参数解释：</p>
<pre><code>- path &lt;string&gt; | &lt;Buffer&gt; | &lt;URL&gt;
- options &lt;Object&gt; | &lt;integer&gt;
  recursive &lt;boolean&gt; 默认值: false。
  mode &lt;integer&gt; Windows 上不支持。默认值: 0o777。
- callback &lt;Function&gt;
</code></pre>
<p>例子：</p>
<pre><code>fs.mkdir(&#39;./tmp/a/apple&#39;, &#123; recursive: true &#125;, (err) =&gt; &#123;
  if (err) &#123;
    console.log(&quot;创建失败&quot;);
    return;
  &#125;
  console.log(&quot;创建成功&quot;)
&#125;);
</code></pre>
<p>创建 /tmp/a/apple 目录，无论是否存在 /tmp 和 /tmp/a 目录。</p>
<p><code>mkdirSync</code>与<code>mkdir</code>类似</p>
<h2 id="fs-readdir-amp-amp-fs-readdirSync"><a href="#fs-readdir-amp-amp-fs-readdirSync" class="headerlink" title="fs.readdir &amp;&amp; fs.readdirSync"></a>fs.readdir &amp;&amp; fs.readdirSync</h2><p>readdir方法用于读取目录，返回一个所包含的文件和子目录的数组</p>
<pre><code>fs.readdir(path[, options], callback)
</code></pre>
<p>参数解释：<br>    - path <string> | <Buffer> | <URL><br>    - options <string> | <Object><br>      encoding <string> 默认值: ‘utf8’。<br>      withFileTypes <boolean> 默认值: false。<br>    - callback <Function><br>      err <Error><br>      files &lt;string[]&gt; | &lt;Buffer[]&gt; | &lt;fs.Dirent[]&gt;<br>例子，读取文本的static文件夹：</p>
<pre><code>  fs.readdir(&quot;./static&quot;,(err,files)=&gt;&#123;
    if (err) &#123;
      console.log(err);
      return;
    &#125;
    console.log(files)
  &#125;)
</code></pre>
<p>运行结果：</p>
<pre><code>   [ &#39;css&#39;, &#39;img&#39;, &#39;index.html&#39;, &#39;js&#39; ]
</code></pre>
<p><code>readdirSync</code>与<code>readdir</code>类似</p>
<h2 id="fs-stat-amp-amp-fs-statSync"><a href="#fs-stat-amp-amp-fs-statSync" class="headerlink" title="fs.stat &amp;&amp; fs.statSync"></a>fs.stat &amp;&amp; fs.statSync</h2><p>stat方法的参数是一个文件或目录，它产生一个对象，该对象包含了该文件或目录的具体信息。我们往往通过该方法，判断正在处理的到底是一个文件，还是一个目录。</p>
<pre><code>fs.stat(path[, options], callback)
</code></pre>
<p>参数解释：<br>    - path <string> | <Buffer> | <URL><br>    - options <Object><br>      bigint <boolean> 返回的 fs.Stats 对象中的数值是否应为 bigint 型。默认值: false。<br>      callback <Function><br>    - err <Error><br>      stats &lt;fs.Stats&gt;<br>我们将上述例子中获取到的static进行遍历，获取对应文件的stat</p>
<pre><code>  fs.readdir(&quot;./static&quot;,(err,files)=&gt;&#123;
    if (err) &#123;
      console.log(err);
      return;
    &#125;
    files.map((file)=&gt;&#123;
      fs.stat(path.join(__dirname,&quot;static&quot;, file),(err,stats)=&gt;&#123;
          if (err) &#123;
            console.log(err);
            return;
          &#125;
        if (stats.isFile()) &#123;
          console.log(&quot;%s is file&quot;, file);
        &#125;else if (stats.isDirectory ()) &#123;
          console.log(&quot;%s is a directory&quot;, file);
        &#125;
      &#125;);
      
    &#125;) 
  &#125;)
</code></pre>
<p>运行结果：</p>
<pre><code>  css is a directory
  img is a directory
  index.html is file
  js is a directory
</code></pre>
<p>利用<code>fs.statSync</code> 与 <code>fs.readdirSync</code> 可以封装一个常用功能：遍历目录下的所有文件</p>
<pre><code>  /**
  *
  * @desc 遍历目录下的所有文件
  * @param &#123;p&#125;:要遍历目录路径
  */
  let localFileArr=[];
  function readPathSync (p) &#123;
    const stat = fs.statSync(p)
    if (stat.isDirectory()) &#123;
      const ls = fs.readdirSync(p).map(file =&gt; path.join(p, file))
      for (let i = 0; i &lt; ls.length; i++) &#123;
        arguments.callee(ls[i])
      &#125;
    &#125; else &#123;
      localFileArr.push(p)
    &#125;
  &#125;
</code></pre>
<p>运行</p>
<pre><code>  readPathSync(path.join(__dirname,&quot;static&quot;)); 
  
</code></pre>
<p>可以得到static文件夹下的所有文件</p>
<pre><code>[ &#39;C:\\Users\\wmh\\Desktop\\nodejs\\static\\css\\fonts\\element-icons.535877f.woff&#39;,
  &#39;C:\\Users\\wmh\\Desktop\\nodejs\\static\\css\\style.css&#39;,
  &#39;C:\\Users\\wmh\\Desktop\\nodejs\\static\\img\\1.png&#39;,
  &#39;C:\\Users\\wmh\\Desktop\\nodejs\\static\\img\\2.png&#39;,
  &#39;C:\\Users\\wmh\\Desktop\\nodejs\\static\\index.html&#39;,
  &#39;C:\\Users\\wmh\\Desktop\\nodejs\\static\\js\\app.js&#39; ]
</code></pre>
<h2 id="fs-existsSync"><a href="#fs-existsSync" class="headerlink" title="fs.existsSync"></a>fs.existsSync</h2><p>用来判断给定路径是否存在:如果路径存在，则返回 true，否则返回 false。</p>
<pre><code>fs.existsSync(path)
</code></pre>
<p>注意：<code>fs.exists</code> <strong>已废弃！！！</strong></p>
<h2 id="fs-copyFile-amp-amp-fs-copyFileSync"><a href="#fs-copyFile-amp-amp-fs-copyFileSync" class="headerlink" title="fs.copyFile &amp;&amp; fs.copyFileSync"></a>fs.copyFile &amp;&amp; fs.copyFileSync</h2><p>拷贝文件到指定路径，V8.5+版本支持</p>
<pre><code>fs.copyFile(src, dest[, flags], callback)
</code></pre>
<p>参数解释：</p>
<pre><code>- src &lt;string&gt; | &lt;Buffer&gt; | &lt;URL&gt; 要拷贝的源文件名。
- dest &lt;string&gt; | &lt;Buffer&gt; | &lt;URL&gt; 拷贝操作的目标文件名。
- flags &lt;number&gt; 用于拷贝操作的修饰符。默认值: 0。
- callback &lt;Function&gt;
</code></pre>
<p>例子：</p>
<pre><code>fs.copyFile(&quot;./static/index.html&quot;,&quot;./test/test.html&quot;,()=&gt;&#123;
  console.log(&quot;拷贝完成&quot;)
&#125;)
</code></pre>
<p>因为拷贝时目标地址目录必须存在，所有一般使用过程中，我们需要做下处理：</p>
<p>利用<code>fs.existsSync</code>、 <code>mkdirSync</code>与 <code>fs.readdirSync</code> 可以封装一个常用功能：拷贝目录下所有文件</p>
<pre><code>/**
* @desc 拷贝原目录下所有文件到目标目录
* @param &#123;*&#125; src 原目录
* @param &#123;*&#125; dest 目标目录
*/
function copySync (src, dest) &#123;
  const stat = fs.statSync(src)
  if (stat.isDirectory()) &#123;
    //原地址是一个文件夹，判断目标文件夹是否存在
    if (!fs.existsSync(dest)) fs.mkdirSync(dest)
    const ls = fs.readdirSync(src).map(file =&gt; path.join(src, file))
    for (let i = 0; i &lt; ls.length; i++) &#123;
      arguments.callee(ls[i], path.join(dest, path.basename(ls[i])))
    &#125;
  &#125; else &#123;
    //path.dirname() 方法返回 path 的目录名
    //原地址是一个文件，先判断目标地址文件所在目录是否存在
    if (!fs.existsSync(path.dirname(dest))) fs.mkdirSync(path.dirname(dest))
    fs.copyFileSync(src, dest)
  &#125;
&#125;
</code></pre>
<p>执行：</p>
<pre><code>copySync(path.join(__dirname,&quot;static&quot;),path.join(__dirname,&quot;_static&quot;))
</code></pre>
<p>完成文件夹拷贝</p>
<h2 id="fs-unlink-amp-amp-fs-unlinkSync"><a href="#fs-unlink-amp-amp-fs-unlinkSync" class="headerlink" title="fs.unlink &amp;&amp; fs.unlinkSync"></a>fs.unlink &amp;&amp; fs.unlinkSync</h2><p>删除文件，当删除路径不是文件时，同步模式下会报错，所以，一般使用时与stat配合使用</p>
<pre><code> fs.unlink(path, callback)
</code></pre>
<p>例子：</p>
<pre><code>fs.unlink(&quot;./static/js&quot;,(err)=&gt;&#123;
  if(err)&#123;
    console.log(&#39;删除失败&#39;)
    return
  &#125;
  console.log(&quot;删除成功&quot;)
&#125;)
</code></pre>
<h2 id="fs-rmdir-amp-amp-fs-rmdirSync"><a href="#fs-rmdir-amp-amp-fs-rmdirSync" class="headerlink" title="fs.rmdir &amp;&amp; fs.rmdirSync"></a>fs.rmdir &amp;&amp; fs.rmdirSync</h2><p>删除文件夹(必须为空文件夹)，当删除路径不是文件夹时，同步模式下会报错，所以，一般使用时与stat配合使用(V12 新增了option选项)</p>
<pre><code>fs.rmdir(path, callback)
</code></pre>
<p>参数说明：</p>
<pre><code>- path &lt;string&gt; | &lt;Buffer&gt; | &lt;URL&gt;
- callback &lt;Function&gt;
  err &lt;Error&gt;
</code></pre>
<p>利用<code>fs.unlinkSync</code> 与 <code>fs.rmdirSync</code> 可以封装一个常用功能：删除目录下所有文件</p>
<pre><code> /**
  *
  * @desc 删除目录下所有文件
  * @param &#123;p&#125;:要删除的目录地址
  */
function removeSync (p) &#123;
  const stat = fs.statSync(p)
  if (stat.isDirectory()) &#123;
    const ls = fs.readdirSync(p).map(file =&gt; path.join(p, file))
    for (let i = 0; i &lt; ls.length; i++) &#123;
      arguments.callee(ls[i])
    &#125;
    fs.rmdirSync(p)
  &#125; else &#123;
    fs.unlinkSync(p)
  &#125;
&#125;
</code></pre>
<p>运行：</p>
<pre><code> removeSync(path.join(__dirname,&quot;static&quot;))
</code></pre>
<p>static目录被删除</p>
<h2 id="fs-watchfile-amp-amp-fs-unwatchfile"><a href="#fs-watchfile-amp-amp-fs-unwatchfile" class="headerlink" title="fs.watchfile &amp;&amp; fs.unwatchfile"></a>fs.watchfile &amp;&amp; fs.unwatchfile</h2><p>watchfile方法监听一个文件，如果该文件发生变化，就会自动触发回调函数。</p>
<pre><code>fs.watchFile(filename[, options], listener)
</code></pre>
<p>参数说明：</p>
<pre><code>- filename &lt;string&gt; | &lt;Buffer&gt; | &lt;URL&gt;
- options &lt;Object&gt;
  persistent &lt;boolean&gt; 默认值: true。
  interval &lt;integer&gt; 默认值: 5007。
- listener &lt;Function&gt;
  current &lt;fs.Stats&gt;
  previous &lt;fs.Stats&gt;
</code></pre>
<p>每当访问文件时都会调用 listener 回调，例子:</p>
<pre><code>fs.watchFile(&#39;./demo.txt&#39;,  (curr, prev)=&gt; &#123;
  console.log(&#39;the current mtime is: &#39; + curr.mtime);
  console.log(&#39;the previous mtime was: &#39; + prev.mtime);
&#125;);

fs.writeFile(&#39;./demo.txt&#39;, &quot;My Name is Tom&quot;, function (err) &#123;
  if (err) throw err;

  console.log(&quot;file write complete&quot;);   
&#125;);
</code></pre>
<p>运行结果：</p>
<pre><code>file write complete
the current mtime is: Wed Oct 16 2019 18:48:30 GMT+0800 (GMT+08:00)
the previous mtime was: Wed Oct 09 2019 18:08:38 GMT+0800 (GMT+08:00)
</code></pre>
<p><code>unwatchfile</code>方法用于解除对文件的监听。</p>
<h2 id="fs-ReadStream-类"><a href="#fs-ReadStream-类" class="headerlink" title="fs.ReadStream 类"></a>fs.ReadStream 类</h2><p>我们经常用到的<code>fs.readFile</code>方法可以满足多数场景，但对于大文件，譬如超过10M文件的读取，<code>fs.readFile</code>就不是最优选择了，因为该方法将数据一次性全部读取到内存中,会造成系统的假死或引发其他问题，此时，我们需要使用<code>fs.ReadStream</code>类来处理数据；类似大文件场景下，对于写入数据，我们选择<code>fs.createWriteStream</code>类来处理：</p>
<p>成功调用 fs.createReadStream() 将会返回一个新的 fs.ReadStream 对象。</p>
<pre><code>      fs.createReadStream(path[, options])
</code></pre>
<p>我们读取本地一个文本文件：</p>
<pre><code>const fs = require(&quot;fs&quot;);
const path = require(&quot;path&quot;);

let filename = path.resolve(&#39;demo.txt&#39;);
let readStream = fs.createReadStream(filename,&#123;encoding:&#39;utf8&#39;&#125;);
readStream.on(&quot;open&quot;,(data)=&gt;&#123;
    console.log(&#39;打开了,触发open&#39;,data)
&#125;)
readStream.on(&quot;ready&quot;,()=&gt;&#123;
  console.log(&#39;ReadStream已经ready,触发ready&#39;)
&#125;)
readStream.on(&quot;data&quot;,(data)=&gt;&#123;
    console.log(&quot;数据来了！&quot;);
    console.log(&quot;已经读取的字节数&quot;,readStream.bytesRead);
&#125;)
readStream.on(&quot;close&quot;,(data)=&gt;&#123;
    console.log(&#39;读取结束，触发close&#39;)
&#125;)
console.log(&quot;读取文件路径为：&quot;+readStream.path)
</code></pre>
<p>运行结果：</p>
<pre><code>读取文件路径为：C:\Users\wmh\Desktop\nodejs\demo.txt
打开了,触发open 3
ReadStream已经ready,触发ready
数据来了！
已经读取的字节数 11
读取结束，触发close
</code></pre>
<h2 id="fs-WriteStream-类"><a href="#fs-WriteStream-类" class="headerlink" title="fs.WriteStream 类"></a>fs.WriteStream 类</h2><p>成功调用 fs.createWriteStream() 将会返回一个新的 fs.WriteStream 对象。</p>
<pre><code>fs.createWriteStream(path[, options])
</code></pre>
<p>我们在上面例子的基础上，改为写入模式：</p>
<pre><code>const fs = require(&quot;fs&quot;);
const path = require(&quot;path&quot;);

let filename = path.resolve(&#39;demo.txt&#39;);
let writeStream = fs.createWriteStream(filename,&#123;encoding:&#39;utf8&#39;&#125;);
writeStream.on(&quot;open&quot;,(data)=&gt;&#123;
    console.log(&#39;打开了,触发open&#39;,data)
&#125;)
writeStream.on(&quot;ready&quot;,()=&gt;&#123;
  console.log(&#39;触发ready&#39;)
&#125;)
writeStream.on(&quot;close&quot;,(data)=&gt;&#123;
    console.log(&#39;写入结束，触发close&#39;)
&#125;)
console.log(&quot;写入文件路径为：&quot;+writeStream.path)
writeStream.write(&quot;My name is Jack!&quot;)
writeStream.end();
</code></pre>
<p>运行结果：</p>
<pre><code>写入文件路径为：C:\Users\wmh\Desktop\nodejs\demo.txt
打开了,触发open 3
触发ready
写入结束，触发close
</code></pre>
<h2 id="fs-Stats-类"><a href="#fs-Stats-类" class="headerlink" title="fs.Stats 类"></a>fs.Stats 类</h2><p>从 fs.stat()、fs.lstat() 和 fs.fstat() 及其同步的方法返回的对象都属于fs.Stats 类, 对象提供了关于文件的信息：</p>
<pre><code>Stats &#123;
  dev: 1217250464,
  mode: 33206,
  nlink: 1,
  uid: 0,
  gid: 0,
  rdev: 0,
  blksize: undefined,
  ino: 1970324836979001,
  size: 264,
  blocks: undefined,
  atimeMs: 1571293841813.9216,
  mtimeMs: 1571293801942.3247,
  ctimeMs: 1571293801942.3247,
  birthtimeMs: 1571220882907.5747,
  atime: 2019-10-17T06:30:41.814Z,
  mtime: 2019-10-17T06:30:01.942Z,
  ctime: 2019-10-17T06:30:01.942Z,
  birthtime: 2019-10-16T10:14:42.908Z &#125;
  
</code></pre>
<p>上图结果为Stats类型下的属性，还有一些方法：</p>
<pre><code>stats.isBlockDevice() #如果 fs.Stats 对象描述块设备，则返回 true。

stats.isCharacterDevice() #如果 fs.Stats 对象描述字符设备，则返回 true。

stats.isDirectory()  #如果 fs.Stats 对象描述文件系统目录，则返回 true。

stats.isFile() #如果 fs.Stats 对象描述常规文件，则返回 true。

stats.isFIFO() #如果 fs.Stats 对象描述先进先出（FIFO）管道，则返回 true。

stats.isSocket() #如果 fs.Stats 对象描述套接字，则返回 true。

stats.isSymbolicLink() #如果 fs.Stats 对象描述符号链接，则返回 true。此方法仅在使用 fs.lstat() 时有效。
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://javascript.ruanyifeng.com/nodejs/fs.html">fs 模块– JavaScript 标准参考教程（alpha）</a></li>
</ul>
]]></content>
      <categories>
        <category>Nodejs 系列</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs系列-9-path模块</title>
    <url>/Nodejs%E7%B3%BB%E5%88%97-9-path%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>path 模块提供用于处理文件路径和目录路径的实用工具，path的几乎所有操作均不检测文件是否真是存在，只针对路径字符串本身进行解析。</p>
<span id="more"></span>
<h2 id="path-dirname"><a href="#path-dirname" class="headerlink" title="path.dirname"></a>path.dirname</h2><p>方法返回 path 的目录名，类似于 Unix 的 dirname 命令</p>
<pre><code>path.dirname(path)
</code></pre>
<p>例子：</p>
<pre><code>const path =require(&quot;path&quot;);
const static=path.join(__dirname,&#39;static/js/app.js&#39;);
console.log(path.dirname(static))
</code></pre>
<p>运行结果：</p>
<pre><code>D:\MyProject\DEMO-CODE\PATH\static\js
</code></pre>
<h2 id="path-extname"><a href="#path-extname" class="headerlink" title="path.extname"></a>path.extname</h2><p>方法返回 path 的扩展名，从最后一次出现 <code>.</code>（句点）字符到 path 最后一部分的字符串结束。没有则返回空</p>
<pre><code>path.extname(path)
</code></pre>
<p>例子：</p>
<pre><code>const path =require(&quot;path&quot;);
const static=path.join(__dirname,&#39;static/js/app.js&#39;);
console.log(path.extname(static))
</code></pre>
<p>运行结果：</p>
<pre><code>.js
</code></pre>
<h2 id="path-basename"><a href="#path-basename" class="headerlink" title="path.basename"></a>path.basename</h2><p>方法返回 path 的最后一部分，类似于 Unix 的 basename 命令。</p>
<pre><code>path.basename(path[, ext])
</code></pre>
<p>例子：</p>
<pre><code>const path =require(&quot;path&quot;);
const static=path.resolve(&#39;static&#39;,&#39;js&#39;,&#39;app.js&#39;);
console.log(path.basename(static))
console.log(path.basename(static,&#39;.js&#39;))
</code></pre>
<p>运行结果：</p>
<pre><code>app.js
app
</code></pre>
<h2 id="path-step-属性"><a href="#path-step-属性" class="headerlink" title="path.step(属性)"></a>path.step(属性)</h2><p>提供平台特定的路径片段分隔符：<br>    Windows 上是 <code>\</code>。<br>    POSIX 上是 <code>/</code>。  </p>
<p>例子：</p>
<pre><code>const path =require(&quot;path&quot;);
const static=path.resolve(&#39;static&#39;,&#39;js&#39;,&#39;app.js&#39;);
console.log(static.split(path.sep))
</code></pre>
<p>运行结果：</p>
<pre><code>[ &#39;D:&#39;, &#39;MyProject&#39;, &#39;DEMO-CODE&#39;, &#39;PATH&#39;, &#39;static&#39;, &#39;js&#39;, &#39;app.js&#39; ]  
</code></pre>
<h2 id="path-join"><a href="#path-join" class="headerlink" title="path.join"></a>path.join</h2><p>方法使用平台特定的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。Unix系统是<code>/</code>，Windows系统是<code>\</code>。</p>
<pre><code>path.join([...paths])
</code></pre>
<p>例子:</p>
<pre><code>const path =require(&quot;path&quot;);
const static=path.join(&#39;static&#39;,&#39;js&#39;,&#39;app.js&#39;);
console.log(static)
</code></pre>
<p>运行结果：</p>
<pre><code>static\js\app.js
</code></pre>
<h2 id="path-resolve"><a href="#path-resolve" class="headerlink" title="path.resolve"></a>path.resolve</h2><p>方法将路径或路径片段的序列解析为绝对路径。如果没有传入 path 片段，则 path.resolve() 将返回当前工作目录的绝对路径</p>
<pre><code>path.resolve([...paths])
</code></pre>
<p>例子：</p>
<pre><code>const path =require(&quot;path&quot;);
const static=path.resolve(&#39;static&#39;,&#39;js&#39;,&quot;app.js&quot;,&quot;..&quot;);
console.log(static)
console.log(path.resolve())
</code></pre>
<p>运行结果：</p>
<pre><code>  D:\MyProject\DEMO-CODE\PATH\static\js
  D:\MyProject\DEMO-CODE\PATH
</code></pre>
<h3 id="path-resolve-与-path-join-区别"><a href="#path-resolve-与-path-join-区别" class="headerlink" title="path.resolve 与 path.join 区别"></a>path.resolve 与 path.join 区别</h3><p>join是把各个path片段连接在一起； resolve把<code>／</code>当成根目录，在传入非<code>/</code>路径时，会自动加上当前目录形成一个绝对路径，而join仅仅用于路径拼接。</p>
<pre><code>  const path =require(&quot;path&quot;);
  const static=path.join(&#39;static&#39;,&#39;js&#39;,&#39;app.js&#39;);
  const static1=path.join(&#39;../static&#39;,&#39;js&#39;,&#39;app.js&#39;);
  const static2=path.resolve(&#39;static&#39;,&#39;js&#39;,&#39;app.js&#39;);
  const static3=path.resolve(&#39;../static&#39;,&#39;js&#39;,&#39;app.js&#39;)
  console.log(static)
  console.log(static1)
  console.log(static2)
  console.log(static3)
</code></pre>
<p>运行结果：</p>
<pre><code>  static\js\app.js
  ..\static\js\app.js
  D:\MyProject\DEMO-CODE\PATH\static\js\app.js
  D:\MyProject\DEMO-CODE\static\js\app.js
</code></pre>
<p>join只会做拼接，而resolve将多个路径解析为一个规范化的绝对路径。其处理方式类似于对这些路径逐一进行cd操作，与cd操作不同的是，这引起路径可以是文件，并且可不必实际存在。</p>
<h2 id="path-relative"><a href="#path-relative" class="headerlink" title="path.relative"></a>path.relative</h2><p>法根据当前工作目录返回 from 到 to 的相对路径。</p>
<pre><code>path.relative(from, to)
</code></pre>
<p>例子，</p>
<pre><code>const path =require(&quot;path&quot;);
const static=path.resolve(&#39;static&#39;,&#39;js&#39;,&#39;app.js&#39;);
const img=path.resolve(&#39;static&#39;,&#39;img&#39;,&#39;20190701223743,jpg&#39;);
console.log(path.relative(img,static))
</code></pre>
<p>将返回从img目录进入static目录的相对路径</p>
<pre><code>  ..\\..\\js\\app.js
</code></pre>
<p>如果两个不在一个盘符下，将返回参数to的路径</p>
<pre><code>const path =require(&quot;path&quot;);
const cDir=path.resolve(process.argv[0]);
console.log(path.relative(img,cDir))
</code></pre>
<p>结果为：</p>
<pre><code>  C:\\Program Files\\nodejs\\node.exe
</code></pre>
<h2 id="path-parse"><a href="#path-parse" class="headerlink" title="path.parse"></a>path.parse</h2><p>法返回一个对象，其属性表示 path 的重要元素。 尾部的目录分隔符将被忽略，</p>
<pre><code>path.parse(path)
</code></pre>
<p>例子：</p>
<pre><code>const path =require(&quot;path&quot;);
const static=path.resolve(&#39;static&#39;,&#39;js&#39;,&#39;app.js&#39;);
console.log(path.parse(static))
</code></pre>
<p>运行结果</p>
<pre><code>&#123; root: &#39;D:\\&#39;,
dir: &#39;D:\\MyProject\\DEMO-CODE\\PATH\\static\\js&#39;, //文件目录
base: &#39;app.js&#39;, //文件名
ext: &#39;.js&#39;, //文件扩展名
name: &#39;app&#39; &#125; //文件名称
</code></pre>
]]></content>
      <categories>
        <category>Nodejs 系列</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Python系列-1-基本数据类型</title>
    <url>/Python%E7%B3%BB%E5%88%97-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最早接触到Python大概是在2009年，当时还在各大塞班（Symbina）论坛逛帖子，那时候大家都叫“大蟒蛇平台”，其实是python发音的一种音译。诺基亚的Symbina智能手机上支持C++和JAVA开发的两类程序， 装上Python后，也就可以支持众多以Python开发的各种程序了。曾经一度想自己编写，下载了论坛置顶资料，后来还是被不知道丢到哪里~</p>
<p>近两年python随着人工智能，数据分析，网络爬虫的火爆，python的天然优势又出来了，越来越多的人开始关注到python，其中包括我，十一年过去了，我又要“重新启航”了。</p>
<p>学习一门语言，先从基本数据类型开始吧。</p>
<span id="more"></span>

<p><img src="1.png"></p>
<h2 id="Number-数字"><a href="#Number-数字" class="headerlink" title="Number-数字"></a>Number-数字</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>包括正整数与负整数，如：8，-100等, 整型是没有限制大小的，可以当做long类型使用（没有 python2 中的 Long）</p>
<pre><code>2 进 制：以&#39;0b&#39;开头。例如：&#39;0b11011&#39;表示10进制的27
8 进 制：以&#39;0o&#39;开头。例如：&#39;0o33&#39;表示10进制的27
10进制：正常显示
16进制：以&#39;0x&#39;开头。例如：&#39;0x1b&#39;表示10进制的27
</code></pre>
<p>各进间数字进行转换（内置函数）：</p>
<pre><code>bin(i)：将i转换为2进制，以“0b”开头。
oct(i)：将i转换为8进制，以“0o”开头。
int(i)：将i转换为10进制，正常显示。
hex(i)：将i转换为16进制，以“0x”开头。
</code></pre>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数也就是小数，整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。到 Python3 中，把 True 和 False 定义成关键字了，但它们的值还是 1 和 0，它们可以和数字相加。注意大小写写法。</p>
<pre><code>print(True == 1) # True
print(False == 0) # True
</code></pre>
<p>下列对象的布尔值是False：</p>
<pre><code>None；False；0（整型），0.0（浮点型）；0L（长整形）；0.0+0.0j（复数）；“”（空字符串）；[]（空列表）；（）（空元组）；&#123;&#125;（空字典）
</code></pre>
<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>Python可以表示复数，日常用到复数的不过，先复习下复数的相关概念：</p>
<ol>
<li><p>把形如z=a+bi（a,b均为实数）的数称为复数，其中a称为实部，b称为虚部，i称为虚数单位，i<sup>2</sup>=-1;</p>
</li>
<li><p>将复数的实部与虚部的平方和的正的平方根的值称为该复数的模，记作<code>∣z∣</code></p>
</li>
</ol>
<p><img src="2.png"></p>
<p>关于复数的理解可以查看底部参考文章来进一步了解。</p>
<p>我们回到Python语法中：</p>
<pre><code>a=4.7+0.666j           #定义一个虚数
print(a)               #输出这个虚数
print(a.real)          #输出实部
print(a.imag)          #输出虚部
print(a.conjugate())   #输出该复数的共轭复数
</code></pre>
<p>运行结果：</p>
<pre><code>(4.7+0.666j)
4.7
0.666
(4.7-0.666j)
</code></pre>
<p>除了直接定义外，还可以通过<code>complex()</code>，创建一个复数或者将一个数或字符串转换为复数形式：</p>
<pre><code>complex(3.2,0.005) # (3.2+0.005j)
complex(1)    # (1 + 0j)
complex(&#39;2+0.01j&#39;)  # (2+0.01j)
</code></pre>
<h3 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h3><pre><code>n=100           # Create
del n           # Delete 删除变量
print(n)        # 访问报错
</code></pre>
<h3 id="随机函数"><a href="#随机函数" class="headerlink" title="随机函数"></a>随机函数</h3><p>random标准库为Python提供了生成随机数的工具（以下方法使用时需<code>import random</code>）</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>choice(seq)</td>
<td>从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td>
</tr>
<tr>
<td>randrange</td>
<td>([start,] stop [,step])    从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</td>
</tr>
<tr>
<td>random()</td>
<td>随机生成下一个实数，它在[0,1)范围内。</td>
</tr>
<tr>
<td>seed([x])</td>
<td>改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td>
</tr>
<tr>
<td>shuffle(lst)</td>
<td>将序列的所有元素随机排序</td>
</tr>
<tr>
<td>uniform(x, y)</td>
<td>随机生成下一个实数，它在[x,y]范围内。</td>
</tr>
</tbody></table>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p>math标准库为Python提供了常用数学方法（以下方法除了<code>abs,max,min,pow,round</code>内置函数外，使用时均需<code>import math</code>）</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>abs(x)</td>
<td>返回数字的绝对值, 如abs(-10) 返回 10</td>
</tr>
<tr>
<td>max(x1, x2,…)</td>
<td>返回给定参数的最大值，参数可以为序列。</td>
</tr>
<tr>
<td>min(x1, x2,…)</td>
<td>返回给定参数的最小值，参数可以为序列。</td>
</tr>
<tr>
<td>pow(x, y)</td>
<td>x**y 运算后的值。</td>
</tr>
<tr>
<td>round(x [,n])</td>
<td>返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。其实准确的说是保留值将保留到离上一位更近的一端。</td>
</tr>
<tr>
<td>ceil(x)</td>
<td>返回数字的上入整数, 如math.ceil(4.1) 返回 5</td>
</tr>
<tr>
<td>exp(x)</td>
<td>返回e的x次幂(ex), 如math.exp(1) 返回2.718281828459045</td>
</tr>
<tr>
<td>fabs(x)</td>
<td>返回数字的绝对值, 如math.fabs(-10) 返回10.0</td>
</tr>
<tr>
<td>floor(x)</td>
<td>返回数字的下舍整数，如math.floor(4.9) 返回 4</td>
</tr>
<tr>
<td>log(x)</td>
<td>如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td>
</tr>
<tr>
<td>log10(x)</td>
<td>返回以10为基数的x的对数，如math.log10(100)返回 2.0</td>
</tr>
<tr>
<td>modf(x)</td>
<td>返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。math.modf(3.1415)) 返回 (0.14150000000000018, 3.0)</td>
</tr>
<tr>
<td>sqrt(x)</td>
<td>返回数字x的平方根。math.sqrt(100) 返回 10.0</td>
</tr>
<tr>
<td>acos(x)</td>
<td>返回x的反余弦弧度值。</td>
</tr>
<tr>
<td>asin(x)</td>
<td>返回x的反正弦弧度值。</td>
</tr>
<tr>
<td>atan(x)</td>
<td>返回x的反正切弧度值。</td>
</tr>
<tr>
<td>atan2(y, x)</td>
<td>返回给定的 X 及 Y 坐标值的反正切值。</td>
</tr>
<tr>
<td>cos(x)</td>
<td>返回x的弧度的余弦值。</td>
</tr>
<tr>
<td>hypot(x, y)</td>
<td>返回欧几里德范数 sqrt(x<em>x + y</em>y)。</td>
</tr>
<tr>
<td>sin(x)</td>
<td>返回的x弧度的正弦值。</td>
</tr>
<tr>
<td>tan(x)</td>
<td>返回x弧度的正切值。</td>
</tr>
<tr>
<td>degrees(x)</td>
<td>将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0</td>
</tr>
<tr>
<td>radians(x)</td>
<td>将角度转换为弧度</td>
</tr>
</tbody></table>
<h3 id="数学常量"><a href="#数学常量" class="headerlink" title="数学常量"></a>数学常量</h3><p>同样需要引入math标准库</p>
<table>
<thead>
<tr>
<th>常量名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>pi</td>
<td>数学常量 pi（圆周率，一般以π来表示）, math.pi</td>
</tr>
<tr>
<td>e</td>
<td>数学常量 e，e即自然常数（自然常数）, math.e</td>
</tr>
</tbody></table>
<h2 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String-字符串"></a>String-字符串</h2><p>字符串是以单引号<code>&#39;</code>或双引号<code>&quot;</code>或者三引号<code>&#39;&#39;&#39;</code>括起来的任意文本，如果需要包含引号，请用转义符<code>\</code>,如：</p>
<pre><code>print(&#39;Tom say:\&quot;Hello!\&quot;&#39;)
</code></pre>
<p>三引号支持换行</p>
<pre><code>print(&#39;&#39;&#39;
Hi Lili
Hi Tom&#39;&#39;&#39;)
</code></pre>
<p>字符串的截取的语法格式为：<code>变量[头下标:尾下标]</code>,<code>+</code>号拼接，<code>*</code>号复制：</p>
<pre><code>str = &#39;Hello world&#39;
print (str)          # 输出字符串
print (str[0:-1])    # 输出第一个到倒数第二个的所有字符
print (str[0])       # 输出字符串第一个字符
print (str[2:5])     # 输出从第三个开始到第五个的字符
print (str[2:])      # 输出从第三个开始的后的所有字符
print (str * 2)      # 输出字符串两次，也可以写成 print (2 * str)
print (str + &quot;TEST&quot;) # 连接字符串
</code></pre>
<p>运行结果：</p>
<pre><code>Hello world
Hello worl
H
llo
llo world
Hello worldHello world
Hello worldTEST
</code></pre>
<p>字符串元素不可被修改,如下操作会报错：</p>
<pre><code>str = &#39;Hello world&#39;
str[0]=&#39;C&#39;
print(str) # TypeError: &#39;str&#39; object does not support item assignment
</code></pre>
<p>f-string 格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去</p>
<h3 id="Bytes-类型"><a href="#Bytes-类型" class="headerlink" title="Bytes 类型"></a>Bytes 类型</h3><p>Python3 新增 bytes 类型，是指一堆字节的集合，十六进制表现形式，两个十六进制数构成一个 byte ，用带b前缀的单引号或双引号来表示。bytes通常用于网络数据传输、二进制图片和文件的保存等等。  </p>
<p>Bytes 与 String 可以相关转换</p>
<p><img src="3.png"></p>
<p>举个例子：</p>
<pre><code>b1 = bytes()
print(b1) # b&#39;&#39;
str=&#39;你好&#39;
result=str.encode(encoding=&#39;utf-8&#39;) # b&#39;\xe4\xbd\xa0\xe5\xa5\xbd&#39;
print(result)
print(result.decode(encoding=&#39;utf-8&#39;)) # 你好
</code></pre>
<h3 id="转义与格式化"><a href="#转义与格式化" class="headerlink" title="转义与格式化"></a>转义与格式化</h3><p>在需要在字符中使用特殊字符时，python用反斜杠<code>\</code>转义字符(同js)。</p>
<p>在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。</p>
<pre><code>print (&quot;我叫 %s 今年 %d 岁!&quot; % (&#39;小明&#39;, 10)) # 我叫 小明 今年 10 岁!
</code></pre>
<h3 id="CRUD-1"><a href="#CRUD-1" class="headerlink" title="CRUD"></a>CRUD</h3><pre><code>str=&#39;abc&#39;            # Create
print(&#39;p&#39;+str[1:3])  # Update  无法修改，可以通过+号重新创建
print(str[0])        # Retrieve 
del str              # Delete 删除变量，不同于列表，集合，字典等，依旧可以访问
print(str)           #  &lt;class &#39;str&#39;&gt;
</code></pre>
<h3 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h3><p>f-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。</p>
<p>之前我们习惯用百分号 (%):</p>
<pre><code>name = &quot;Jack&quot;
print(&quot;My name is %s&quot; %name)    # My name is Jack
</code></pre>
<p>如果采用f-string表达更简单了（类似NodeJs中的模板字符串）</p>
<pre><code>print(f&quot;My name is &#123;name&#125;&quot;)     # My name is Jack
</code></pre>
<h3 id="String类型方法"><a href="#String类型方法" class="headerlink" title="String类型方法"></a>String类型方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>len(string)</td>
<td>返回字符串长度</td>
<td>略</td>
</tr>
<tr>
<td>lower()</td>
<td>转换字符串中所有大写字符为小写</td>
<td>略</td>
</tr>
<tr>
<td>upper()</td>
<td>转换字符串中的小写字母为大写</td>
<td>略</td>
</tr>
<tr>
<td>swapcase()</td>
<td>将字符串中大写转换为小写，小写转换为大写</td>
<td>略</td>
</tr>
<tr>
<td>capitalize()</td>
<td>将字符串的第一个字符转换为大写</td>
<td>略</td>
</tr>
<tr>
<td>title()</td>
<td>返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td>
<td>略</td>
</tr>
<tr>
<td>join(seq)</td>
<td>以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td>
<td>以<code>s=&#39;-&#39;</code>为例：<code>s.join((&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;))</code> : <code>h-e-l-l-o</code>   <code>s.join([&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;])</code>：<code>h-e-l-l-o</code>  <code>s.join(&#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;</code> : <code>l-e-o-h</code>(每次均不同)</td>
</tr>
<tr>
<td>center(width, fillchar)</td>
<td>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格(不能完全居中就有出现偏移)</td>
<td>以<code>s=&#39;[go]&#39;</code>为例： <code>s.center(10,&#39;*&#39;)</code>：<code>***[go]***</code>  <code>s.center(11,&#39;*&#39;)</code>：<code>****[go]***</code></td>
</tr>
<tr>
<td>count(<code>str, beg= 0,end=len(string)</code>)</td>
<td>返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td>
<td><code>&quot;abab&quot;.count(&#39;ab&#39;)</code>：<code>2</code>  <code>&quot;abab&quot;.count(&#39;ab&#39;,2,4)</code>：<code>1</code></td>
</tr>
<tr>
<td>bytes.decode(<code>encoding=&quot;utf-8&quot;, errors=&quot;strict&quot;</code>)</td>
<td>Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回</td>
<td><code>(&#39;好&#39;.encode(&quot;UTF-8&quot;)).decode(&#39;UTF-8&#39;,&#39;strict&#39;)</code> : <code>好</code></td>
</tr>
<tr>
<td>encode(<code>encoding=&#39;UTF-8&#39;,errors=&#39;strict&#39;</code>)</td>
<td>以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td>
<td><code>&quot;好&quot;.encode(&#39;UTF-8&#39;)</code>：<code>b&#39;\xe5\xa5\xbd&#39;</code>  <code>&quot;好&quot;.encode(&#39;GBK&#39;)</code>：<code>b&#39;\xba\xc3&#39;</code></td>
</tr>
<tr>
<td>endswith(<code>suffix, beg=0, end=len(string)</code>)</td>
<td>指定后缀结尾，如果是返回 True，否则返回 False，可选参数 “start” 与 “end” 为检索字符串的开始与结束位置</td>
<td><code>&#39;abc!!&#39;.endswith(&#39;!!&#39;,3,5)</code> ：<code>True</code></td>
</tr>
<tr>
<td>expandtabs(tabsize=8)</td>
<td>把字符串 string 中的 tab 符号 <code>\t</code>转为空格，tab 符号默认的空格数是 8</td>
<td>略</td>
</tr>
<tr>
<td>find(str, beg=0, end=len(string))</td>
<td>检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td>
<td><code>&quot;abcd&quot;.find(&#39;ab&#39;,0,1)</code> ：-1</td>
</tr>
<tr>
<td>index(str, beg=0, end=len(string))</td>
<td>跟find()方法一样，只不过如果str不在字符串中会报一个异常</td>
<td><code>&quot;abcd&quot;.find(&#39;ab&#39;,0,1)</code> ：报错</td>
</tr>
<tr>
<td>rfind(str, beg=0,end=len(string))</td>
<td>类似于 find()函数，不过是从右边开始查找</td>
<td>略</td>
</tr>
<tr>
<td>rindex( str, beg=0, end=len(string))</td>
<td>类似于 index()，不过是从右边开始</td>
<td>略</td>
</tr>
<tr>
<td>isalnum()</td>
<td>如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</td>
<td>略</td>
</tr>
<tr>
<td>isalpha()</td>
<td>如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</td>
<td>略</td>
</tr>
<tr>
<td>isdigit()</td>
<td>如果字符串只包含数字则返回 True 否则返回 False</td>
<td>略</td>
</tr>
<tr>
<td>isnumeric()</td>
<td>如果字符串中只包含数字字符，则返回 True，否则返回 False</td>
<td>略</td>
</tr>
<tr>
<td>islower()</td>
<td>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td>
<td>略</td>
</tr>
<tr>
<td>isspace()</td>
<td>如果字符串中只包含空白，则返回 True，否则返回 False</td>
<td>略</td>
</tr>
<tr>
<td>istitle()</td>
<td>如果字符串是标题化的(见 title())则返回 True，否则返回 False</td>
<td>略</td>
</tr>
<tr>
<td>isupper()</td>
<td>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td>
<td>略</td>
</tr>
<tr>
<td>ljust(width[, fillchar])</td>
<td>返回一个原字符串左对齐,并使用 fillchar(默认为空格) 填充至长度 width 的新字符串, 如果指定的长度小于原字符串的长度则返回原字符串</td>
<td><code>&quot;abcd&quot;.ljust(10,&#39;@&#39;)</code>：<code>abcd@@@@@@</code></td>
</tr>
<tr>
<td>rjust(width,[, fillchar])</td>
<td>同ljust，不同的是返回一个右对齐的原字符串</td>
<td>略</td>
</tr>
<tr>
<td>lstrip([chars])</td>
<td>截掉字符串左边的空格或指定字符(默认截掉左边空格)。</td>
<td><code>&quot;111abcd11&quot;.lstrip(&#39;1&#39;)</code>：<code>abcd11</code></td>
</tr>
<tr>
<td>rstrip([chars])</td>
<td>功能同 lstrip ，不过截取的为字符串右边空格或指定字符</td>
<td>略</td>
</tr>
<tr>
<td>strip([chars])</td>
<td>在字符串上执行 lstrip()和 rstrip()</td>
<td>略</td>
</tr>
<tr>
<td>max(str)</td>
<td>返回字符串 str 中最大的字母</td>
<td>略</td>
</tr>
<tr>
<td>min(str)</td>
<td>返回字符串 str 中最小的字母</td>
<td>略</td>
</tr>
<tr>
<td>replace(old, new [, max])</td>
<td>把 将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次</td>
<td></td>
</tr>
<tr>
<td>split(<code>str=&quot;&quot;, num=string.count(str)</code>)</td>
<td>通过指定分隔符对字符串进行切片，如果第二个参数 num 有指定值(默认全部分隔)，则分割为 num+1 个子字符串</td>
<td>s=”a1bc1d” <code>s.split(&#39;1&#39;,1)</code>：<code>[&#39;a&#39;, &#39;bc1d&#39;]</code>  <code>s.split(&#39;1&#39;,5)</code>：<code>[&#39;a&#39;, &#39;bc&#39;, &#39;d&#39;]</code></td>
</tr>
<tr>
<td>splitlines([keepends])</td>
<td>按照行<code>(&#39;\r&#39;, &#39;\r\n&#39;, \n&#39;)</code>分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td>
<td><code>&#39;ab c\n\nde fg\rkl\r\n&#39;.splitlines()</code>: <code>[&#39;ab c&#39;, &#39;&#39;, &#39;de fg&#39;, &#39;kl&#39;]</code></td>
</tr>
<tr>
<td>startswith(substr, beg=0,end=len(string))</td>
<td>检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查</td>
<td><code>&quot;abcd&quot;.startswith(&#39;cd&#39;,2,4))</code> : <code>True</code></td>
</tr>
<tr>
<td>maketrans()</td>
<td>创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标</td>
<td><code>trantab = str.maketrans(&quot;aeiou&quot;, &quot;12345&quot;)</code> (一般与translate搭配使用)</td>
</tr>
<tr>
<td>translate(table, deletechars=””)</td>
<td>根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</td>
<td><code>&quot;this is string example&quot;.translate(trantab)</code> : <code>th3s 3s str3ng 2x1mpl2</code></td>
</tr>
<tr>
<td>zfill (width)</td>
<td>返回长度为 width 的字符串，原字符串右对齐，前面填充0</td>
<td><code>&quot;abcd&quot;.zfill(10)</code>：<code>000000abcd</code>  <code>&quot;abcd&quot;.zfill(1)</code> ：<code>abcd</code></td>
</tr>
<tr>
<td>isdecimal()</td>
<td>检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false(方法只存在于unicode对象)</td>
<td><code>&quot;abcd&quot;.isdecimal()</code>：<code>True</code>  <code>&quot;100&quot;.isdecimal()</code>：<code>False</code></td>
</tr>
</tbody></table>
<h2 id="List-列表"><a href="#List-列表" class="headerlink" title="List-列表"></a>List-列表</h2><p>List（列表） 是 Python 中使用最频繁的数据类型。<br>列表是写在方括号 [] 之间、用逗号分隔开的元素列表。与Javascript中的数组非常相似。列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p>
<p>操作与字符串很多相似之处:</p>
<pre><code>list = [1,0.02,True,&#39;Hi&#39;]
print(list[3])
print(list[0:-1])
print(list*2)
print(list+[&#39;Tom&#39;])
print(list[0:3])
print(list[0:3:2]) #截取可以接收第三个参数，参数作用是截取的步长
</code></pre>
<p>运行结果：</p>
<pre><code>Hi
[1, 0.02, True]
[1, 0.02, True, &#39;Hi&#39;, 1, 0.02, True, &#39;Hi&#39;]
[1, 0.02, True, &#39;Hi&#39;, &#39;Tom&#39;]
[1, 0.02, True]
[1, True]
</code></pre>
<p>列表的元素不同于字符串，元素是可以被修改的</p>
<pre><code>list = [1,0.02,True,&#39;Hi&#39;]
list[0]=&#39;c&#39;
print(list)
</code></pre>
<p>运行结果：</p>
<pre><code>[&#39;c&#39;, 0.02, True, &#39;Hi&#39;]
</code></pre>
<h3 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h3><p>废话不说，上代码：</p>
<pre><code>ls=[1,2,3]    # Create
ls[0]=0       # Update
print(ls[0])  # Retrieve
del ls[2]     # Delete
print(ls)     # [0, 2]
del ls        # 删除变量，访问ls会报错
</code></pre>
<h3 id="List类型方法"><a href="#List类型方法" class="headerlink" title="List类型方法"></a>List类型方法</h3><p>设置<code>ls=[1,2,1]</code>，有如下表格：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>list.append(obj)</td>
<td>在列表末尾添加新的对象，返回None</td>
<td><code>ls.append((2,0))</code> ： [1,2,1,(2, 0)]</td>
</tr>
<tr>
<td>list.count(obj)</td>
<td>统计某个元素在列表中出现的次数，返回次数</td>
<td><code>ls.count(1)</code> ：2</td>
</tr>
<tr>
<td>list.extend(seq)</td>
<td>在列表末尾一次性追加另一个序列中的多个值,返回None</td>
<td><code>ls.extend((2,0))</code> ： [1,2,1,2,0]</td>
</tr>
<tr>
<td>list.index(obj)</td>
<td>从列表中找出某个值第一个匹配项的索引位置,返回索引</td>
<td><code>ls.index(1)</code> ：0</td>
</tr>
<tr>
<td>list.insert(index,obj)</td>
<td>将对象插入列表,返回为None</td>
<td><code>ls.insert(1,-10)</code> ：[1, -10, 2, 1]</td>
</tr>
<tr>
<td>list.pop(index=-1)</td>
<td>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td>
<td><code>ls.pop(0)</code> ：[2,1]</td>
</tr>
<tr>
<td>list.remove(obj)</td>
<td>移除列表中某个值的第一个匹配项,返回为None</td>
<td><code>ls.remove(1)</code> ：[2,1]</td>
</tr>
<tr>
<td>list.reverse()</td>
<td>反向列表中元素,返回为None</td>
<td><code>ls.reverse()</code> ：[1,2,1]</td>
</tr>
<tr>
<td>list.sort(key=None, reverse=False)</td>
<td>key用来进行比较的元素;reverse :True降序,False升序（默认），返回None</td>
<td><code>ls.sort()</code> ：[1,1,2]</td>
</tr>
<tr>
<td>list.clear()</td>
<td>清空列表，返回None</td>
<td><code>ls.clear()</code> ：[]</td>
</tr>
<tr>
<td>list.copy()</td>
<td>复制列表，返回复制后的新列表(非指针)</td>
<td><code>ls.copy()</code> ：[1,2,1]</td>
</tr>
</tbody></table>
<h2 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple-元组"></a>Tuple-元组</h2><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。<br>元组写在小括号 () 里，元素之间用逗号隔开（可以把字符串看作一种特殊的元组）</p>
<pre><code>tup = (1, 2, &#39;3&#39;, 4.1, 5, 6)
tup1 = ()    # 空元组
tup2 = (20,) # 一个元素，需要在元素后添加逗号
tup3 = (20) # 一个元素，不加逗号就变成的Number类型

print(tup[0]) # 1
print(tup1)   # ()
print(type(tup2)) # &lt;class &#39;tuple&#39;&gt;
print(type(tup3)) # &lt;class &#39;int&#39;&gt;
</code></pre>
<h3 id="CURD-1"><a href="#CURD-1" class="headerlink" title="CURD"></a>CURD</h3><p>相比列表，元组是无法修改的，所以只能更新出新元组</p>
<pre><code>tup=(1,2,3)         # Create
print(tup + (4,5))  # tup[0]=0 会报错
print(tup[0])       # Retrieve
del tup             # del tup[2] 会报错 且删除后变量tup就不存在了
</code></pre>
<h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set-集合"></a>Set-集合</h2><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。基本功能是进行成员关系测试和删除重复元素。  </p>
<p>可以使用大括号 <code>&#123; &#125;</code> 或者 <code>set()</code> 函数创建集合。不过创建一个空集合必须用 <code>set()</code> 而不是 <code>&#123; &#125;</code>，因为 <code>&#123; &#125;</code> 是用来创建一个空字典</p>
<pre><code>sites = &#123;&#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;y&#39;&#125;
sitea = set([&#39;b&#39;,&#39;a&#39;,&#39;t&#39;,&#39;t&#39;,&#39;l&#39;,&#39;e&#39;])
print(sites)  # 输出集合，重复的元素被自动去掉
print(sitea)
print(sites - sitea) # a 和 b 的差集
print(sites | sitea)  # a 和 b 的并集
print(sites &amp; sitea) # a 和 b 的交集
print(sites ^ sitea)  # a 和 b 中不同时存在的元素
</code></pre>
<p>运行结果：</p>
<pre><code>&#123;&#39;y&#39;, &#39;b&#39;, &#39;a&#39;&#125;
&#123;&#39;e&#39;, &#39;l&#39;, &#39;a&#39;, &#39;t&#39;, &#39;b&#39;&#125;
&#123;&#39;y&#39;&#125;
&#123;&#39;e&#39;, &#39;l&#39;, &#39;a&#39;, &#39;t&#39;, &#39;b&#39;, &#39;y&#39;&#125;
&#123;&#39;b&#39;, &#39;a&#39;&#125;
&#123;&#39;y&#39;, &#39;t&#39;, &#39;e&#39;, &#39;l&#39;&#125;
</code></pre>
<p>集合本身是一个无序的不重复元素序列，并不支持索引操作。</p>
<h3 id="CURD-2"><a href="#CURD-2" class="headerlink" title="CURD"></a>CURD</h3><p>集合本身不支持索引操作，常用操作中只剩下删除操作支持</p>
<pre><code>s=&#123;1,2,3&#125;
print(s)
del s
</code></pre>
<h3 id="Set类型方法"><a href="#Set类型方法" class="headerlink" title="Set类型方法"></a>Set类型方法</h3><p>以<code>set=&#123;1,2,1&#125;</code>为例，有如下表格：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>set.add(ele)</td>
<td>为集合添加元素(只能添加Sting或Number)，返回None</td>
<td><code>set.add(&#39;5&#39;)</code> ：{1, 2, ‘5’}</td>
</tr>
<tr>
<td>set.clear()</td>
<td>移除集合中的所有元素，返回None</td>
<td><code>set.clear()</code> ：set()</td>
</tr>
<tr>
<td>set.copy()</td>
<td>拷贝一个集合 返回复制后的新集合(非指针)</td>
<td><code>set.copy()</code> ：{1, 2}</td>
</tr>
<tr>
<td>set.update(obj)</td>
<td>给集合添加元素</td>
<td><code>set.update(&#123;3,1,5&#125;)</code>  ：{1, 2, 3, 5}</td>
</tr>
<tr>
<td>set.pop()</td>
<td>随机移除元素,返回被删除的元素</td>
<td><code>set.pop()</code>  ：{}</td>
</tr>
<tr>
<td>set.remove(item)</td>
<td>移除指定元素(元素不存在会报错)</td>
<td><code>set.remove(2)</code>  ：{1}</td>
</tr>
<tr>
<td>set.difference(s)</td>
<td>返回多个集合的差集，元素包含在集合 set中,但不在集合s中</td>
<td><code>set.difference(&#123;2,4&#125;)</code> ：{1}</td>
</tr>
<tr>
<td>set.difference_update(s)</td>
<td>移除两个集合都包含的元素,返回None</td>
<td><code>set.difference_update(&#123;2,4&#125;)</code> ：{1}</td>
</tr>
<tr>
<td>set.discard(calue)</td>
<td>删除集合中指定的元素（功能等同remove,但不存在元素时不会报错）</td>
<td><code>set.discard(4)</code> :{1,2}</td>
</tr>
<tr>
<td>set.intersection(set1, set2 … etc)</td>
<td>返回两个或更多集合中都包含的元素，即交集</td>
<td>自行测试</td>
</tr>
<tr>
<td>set.intersection_update()</td>
<td>获取两个或更多集合中都重叠的元素，不同于intersection，该方法会修改原始集合。</td>
<td>自行测试</td>
</tr>
<tr>
<td>set.isdisjoint(s)</td>
<td>判断两个集合是否包含相同的元素，s中是否有包含集合set的元素,不包含返回 True，否则返回 False。</td>
<td>自行测试</td>
</tr>
<tr>
<td>set.issubset(s)</td>
<td>用于判断集合的所有元素是否都包含在指定集合中，即 set 的所有元素是否都包含在集合 s 中,是则返回True，否返回False</td>
<td>自行测试</td>
</tr>
<tr>
<td>set.issuperset(s)</td>
<td>判断指定集合的所有元素是否都包含在原始的集合中, 即s 的所有元素是否都包含在集合 set 中，都包含返回True,否返回False</td>
<td>自行测试</td>
</tr>
<tr>
<td>set.symmetric_difference(s)</td>
<td>返回两个集合中不重复的元素集合，即会移除两个集合中都存在的元素(返回新集合)</td>
<td>自行测试</td>
</tr>
<tr>
<td>set.symmetric_difference_update(s)</td>
<td>原始集合set 中移除与 s 集合中的重复元素，并将不重复的元素插入到集合 set 中</td>
<td>自行测试</td>
</tr>
<tr>
<td>set.union(set1, set2…)</td>
<td>返回两个或多个集合的并集，即包含了所有集合的元素，重复的元素只会出现一次</td>
<td>自行测试</td>
</tr>
</tbody></table>
<h2 id="Dictionary-字典"><a href="#Dictionary-字典" class="headerlink" title="Dictionary-字典"></a>Dictionary-字典</h2><p>字典（dictionary）是Python中另一个非常有用的内置数据类型。是一种映射类型，字典用 <code>&#123; &#125;</code> 标识，它是一个无序的 键(key) : 值(value) 的集合,非常类似Javascript中的对象（key如果为String类型就必须用引号，这点与js不同）。</p>
<p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p>
<pre><code>dicta=&#123;&#39;name&#39;:&#39;jack&#39;,&#39;age&#39;:12&#125;
dictb=dict([(&#39;name&#39;,&#39;tom&#39;),(&#39;job&#39;,&#39;worker&#39;)])
print(dicta)
print(dicta.keys())
print(dicta.values())
print(dictb)
print(dicta[&#39;name&#39;])
</code></pre>
<p>运行结果：</p>
<pre><code>&#123;&#39;name&#39;: &#39;jack&#39;, &#39;age&#39;: 12&#125;
dict_keys([&#39;name&#39;, &#39;age&#39;])
dict_values([&#39;jack&#39;, 12])
&#123;&#39;name&#39;: &#39;tom&#39;, &#39;job&#39;: &#39;worker&#39;&#125;
jack
</code></pre>
<h3 id="CURD-3"><a href="#CURD-3" class="headerlink" title="CURD"></a>CURD</h3><p>与列表非常类似，因为字典键值的唯一性与不可变性，通过键值来进行索引（键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行）</p>
<pre><code>dict=&#123;&#39;name&#39;:&#39;Tom&#39;,&#39;age&#39;:12&#125;    # Create
dict[&#39;name&#39;]=&#39;Jack&#39;             # Update
print(dict[&#39;name&#39;])             # Retrieve
del dict[&#39;age&#39;]                 # Delete
print(dict)                     # &#123;&#39;name&#39;: &#39;Jack&#39;&#125;
del dict                        # 删除变量，访问dict会报错
</code></pre>
<h3 id="Dictionary类型方法"><a href="#Dictionary类型方法" class="headerlink" title="Dictionary类型方法"></a>Dictionary类型方法</h3><p>以<code>dit=&#123;&#39;s&#39;:&quot;Tom&quot;,1:&#39;14&#39;&#125;</code>为例，有如下表格：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>dict.clear()</td>
<td>删除字典内所有元素，返回None</td>
<td><code>dit.clear()</code> ：{}</td>
</tr>
<tr>
<td>dict.copy()</td>
<td>返回一个字典的浅复制, 深拷贝父对象（一级目录），子对象（二级目录）不拷贝，还是引用（赋值操作只是复制了一个指针）</td>
<td><code>dit.copy()</code>：<code>&#123;&#39;s&#39;:&#39;Tom&#39;, 1:&#39;14&#39;&#125;</code></td>
</tr>
<tr>
<td>dict.fromkeys(seq[, value])</td>
<td>创建一个新字典，以序列 seq 中元素做字典的键，value 为字典所有键对应的初始值</td>
<td><code>dict.fromkeys((1,2,3),0)</code>: <code>&#123;1: 0, 2: 0, 3: 0&#125;</code> (注意必须通过dict实例或者dict类名来调用)</td>
</tr>
<tr>
<td>dict.get(key, default=None)</td>
<td>返回指定键的值，如果键不在字典中返回默认值。</td>
<td><code>dit.get(&#39;s&#39;)</code>：Tom  <code>dit.get(&#39;t&#39;)</code>：None</td>
</tr>
<tr>
<td>dict.setdefault(key, default=None)</td>
<td>与get类似，如果键不已经存在于字典中，将会添加键并将值设为默认值(不同于get,该方法会修改dict)</td>
<td><code>dit.setdefault(2)</code> ：<code>&#123;&#39;s&#39;: &#39;Tom&#39;, 1: &#39;14&#39;, 2: None&#125;</code></td>
</tr>
<tr>
<td>key in dict</td>
<td>in 操作符用于判断键是否存在于字典中，存在返回True，否则返回False</td>
<td><code>&#39;s&#39; in dit</code>：True</td>
</tr>
<tr>
<td>key not in dict</td>
<td>not in 操作符与in正好相反</td>
<td><code>&#39;s&#39; not in dit</code>：False</td>
</tr>
<tr>
<td>dict.items()</td>
<td>以列表返回可遍历的(键, 值) 元组数组</td>
<td><code>dit.items()</code> : <code>dict_items([(&#39;s&#39;, &#39;Tom&#39;), (1, &#39;14&#39;)])</code></td>
</tr>
<tr>
<td>dict.keys()</td>
<td>返回一个可迭代对象，可以使用 list() 来转换为列表</td>
<td><code>list(dit.keys())</code> ：<code>[&#39;s&#39;, 1]</code></td>
</tr>
<tr>
<td>dict.update(dict2)</td>
<td>字典参数 dict2 的 key/value(键/值) 对更新到字典 dict 里，返回None，直接修改dict</td>
<td><code>dit.update(&#123;&#39;t&#39;:0&#125;</code>：<code>&#123;&#39;s&#39;: &#39;Tom&#39;, 1: &#39;14&#39;, &#39;t&#39;: 0&#125;</code></td>
</tr>
<tr>
<td>dict.values()</td>
<td>返回一个迭代器，可以使用 list() 来转换为列表，列表为字典中的所有值</td>
<td>：<code>dict_values([&#39;Tom&#39;, &#39;14&#39;])</code></td>
</tr>
<tr>
<td>pop(key[,default])</td>
<td>删除字典给定键 key 所对应的值，返回值为被删除的值,如果key值不存在，则返回default，否则就报错</td>
<td><code>dit.pop(&#39;s&#39;,99)</code>：<code>Tom</code>(如果s不存在则会返回99，否则报错)</td>
</tr>
<tr>
<td>popitem()</td>
<td>删除字典中的最后一对键和值, 并返回删除的键值（元组）</td>
<td><code>dit.popitem()</code> : <code>(1, &#39;14&#39;)</code></td>
</tr>
</tbody></table>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.cnblogs.com/aiwanbuhui/p/7766352.html">PYTHON3基本数据类型</a></li>
<li><a href="https://www.zhihu.com/question/46877027/answer/542742130">怎么理解虚数和复数？ - 李狗嗨的回答 - 知乎</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Python系列-2-运算符</title>
    <url>/Python%E7%B3%BB%E5%88%97-2-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>了解完基本数据类型后，我们学习下Python中的运算符</p>
<span id="more"></span>

<h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加 - 两个对象相加</td>
<td>1 + 2 输出结果 3</td>
</tr>
<tr>
<td>-</td>
<td>减 - 得到负数或是一个数减去另一个数</td>
<td>1 - 2 输出结果 -1</td>
</tr>
<tr>
<td>*</td>
<td>乘 - 两个数相乘或是返回一个被重复若干次的字符串</td>
<td>2 * 2 输出结果 4</td>
</tr>
<tr>
<td>/</td>
<td>除 - x 除以 y    ,返回浮点型</td>
<td>3 / 3 输出结果 1.0</td>
</tr>
<tr>
<td>%</td>
<td>取模 - 返回除法的余数</td>
<td>2 % 3 输出结果 2</td>
</tr>
<tr>
<td>**</td>
<td>幂 - 返回x的y次幂</td>
<td>2**3 为2的3次方</td>
</tr>
<tr>
<td>//</td>
<td>取整除 - 向下取接近商的整数</td>
<td>9//2 结果为4; -9//2 结果为-5</td>
</tr>
</tbody></table>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>等于 - 比较对象是否相等</td>
<td>1==2 输出结果 False</td>
</tr>
<tr>
<td>!=</td>
<td>不等于 - 比较两个对象是否不相等</td>
<td>1==2 输出结果 True</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于 - 返回x是否大于y</td>
<td>2&gt;3 输出结果 False</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于 - 返回x是否小于y</td>
<td>2&lt;3 输出结果 True</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于 - 返回x是否大于等于y</td>
<td>2&gt;=2 输出结果 True</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于 - 返回x是否小于等于y</td>
<td>-1&lt;=0 输出结果 True</td>
</tr>
</tbody></table>
<p>所有返回值中，1、0 分别等同 True、False</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>简单的赋值运算符</td>
<td>自行测试</td>
</tr>
<tr>
<td>+=</td>
<td>加法赋值运算</td>
<td>自行测试</td>
</tr>
<tr>
<td>-=</td>
<td>减法赋值运算符</td>
<td>自行测试</td>
</tr>
<tr>
<td>*=</td>
<td>乘法赋值运算符</td>
<td>自行测试</td>
</tr>
<tr>
<td>/=</td>
<td>除法赋值运算符</td>
<td>自行测试</td>
</tr>
<tr>
<td>%=</td>
<td>取模赋值运算符</td>
<td>自行测试</td>
</tr>
<tr>
<td>**=</td>
<td>幂赋值运算符</td>
<td>自行测试</td>
</tr>
<tr>
<td>//=</td>
<td>取整除赋值运算符</td>
<td>自行测试</td>
</tr>
<tr>
<td>:=</td>
<td>海象运算符</td>
<td>Python 3.8 新增</td>
</tr>
</tbody></table>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与运算符</td>
<td>自行测试</td>
</tr>
<tr>
<td>丨</td>
<td>按位或运算符</td>
<td>自行测试</td>
</tr>
<tr>
<td>^</td>
<td>按位异或运算符</td>
<td>自行测试</td>
</tr>
<tr>
<td>~</td>
<td>按位取反运算符</td>
<td>自行测试</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移动运算符</td>
<td>自行测试</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移动运算符</td>
<td>自行测试</td>
</tr>
</tbody></table>
<p>按位运算符是把数字看作二进制来进行计算的,10进制数字都会先被转换成二进制进行位运算，然后再转换成10进制输出</p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>and</td>
<td>布尔”与”</td>
</tr>
<tr>
<td>or</td>
<td>布尔”或”</td>
</tr>
<tr>
<td>not</td>
<td>布尔”非”</td>
</tr>
</tbody></table>
<h2 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>如果在指定的序列中找到值返回 True，否则返回 False</td>
</tr>
<tr>
<td>not in</td>
<td>如果在指定的序列中没有找到值返回 True，否则返回 False</td>
</tr>
</tbody></table>
<p>例子：</p>
<pre><code>a = 10
list = [1, 2, 3, 4, 5 ]

if ( a in list ):
  print (&quot;变量 a 在给定的列表中 list 中&quot;)
else:
  print (&quot;变量 a 不在给定的列表中 list 中&quot;)
</code></pre>
<h2 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>is</td>
<td>is 是判断两个标识符是不是引用自一个对象</td>
</tr>
<tr>
<td>is not</td>
<td>is not 是判断两个标识符是不是引用自不同对象</td>
</tr>
</tbody></table>
<p>例子：</p>
<pre><code>a = 20
b = 20

if ( a is b ):
  print (&quot;a 和 b 有相同的标识&quot;)
else:
  print (&quot;a 和 b 没有相同的标识&quot;)
</code></pre>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Python系列-3-条件与循环</title>
    <url>/Python%E7%B3%BB%E5%88%97-3-%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>判断与循环, 在各个语言中基本都有对应实现，也是开始编程最基础的语法，本文学习下pyhon中是如何玩转这些的。</p>
<span id="more"></span>

<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>py中只有<code>if else</code> 判断，没有<code>switch case</code>，语法格式如下：</p>
<pre><code>if &lt;条件判断1&gt;:
    &lt;执行1&gt;
elif &lt;条件判断2&gt;:
    &lt;执行2&gt;
elif &lt;条件判断3&gt;:
    &lt;执行3&gt;
else:
    &lt;执行4&gt;
</code></pre>
<p>举个例子:</p>
<pre><code>s = input(&#39;birth: &#39;)
birth = int(s)  # 此处一定要做类型转换，py不同与js不会做自动类型转换
if birth &lt; 1990:
    print(&#39;90前&#39;)
else:
    print(&#39;90后&#39;)
</code></pre>
<h3 id="三目运算"><a href="#三目运算" class="headerlink" title="三目运算"></a>三目运算</h3><p>Python 是一种极简主义的编程语言，它没有引入<code>? :</code>这个新的运算符，而是使用已有的 if else 关键字来实现相同的功能:</p>
<pre><code>exp1 if contion else exp2
</code></pre>
<p>举个例子：</p>
<pre><code>a=10
b=a*-10 if a&gt;20 else a*10
c=&#39;Leo&#39; if a&gt;100  else (&#39;Tom&#39; if a&gt;10 else &#39;Jack&#39;)
print(b) # 100
print(c) # Jack
</code></pre>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>Python 中的循环语句有 for 和 while。</p>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>语法格式如下：</p>
<pre><code>while 判断条件(condition)：
    执行语句(statements)……
</code></pre>
<p>举个例子：</p>
<pre><code>i=1
while i&gt;=1:
  print(i)
  i += 1
  if i == 15:
    print(&quot;跳出&quot;)
    break
  elif i&gt;10:
    print(&quot;继续&quot;)
    continue
print(&quot;循环结束&quot;)
</code></pre>
<p>当i为15的时候会跳出while循环，执行后面的语句</p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>通过for in 进行循环，千万不要遗漏冒号(:)</p>
<pre><code>lists = [&quot;C&quot;, &quot;C++&quot;, &quot;Perl&quot;, &quot;Python&quot;] 
for item in lists:
    print(item)
print(&quot;循环结束&quot;)
</code></pre>
<p>可以通过break跳出循环：</p>
<pre><code>maps=[1,3,4,7]
for item in maps:
  if(item&gt;3):
    print(item)
    break
print(&#39;循环结束&#39;)
</code></pre>
<p>运行结果：</p>
<pre><code>4
循环结束
</code></pre>
<h3 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h3><p>可以使用内置range()函数。它会生成数列<br>    # 输出0-9<br>    for i in range(10):<br>      print(i)</p>
<pre><code># 输出2-7
for i in range(2,8):
  print(i)

# 指定步长输出：2,5
for i in range(2,8,3):
  print(i)
  
</code></pre>
<h2 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a>pass 语句</h2><p>Python pass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句，如下实例</p>
<pre><code>  for l in &#39;Runoob&#39;: 
    if l == &#39;o&#39;:
        pass
        print (&#39;执行 pass 块&#39;)
    print (&#39;当前字母 :&#39;, l)
  
  print (&quot;Run over!&quot;)
</code></pre>
<p>执行结果：</p>
<pre><code>  当前字母 : R
  当前字母 : u
  当前字母 : n
  执行 pass 块
  当前字母 : o
  执行 pass 块
  当前字母 : o
  当前字母 : b
  Run over!
</code></pre>
<h2 id="其他语句"><a href="#其他语句" class="headerlink" title="其他语句"></a>其他语句</h2><h3 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h3><p>python中的with语句使用于对资源进行访问的场合，保证不管处理过程中是否发生错误或者异常都会执行规定的<code>__exit__</code>（“清理”）操作，释放被访问的资源，比如: 有文件读写后自动关闭、线程中锁的自动获取和释放等</p>
<p>与python中with语句有关的概念有：上下文管理协议、上下文管理器、运行时上下文、上下文表达式、处理资源的代码段。</p>
<p>经常看到的是进行文件操作时会带有with语句</p>
<pre><code>  with open( &#39;/path/to/file&#39;, &#39;r&#39; ) as f:
    print( f.read() ) 
</code></pre>
<p>此处with的作用就是在读取结束后（包括出错后）执行close函数，不用我们每次调取。</p>
<h3 id="del-语句"><a href="#del-语句" class="headerlink" title="del 语句"></a>del 语句</h3><p>del语句删除一些对象引用,只是删除引用，变为了一个可回收的对象，内存会不定期回收</p>
<h3 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h3><p>返回函数执行结果, 与c++/nodejs等基本一致：</p>
<pre><code>def add(x,y):
    result = x + y
    return result

print(add(10,24))
</code></pre>
<h3 id="yeild-语句"><a href="#yeild-语句" class="headerlink" title="yeild 语句"></a>yeild 语句</h3><p>yeild 语句等同于yeild表达式，使用了yield 表达式的函数被称为生成器（generator）</p>
<h3 id="assert-语句"><a href="#assert-语句" class="headerlink" title="assert 语句"></a>assert 语句</h3><p>当表达式为False时则触发AssertionError异常，代码终止</p>
<pre><code>def testAssert(num):
  if num&gt;0:
    print(&quot;输入大于0，正常执行&quot;)
  else:
    print(&quot;输入小于0！&quot;)
    assert False ,&#39;Not positive integer&#39;
try:
  n=input(&quot;请输入正整数：&quot;) 
  testAssert(int(n))

except Exception as ex:
    print(&quot;发现错误:&quot;,ex)
</code></pre>
<p>执行<code>python main.py</code>,输入10：</p>
<pre><code>  输入大于0，正常执行
</code></pre>
<p>执行<code>python main.py</code>,输入-10：</p>
<pre><code>  输入小于0！
  发现错误: Not positive integer
</code></pre>
<h3 id="raise语句"><a href="#raise语句" class="headerlink" title="raise语句"></a>raise语句</h3><p>raise语句是抛出一个异常，即使程序没有任何问题:</p>
<pre><code>print(&#39;run&#39;)

raise RuntimeError(&quot;没事找事，怎么了&quot;)
</code></pre>
<p>执行结果：</p>
<pre><code>run
Traceback (most recent call last):
  File &quot;main.py&quot;, line 188, in &lt;module&gt;
    raise RuntimeError(&quot;没事找事，怎么了&quot;)
RuntimeError: 没事找事，怎么了
</code></pre>
<h3 id="global语句"><a href="#global语句" class="headerlink" title="global语句"></a>global语句</h3><p>global 语句是作用于整个当前代码块的声明。 它意味着所列出的标识符将被解读为全局变量</p>
<pre><code>x=1
y=0

def foo():
  x=2

def fun():
  global y  # 声明为全局变量
  y=2

foo()
fun()

print(x)   # 1
print(y)   # 3
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.runoob.com/python3/python3-conditional-statements.html">Python3 条件控制</a></li>
<li><a href="https://www.runoob.com/python3/python3-loop.html">Python3 循环语句</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Python系列-4-函数</title>
    <url>/Python%E7%B3%BB%E5%88%97-4-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>函数能提高应用的模块性，和代码的重复利用率。Python提供了许多内建函数，比如print()。但我们也可以自己创建函数:</p>
<ol>
<li><code>def</code> 关键字来开头</li>
<li>括号中间为函数参数</li>
<li>函数第一行可以选择性的使用字符串作为函数说明</li>
<li>函数内容以冒号（:）开始</li>
<li>return 表示函数结束，无返回内容默认返回None</li>
</ol>
<span id="more"></span>

<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>Python 定义函数使用 def 关键字，一般格式如下：</p>
<pre><code>def 函数名（参数列表）:
    函数体
</code></pre>
<p>Python是一种对缩进非常敏感的语言，对代码格式要求非常严格的，这块在函数体中可以更直白的看出来，举个例子：</p>
<pre><code>def fn1(num):
    &quot;将传入的数字转为正整数，包含0&quot;
    if num&lt;0:
      return abs(num)
    return num
print(fn1(10))
print(fn1(-10))
print(fn1(0))
</code></pre>
<p>运行结果：</p>
<pre><code>10
10
0
</code></pre>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="可更改-mutable-与不可更改-immutable-对象"><a href="#可更改-mutable-与不可更改-immutable-对象" class="headerlink" title="可更改(mutable)与不可更改(immutable)对象"></a>可更改(mutable)与不可更改(immutable)对象</h3><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。所谓不可更改对象是指，变量只是一个对象的引用（指针），如：</p>
<pre><code>a = &quot;Hello&quot;
a = [1,2,3]
</code></pre>
<p>a的重新赋值，并不会修改之前引用对象的值，而是重新创建了一个对象，把a又指向了这个对象。</p>
<pre><code>def change(a):
  a = 100

b=20
change(b)
print(b) # b的值并没有被修改
</code></pre>
<p>但对于列表与字典，则会修改原始数据：</p>
<pre><code>  def change(a):
    a.reverse()

  b=[1,2,3,4]
  change(b)
  print(b) # [4,3,2,1]
  
</code></pre>
<h3 id="必需参数"><a href="#必需参数" class="headerlink" title="必需参数"></a>必需参数</h3><p>必须参数就是函数运行时必须的参数，否则会报错，如上change方法，如果直接运行就会报错。</p>
<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>正常情况下，函数参数是按顺序解析的，但使用关键字参数允许函数调用时参数的顺序与声明时不一致：</p>
<pre><code>def printinfo( name, age ):
  print (&quot;名字: &quot;, name)
  print (&quot;年龄: &quot;, age)
  return

printinfo(age=50,name=&#39;Tom&#39;)
</code></pre>
<p>运行结果：</p>
<pre><code>名字:  Tom
年龄:  50
</code></pre>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>这点与ES6语法类似，可以为函数指定默认参数</p>
<pre><code>def printinfo( name, age=20 ):
  print (&quot;名字: &quot;, name)
  print (&quot;年龄: &quot;, age)
  return

printinfo(&#39;Tom&#39;)
</code></pre>
<p>运行结果：</p>
<pre><code>名字:  Tom
年龄:  20
</code></pre>
<h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><p>某些情况下不确定函数的参数个数，这个时候就需要不定长参数出场了，加了星号 <code>* </code>的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数:</p>
<pre><code>def printinfo( arg1, *vartuple ):
</code></pre>
<p>举个例子：</p>
<pre><code>def printinfo( arg1, *vartuple ):
  &quot;打印任何传入的参数&quot;
  print (&quot;输出: &quot;)
  print (arg1)
  print (vartuple)
  
printinfo(1,2,3,4,5)
</code></pre>
<p>运行结果：</p>
<pre><code>1
(2, 3, 4, 5)
</code></pre>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>python 使用 lambda 来创建匿名函数。</p>
<p>lambda 函数的语法只包含一个语句，如下：</p>
<pre><code>lambda [arg1 [,arg2,.....argn]]:expression
</code></pre>
<p>举个例子：</p>
<pre><code>sum = lambda ag1, ag2 : ag1 + ag2

print(sum(1,10))
</code></pre>
<p>运行结果为：11。可以看到lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</p>
<h2 id="Python内置函数"><a href="#Python内置函数" class="headerlink" title="Python内置函数"></a>Python内置函数</h2><h3 id="数学运算类"><a href="#数学运算类" class="headerlink" title="数学运算类"></a>数学运算类</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>abs(a)</td>
<td>求取绝对值</td>
<td>abs(-1)</td>
</tr>
<tr>
<td>max(list)</td>
<td>求取list最大值</td>
<td>max([1,2,3])</td>
</tr>
<tr>
<td>min(list)</td>
<td>求取list最小值</td>
<td>min([1,2,3])</td>
</tr>
<tr>
<td>sum(list)</td>
<td>求取list元素的和</td>
<td>sum([1,2,3]) &gt;&gt;&gt; 6</td>
</tr>
<tr>
<td>sorted(list)</td>
<td>排序</td>
<td>返回排序后的list。</td>
</tr>
<tr>
<td>len(list)</td>
<td>list长度</td>
<td>len([1,2,3])</td>
</tr>
<tr>
<td>divmod(a,b)</td>
<td>获取商和余数。</td>
<td>divmod(5,2) &gt;&gt;&gt; (2,1)</td>
</tr>
<tr>
<td>pow(a,b)</td>
<td>获取乘方数。</td>
<td>pow(2,3) &gt;&gt;&gt; 8</td>
</tr>
<tr>
<td>round(a,b)</td>
<td>获取指定位数的小数。a代表浮点数，b代表要保留的位数。</td>
<td>round(3.1415926,2) &gt;&gt;&gt; 3.14</td>
</tr>
<tr>
<td>range(a[,b])</td>
<td>生成一个a到b的数组,左闭右开。</td>
<td>range(1,10) &gt;&gt;&gt; [1,2,3,4,5,6,7,8,9]</td>
</tr>
</tbody></table>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>int(str)</td>
<td>转换为int型</td>
<td><code>int(&#39;1&#39;) &gt;&gt;&gt; 1</code></td>
</tr>
<tr>
<td>float(int/str) :</td>
<td>将int型或字符型转换为浮点型</td>
<td><code>float(&#39;1&#39;) &gt;&gt;&gt; 1.0</code></td>
</tr>
<tr>
<td>str(int)</td>
<td>转换为字符型</td>
<td><code>str(1) &gt;&gt;&gt; &#39;1&#39;</code></td>
</tr>
<tr>
<td>bool(int)</td>
<td>转换为布尔类型</td>
<td><code>str(0) &gt;&gt;&gt; False str(None) &gt;&gt;&gt; False</code></td>
</tr>
<tr>
<td>bytes(str,code)</td>
<td>接收一个字符串，与所要编码的格式，返回一个字节流类型</td>
<td><code>bytes(&#39;abc&#39;, &#39;utf-8&#39;) &gt;&gt;&gt; b&#39;abc&#39; bytes(u&#39;爬虫&#39;, &#39;utf-8&#39;) &gt;&gt;&gt; b&#39;\xe7\x88\xac\xe8\x99\xab&#39;</code></td>
</tr>
<tr>
<td>list(iterable)</td>
<td>转换为list</td>
<td><code>list((1,2,3)) &gt;&gt;&gt; [1,2,3]</code></td>
</tr>
<tr>
<td>dict(iterable)</td>
<td>转换为dict</td>
<td><code>dict([(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]) &gt;&gt;&gt; &#123;&#39;a&#39;:1, &#39;b&#39;:2, &#39;c&#39;:3&#125;</code></td>
</tr>
<tr>
<td>enumerate(iterable)</td>
<td>返回一个枚举对象。</td>
<td>略</td>
</tr>
<tr>
<td>tuple(iterable)</td>
<td>转换为tuple</td>
<td><code>tuple([1,2,3]) &gt;&gt;&gt;(1,2,3)</code></td>
</tr>
<tr>
<td>set(iterable)</td>
<td>转换为set</td>
<td><code>set([1,4,2,4,3,5]) &gt;&gt;&gt; &#123;1,2,3,4,5&#125; set(&#123;1:&#39;a&#39;,2:&#39;b&#39;,3:&#39;c&#39;&#125;) &gt;&gt;&gt; &#123;1,2,3&#125;</code></td>
</tr>
<tr>
<td>hex(int)</td>
<td>转换为16进制</td>
<td><code>hex(1024) &gt;&gt;&gt; &#39;0x400&#39;</code></td>
</tr>
<tr>
<td>oct(int)</td>
<td>转换为8进制</td>
<td><code>oct(1024) &gt;&gt;&gt; &#39;0o2000&#39;</code></td>
</tr>
<tr>
<td>bin(int)</td>
<td>转换为2进制</td>
<td><code>bin(1024) &gt;&gt;&gt; &#39;0b10000000000&#39;</code></td>
</tr>
<tr>
<td>chr(int)</td>
<td>转换数字为相应ASCI码字符</td>
<td><code>chr(65) &gt;&gt;&gt; &#39;A&#39;</code></td>
</tr>
<tr>
<td>ord(str)</td>
<td>转换ASCI字符为相应的数字</td>
<td><code>ord(&#39;A&#39;) &gt;&gt;&gt; 65</code></td>
</tr>
</tbody></table>
<h3 id="功能相关"><a href="#功能相关" class="headerlink" title="功能相关"></a>功能相关</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>eval()</td>
<td>执行一个表达式，或字符串作为运算</td>
<td><code>eval(&#39;1+1&#39;) &gt;&gt;&gt; 2</code></td>
</tr>
<tr>
<td>exec()</td>
<td>执行python语句</td>
<td><code>exec(&#39;print(&quot;Python&quot;)&#39;) &gt;&gt;&gt; Python</code></td>
</tr>
<tr>
<td>filter(func, iterable)</td>
<td>通过判断函数fun，筛选符合条件的元素</td>
<td><code>filter(lambda x: x&gt;3, [1,2,3,4,5,6]) &gt;&gt;&gt; &lt;filter object at 0x0000000003813828&gt;</code></td>
</tr>
<tr>
<td>map(func, *iterable)</td>
<td>将func用于每个iterable对象</td>
<td><code>map(lambda a,b: a+b, [1,2,3,4], [5,6,7]) &gt;&gt;&gt; [6,8,10]</code></td>
</tr>
<tr>
<td>zip(*iterable)</td>
<td>将iterable分组合并。返回一个zip对象</td>
<td><code>list(zip([1,2,3],[4,5,6])) &gt;&gt;&gt; [(1, 4), (2, 5), (3, 6)]</code></td>
</tr>
<tr>
<td>type()</td>
<td>返回一个对象的类型。</td>
<td>略</td>
</tr>
<tr>
<td>id()</td>
<td>返回一个对象的唯一标识值。</td>
<td>略</td>
</tr>
<tr>
<td>hash(object)</td>
<td>返回一个对象的hash值，具有相同值的object具有相同的hash值</td>
<td><code> hash(&#39;python&#39;) &gt;&gt;&gt; 7070808359261009780</code></td>
</tr>
<tr>
<td>help()</td>
<td>调用系统内置的帮助系统。</td>
<td>略</td>
</tr>
<tr>
<td>isinstance()</td>
<td>判断一个对象是否为该类的一个实例。</td>
<td>略</td>
</tr>
<tr>
<td>issubclass()</td>
<td>判断一个类是否为另一个类的子类。</td>
<td>略</td>
</tr>
<tr>
<td>globals()</td>
<td>返回当前全局变量的字典。</td>
<td>略</td>
</tr>
<tr>
<td>reversed(sequence)</td>
<td>生成一个反转序列的迭代器</td>
<td><code>reversed(&#39;abc&#39;) &gt;&gt;&gt; [&#39;c&#39;,&#39;b&#39;,&#39;a&#39;]</code></td>
</tr>
</tbody></table>
<h3 id="迭代器-生成器函数"><a href="#迭代器-生成器函数" class="headerlink" title="迭代器/生成器函数"></a>迭代器/生成器函数</h3><p>迭代是Python最强大的功能之一，是访问集合元素的一种方式。字符串，列表，元组，集合，字典对象都可用于创建迭代器:</p>
<pre><code>str=&quot;0987&quot;
list =  [1,2,&#39;3&#39;] 
tup = (10, 20, &#39;30&#39;)
sites = &#123;&#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;y&#39;&#125;
dict = &#123;&#39;name&#39;:&#39;jack&#39;,&#39;age&#39;:12&#125;

it0 = iter(str)
it1 = iter(list)
it2 = iter(tup)
it3 = iter(sites)
it4 = iter(dict)

print(it0)
print(it1)
print(it2)
print(it3)
print(it4)
</code></pre>
<p>执行结果：</p>
<pre><code>&lt;str_iterator object at 0x000001C8430F7DC8&gt;
&lt;list_iterator object at 0x000001C8430F7E08&gt;
&lt;tuple_iterator object at 0x000001C8430F7E48&gt;
&lt;set_iterator object at 0x000001C8430D1A98&gt;
&lt;dict_keyiterator object at 0x000001C8430D1B88&gt;
</code></pre>
<p>迭代就是从迭代器中取元素的过程。比如我们用for循环从列表[1,2,3]中取元素，这种遍历过程就被称作迭代。上述数据类型通过iter函数转成迭代对象（ps:字符串，列表，元组，集合，字典本身都是支持for循环的，因为这些数据结构已经内置了iter函数），此时我们除了for循环外，还可以使用next函数进行迭代：</p>
<pre><code>import sys         # 引入 sys 模块

list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象

while True:
    try:
        print (next(it))
    except StopIteration:
        sys.exit()
</code></pre>
<p>运行结果：</p>
<pre><code>  1
  2
  3
  4
</code></pre>
<p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器:</p>
<pre><code>  def generate():
      yield 1
      yield [1,2,3]
      yield &#39;over&#39;

  p = generate()
  print(p)
</code></pre>
<p>执行结果：</p>
<pre><code>&lt;generator object generate at 0x0000013C5A583648&gt;
</code></pre>
<p><strong>它支持for循环</strong></p>
<pre><code>for x in p:
  print(x, end=&#39; &#39;)
</code></pre>
<p>运行结果：</p>
<pre><code>1 [1, 2, 3] over
</code></pre>
<p><strong>也支持next方法</strong></p>
<pre><code>while True:
    try:
        print (next(p))
    except StopIteration:
        sys.exit()
</code></pre>
<p>运行结果：</p>
<pre><code>  1
  [1, 2, 3]
  over
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/yangxiaoyan12/article/details/87566833">python 常见的内置函数</a></li>
<li><a href="https://www.runoob.com/python3/python3-function.html">Python3 函数</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Python系列-5-模块</title>
    <url>/Python%E7%B3%BB%E5%88%97-5-%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>关于模块的概念，都已有了概念，本章我们学习下python的模块, 看看它的模块化怎么玩儿。</p>
<span id="more"></span>

<h2 id="python中的模块"><a href="#python中的模块" class="headerlink" title="python中的模块"></a>python中的模块</h2><p>在Python中模块分为以下几种：</p>
<ul>
<li>系统内置模块，例如：sys、time、json模块等等；</li>
<li>自定义模块，自定义模块是自己写的模块，对某段逻辑或某些函数进行封装后供其他函数调用。注意：自定义模块的命名一定不能和系统内置的模块重名了，否则将不能再导入系统的内置模块了。例如：自定义了一个sys.py模块后，再想使用系统的sys模块是不能使用的；</li>
<li>第三方的开源模块：这部分模块可以通过pip install进行安装，有开源的代码。pip 类似node中的npm。 pip 默认源为<code>https://pypi.org</code>，使用时可以设置国内镜像源 <code>pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code>进行加速。PS: python3 使用 pip3</li>
</ul>
<h2 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h2><p>我们先看下如何定义一个模块，不同于nodejs，py中不需要特定的语法。模块内部的作用域是在模块内，如果两个不同的模块如果需要共享变量，只需要通过引入对应变量即可。我们先定义一个模块<code>hello.py</code>:</p>
<pre><code>#!/usr/bin/env python3
# -*- coding=utf-8 -*-

listdata=[1,2,3]

def sayHi(name):
  print(&quot;Hello,&quot;+name)
  listdata.append(name)

def foo(name):
  print(&quot;Hi! &quot;+ name + &quot;,I am foo&quot;)
</code></pre>
<p>这样，就定义好了一个模块，我们接下来看如何引用模块</p>
<h2 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h2><p>Python中引入模块的方式有以下几种:</p>
<h3 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h3><pre><code>import module1[, module2[,... moduleN]
</code></pre>
<p>对于hello.py模块：</p>
<pre><code>import hello

hello.sayHi(&#39;main&#39;) 
print(hello.listdata)
</code></pre>
<p>我们可以通过模块名称访问模块内部所有的变量与函数。</p>
<h3 id="from-import-语句"><a href="#from-import-语句" class="headerlink" title="from .. import 语句"></a>from .. import 语句</h3><p> from 语句让你从模块中导入一个指定的部分到当前命名空间中：</p>
<pre><code>from modname import name1[, name2[, ... nameN]]
</code></pre>
<p>对于hello.py模块：</p>
<pre><code>from hello import listdata, sayHi

sayHi(&#39;main&#39;) 
print(listdata)
</code></pre>
<p>即可引入变量listdata 与 函数sayHi，可以直接调用，无须再加模块名称。</p>
<p>导入时也支持别名</p>
<pre><code>from modname import name as otherName
</code></pre>
<p>对于hello.py模块：</p>
<pre><code>from hello import sayHi as sayHello, listdata as listArr

sayHello(&#39;Tom&#39;)
print(listArr)
</code></pre>
<h3 id="from-import"><a href="#from-import" class="headerlink" title="from .. import *"></a>from .. import *</h3><p>如果需要将模块中所有内容全部导入到当前命名空间中，需要使用：</p>
<pre><code>from modname import *
</code></pre>
<p>对于hello.py模块：</p>
<pre><code>from hello import *

sayHi(&#39;Tom&#39;)
print(listdata)
</code></pre>
<p>但是尽量避免这种引用方式，这样会将引用模块中所有的变量及函数引入到当前模块内，极大概率的会污染当前命名空间。</p>
<ul>
<li><code>import *</code> 无法导入以下划线开头的变量名</li>
<li>如果定义了<code>__all__</code>, <code>import *</code> 只会导入__all__中指定的变量，无论是否以下划线开头</li>
</ul>
<p>推荐直接使用 import， 语法简单且基本不会造成命名冲突</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>上面提到模块内部的作用域是在模块内，如果模块之前共享数据的话只需要引入对应变量即可：</p>
<pre><code>import hello

# 执行sayHi函数
hello.sayHi(&#39;Tom&#39;)

# 修改listdata
hello.listdata.append(&quot;main&quot;)

print(hello.listdata)
</code></pre>
<p>  运行结果：</p>
<pre><code> hello Tom
 [1, 2, 3, &#39;Tom&#39;, &#39;main&#39;]
</code></pre>
<p>可以看到 listdata 数据在hello.py模块中增加一条数据<code>Tom</code>,在当前模块内又被追加上数据<code>main</code>，相当于两个模块“共享”了这个数据。当然这种方式在nodejs中与ES6中都是通用的。</p>
<p>在python中没有类似public,private等关键词来修饰成员函数和成员变量,那怎么才能将函数或变量作为作为非公开的（private）？</p>
<h3 id="非类定义"><a href="#非类定义" class="headerlink" title="非类定义"></a>非类定义</h3><p>很多博客跟文档反复提到’_’开头的命名，但对于非类成员的定义，下划线开头的命名方式只对于<code>import *</code> 有效（上面有提到），其他引入方式仍是可以正常访问的，这个只能作为规范，只是“不建议”直接引用，而不是“不能”直接引用。</p>
<h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3><p>对于类成员的定义</p>
<p>我们定义一个类，放在hi.py中</p>
<pre><code>class Hi(object):
  def __init__(self):
      self.__list=[1,2,3]
      self.list=[-1,-2]

  def add(self,name):
      self.__list.append(name)
      self.list.append(name)
      print(&quot;Hello,&quot;+name)
      print(self.__list)
</code></pre>
<p>然后我们在main.py中执行</p>
<pre><code>    from hello import Hi

    p = Hi()

    p.add(&quot;Tom&quot;)

    print(p.list)
</code></pre>
<p>运行结果为：</p>
<pre><code>  Hello,Tom
  [1, 2, 3, &#39;Tom&#39;]
  [-1, -2, &#39;Tom&#39;]
</code></pre>
<p>如果我们再打印下内部<code>__list</code>属性：</p>
<pre><code>   print(p.__list)   
</code></pre>
<p>此时就会报错：</p>
<pre><code>  Traceback (most recent call last):
    File &quot;main.py&quot;, line 19, in &lt;module&gt;
      print(p.__list)
  AttributeError: &#39;Hi&#39; object has no attribute &#39;__list&#39;
</code></pre>
<h2 id="导入模块的搜索路径"><a href="#导入模块的搜索路径" class="headerlink" title="导入模块的搜索路径"></a>导入模块的搜索路径</h2><p>用import hello时，python会搜寻hello.py文件，搜索顺序如下: </p>
<ul>
<li>首先搜寻内置模块是否有hello（所以我们定义的模块名不要和内置模块相同）</li>
<li>如果内置模块没有，则看下面这些目录里有没有(以下结果通过内置<code>sys</code>模块的<code>sys.path</code>属性获取):<pre><code>  [&#39;F:\\python-demo&#39;,
   &#39;C:\\Users\\wmh\\AppData\\Local\\Programs\\Python\\Python37\\python37.zip&#39;, 
   &#39;C:\\Users\\wmh\\AppData\\Local\\Programs\\Python\\Python37\\DLLs&#39;, 
   &#39;C:\\Users\\wmh\\AppData\\Local\\Programs\\Python\\Python37\\lib&#39;, 
   &#39;C:\\Users\\wmh\\AppData\\Local\\Programs\\Python\\Python37&#39;, 
   &#39;C:\\Users\\wmh\\AppData\\Roaming\\Python\\Python37\\site-packages&#39;, 
   &#39;C:\\Users\\wmh\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages&#39;]
</code></pre>
</li>
</ul>
<p>执行导入模块命令时，会首先检查待导入的模块是否在当前已有模块之中，如果有则跳过import。因此模块之间相互引用不会导致无限循环</p>
<h2 id="相对引用与绝对引用"><a href="#相对引用与绝对引用" class="headerlink" title="相对引用与绝对引用"></a>相对引用与绝对引用</h2><p>python中的import分为绝对引用和相对引用两种。绝对引用就是上面我们采用的引用方式，对与相对引用，在nodejs中也经常遇到，不同的是：Python中只采用<code>.</code>来拼接</p>
<p>对于如下结构：</p>
<pre><code>    home
    ├─── hello.py
</code></pre>
<p>我们可以这样引用</p>
<pre><code>    from home.hello import Hi
</code></pre>
<p><code>.</code>只能放在from后，不能放import后，更多用法请参考：<a href="https://zhuanlan.zhihu.com/p/33913131">python模块详解</a></p>
<h2 id="if-name-39-main-39"><a href="#if-name-39-main-39" class="headerlink" title="if __name__ == &#39;__main__&#39;"></a><code>if __name__ == &#39;__main__&#39;</code></h2><p>经常会在别人的代码中发现<code>if __name__ == &#39;__main__&#39;</code>, 我们接着上面的例子，执行如下代码：</p>
<pre><code>import hello 

print(__name__)
print(hello.__name__)
</code></pre>
<p>运行结果：</p>
<pre><code>__main__
hello
</code></pre>
<p>其实，<code>if __name__ == &#39;__main__&#39;</code>的含义就是：该模块直接执行时运行的代码，如果被引用时则不执行；这算是一种约定俗成的写法。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://baijiahao.baidu.com/s?id=1608487972546304614&wfr=spider&for=pc">python中的模块详解</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017455068170048">廖雪峰-Python教程</a></li>
<li><a href="https://www.runoob.com/python3/python3-module.html">菜鸟教程-Python3 模块</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33913131">python模块详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/146993325">NodeJs与python的使用对比</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Python系列-6-面向对象</title>
    <url>/Python%E7%B3%BB%E5%88%97-6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>上一篇中已经提到了Python中的类，这里我们再详细介绍下</p>
<span id="more"></span>

<h2 id="类的写法"><a href="#类的写法" class="headerlink" title="类的写法"></a>类的写法</h2><p>类是用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</p>
<pre><code>class People:
    
    # 静态字段
    #定义基本属性
    name = &#39;&#39;
    age = 0
    # 定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0

    #定义构造方法
    def __init__(self,n,a,w):

        # 普通字段
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))

# 实例化类
p = People(&#39;Tom&#39;,10,30)
p.speak()
# 直接访问静态字段 不可修改
print(People.age)
# 直接访问普通字段
print(p.age)
</code></pre>
<p> 运行结果：</p>
<pre><code>Tom 说: 我 10 岁。
0
10
</code></pre>
<ul>
<li>普通字段属于对象，静态字段属于类，如果每个对象都具有相同的字段，那么就使用静态字段（因为静态字段在内存中只保存一份）</li>
<li>类内部有一个特殊方法（构造方法）： <code>__init__</code> 方法，在实例化操作时候会被自动调用。</li>
<li>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例(self不是关键字，所以也可以换成其他的，如my)</li>
</ul>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>Python 同样支持类的继承，定义一个Man类且继承上面的People类:</p>
<pre><code>class Man(People):
    sex = &#39;man&#39;
    def __init__(self,n,a,w,g):
        #调用父类的构函
        People.__init__(self,n,a,w)
        self.job = g
    #覆写父类的方法
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我是一名 %s &quot;%(self.name,self.age,self.job))
m = Man(&quot;Jack&quot;,20,50,&#39;student&#39;)
m.speak()
print(Man.sex)
</code></pre>
<p>运行结果：</p>
<pre><code>Jack 说: 我 20 岁了，我是一名 student
man
</code></pre>
<p>并且，Python还支持多个类的继承，需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法：</p>
<p>新定义一个Speaker类：</p>
<pre><code>class Speaker:
    topic = &#39;&#39;
    name = &#39;Jam&#39;
    def __init__(self,n,t):
        self.name = n
        self.topic = t
    def speak(self):
        print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic))
</code></pre>
<p>再定义一个Man类继承Speaker和People：</p>
<pre><code>class Man(Speaker,People):
    sex = &#39;man&#39;
    def __init__(self,n,a,w,g):
        #调用父类的构函
        People.__init__(self,n,a,w)
        Speaker.__init__(self,n,a)
        self.job = g

m = Man(&quot;Jack&quot;,20,50,&#39;student&#39;)
m.speak()
print(Man.name)
</code></pre>
<p>执行结果：</p>
<pre><code>我叫 Jack，我是一个演说家，我演讲的主题是 20
Jam
</code></pre>
<p>可以看到，多重继承时，是从左到右查找父类的。</p>
<p>继承过程中，子类的方法会重写父类的方法，如果需要调用父类方法，此时可以使用<code>super()</code>: 该函数是用于调用父类(超类)的一个方法：</p>
<pre><code>class Man(People):
    sex = &#39;man&#39;
    def __init__(self,n,a,w,g):
        #调用父类的构函
        People.__init__(self,n,a,w)
        self.job = g
    #覆写父类的方法
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我是一名 %s &quot;%(self.name,self.age,self.job))
m = Man(&quot;Jack&quot;,20,50,&#39;student&#39;)
m.speak()
print(Man.sex)
super(Man,m).speak()
super(Man,m).speak()
</code></pre>
<p>运行结果：</p>
<pre><code>Jack 说: 我 20 岁了，我是一名 student
man
Jack 说: 我 20 岁。
</code></pre>
<p>ES6中也有super关键字，也是用在继承过程中，不过二者用法相差较大，有兴趣可以查看：<a href="https://es6.ruanyifeng.com/#docs/class-extends#super-%E5%85%B3%E9%94%AE%E5%AD%97">ECMAScript 6 入门-super关键字</a></p>
<p>最后，Python中<strong>没有多态</strong>的概念。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/34781040">Python 面向对象（进阶篇）</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Python系列-7-输入输出</title>
    <url>/Python%E7%B3%BB%E5%88%97-7-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文我们学习下输入输出函数，之前多次用到的print就是输出函数，可以再控制台打印数据，类似nodejs的console.log。但是Python的输出函数更强大。还有输入函数input 与 File对象的一些方法</p>
<span id="more"></span>
<h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><p>使用input([prompt])读取一行，将其转换为string类型并返回：</p>
<pre><code>name = input(&quot;Enter you name: &quot;)
print(f&quot;Hi &#123;name&#125;&quot;)
</code></pre>
<p>运行后会进入一个交互式命令行：</p>
<p><img src="1.png"></p>
<h2 id="print"><a href="#print" class="headerlink" title="print"></a>print</h2><p>print的原型如下：</p>
<pre><code>print(*objects, sep=&#39; &#39;, end=&#39;\n&#39;, file=sys.stdout, flush=False)
</code></pre>
<ul>
<li>*objects:要在控制台输出的数据，可以是多个，用,逗号隔开</li>
<li>第二个是数据之前的分隔符</li>
<li>第三个是加在输出的末尾的</li>
</ul>
<p>一般我们使用的只有前3个参数。</p>
<pre><code>print(1,2,&quot;6&quot;)                      # 1 2 6

print(1,2,&quot;6&quot;,sep=&quot;&amp;&quot;,end=&quot;--&quot;)     # 1&amp;2&amp;6--
</code></pre>
<p><strong>格式化输出，format</strong><br>和C语言一样，我们可以使用占位符<code>%?</code>，其中<code>?</code>代表不同的字符，例如<code>%s</code>代表字符串，<code>%d</code>代表十进制整数，<code>%f</code>代表浮点</p>
<pre><code>  name=&quot;Jack&quot;
  age = 25
  print(&quot;你好%s，你的年龄是%d&quot; %(name,age))  # 你好Jack，你的年龄是25
</code></pre>
<p>字符串后的<code>%</code>用来说明是哪些变量要替换前面的占位符，当只有一个变量的时候，可以省略括号</p>
<p><strong>格式化输出，占位符</strong><br>利用string对象的format方法，进行格式化:</p>
<pre><code>print(&quot;你好&#123;0&#125;，你的余额是&#123;1:.2f&#125;&quot;.format(&quot;Potato&quot;,3.1))   #  你好Potato，你的余额是3.10
</code></pre>
<p><code>&#123;0&#125;</code>代表占位符和format里的参数对应，<code>&#123;1:.2f&#125;</code>，冒号后是格式控制，代表保留两位小数</p>
<p>这样用起来不太方便，也可以改成：</p>
<pre><code>m=(format(3.1415,&quot;.2f&quot;))

print(&quot;你好&#123;0&#125;，你的余额是&#123;1&#125;&quot;.format(&quot;Potato&quot;,m))    #  你好Potato，你的余额是3.14
</code></pre>
<h2 id="File对象"><a href="#File对象" class="headerlink" title="File对象"></a>File对象</h2><p>Python <code>open()</code> 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，则会抛出错误。</p>
<p><code>open()</code> 函数常用形式是接收两个参数：文件名(file)和模式(mode)。</p>
<pre><code>open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
</code></pre>
<p>使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法:</p>
<pre><code>try:
  f = open(&#39;o.txt&#39;, &#39;r&#39;)
  print(f.read())
finally:
  if f:
    f.close()

# 使用with语句简化书写过程
with open(&quot;i.txt&quot;,&#39;w+&#39;) as f:
  f.write(&quot;Hi! I am writing&quot;)
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://segmentfault.com/a/1190000018081959">Python中的基本输入、输出、格式化输出</a></li>
<li><a href="https://www.runoob.com/python/att-string-format.html">Python format 格式化函数</a></li>
<li><a href="https://blog.csdn.net/xinyuski/article/details/88865162">Python中打开文件的方式（With open）</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Python系列-8-常用标准库</title>
    <url>/Python%E7%B3%BB%E5%88%97-8-%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Python提供了一个强大的标准库，内置了许多非常有用的模块，可以直接使用（标准库是随Python一起安装的）， 日常应用比较广泛的模块是：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>re</td>
<td>正则表达式操作</td>
</tr>
<tr>
<td>datetime / time</td>
<td>为日期和时间处理同时提供了简单和复杂的方法。</td>
</tr>
<tr>
<td>random</td>
<td>提供了生成随机数的工具。</td>
</tr>
<tr>
<td>math</td>
<td>为浮点运算提供了对底层C函数库的访问。</td>
</tr>
<tr>
<td>zlib</td>
<td>直接支持通用的数据打包和压缩格式：zlib，gzip，bz2，zipfile，以及 tarfile。</td>
</tr>
<tr>
<td>pathlib / os.path</td>
<td>文件和目录操作访问</td>
</tr>
<tr>
<td>sys</td>
<td>工具脚本经常调用命令行参数。这些命令行参数以链表形式存储于 sys 模块的 argv 变量。</td>
</tr>
<tr>
<td>glob</td>
<td>提供了一个函数用于从目录通配符搜索中生成文件列表。</td>
</tr>
<tr>
<td>os</td>
<td>提供了不少与操作系统相关联的函数。</td>
</tr>
<tr>
<td>argparse</td>
<td>命令行选项、参数和子命令解析器</td>
</tr>
<tr>
<td>base64 /json/urllib</td>
<td>Internet相关数据处理</td>
</tr>
<tr>
<td>html / xml</td>
<td>结构化标记处理工具</td>
</tr>
<tr>
<td>threading / queue</td>
<td>多线程相关</td>
</tr>
</tbody></table>
<span id="more"></span>
<h2 id="常用标准库示例"><a href="#常用标准库示例" class="headerlink" title="常用标准库示例"></a>常用标准库示例</h2><h3 id="re"><a href="#re" class="headerlink" title="re"></a>re</h3><pre><code>  import re

  p = re.compile(r&#39;(\d+)&#39;)
  print(p.match(&#39;123abc&#39;).groups())    # (&#39;123&#39;,)
  print(p.search(&#39;abc&#39;))               # None
</code></pre>
<h3 id="datatime-time"><a href="#datatime-time" class="headerlink" title="datatime / time"></a>datatime / time</h3><p>注意Python的timestamp是一个浮点数，整数位表示秒, 而nodejs是以整数来表示的</p>
<pre><code>  import time 
  print (time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()))  #  获取当前时间：2020-10-14 14:16:31

  import datetime
  now = datetime.datetime.now() # 获取当前datetime
  print(now)              # 当前时间  2020-10-14 14:22:21.735610
  print(now.timestamp())  # 时间戳 浮点型  1602656541.73561
</code></pre>
<h3 id="math-amp-amp-random"><a href="#math-amp-amp-random" class="headerlink" title="math &amp;&amp; random"></a>math &amp;&amp; random</h3><pre><code>import math
import random

rand = random.randrange(10)   # 获取0-10内的随机数
print(rand)                   # 6
print(math.pow(2,rand))       # 计算2的n次方 64
</code></pre>
<h3 id="sys-amp-amp-os"><a href="#sys-amp-amp-os" class="headerlink" title="sys &amp;&amp; os"></a>sys &amp;&amp; os</h3><pre><code>import os
print(os.getcwd())  # 获取当前运行目录 F:\python-demo

import sys
print(sys.argv)    # 获取命令行参数 [&#39;main.py&#39;]
</code></pre>
<h3 id="argparse"><a href="#argparse" class="headerlink" title="argparse"></a>argparse</h3><pre><code>import argparse

def main():
    parser = argparse.ArgumentParser(description=&quot;Demo of argparse&quot;)
    parser.add_argument(&#39;-n&#39;,&#39;--name&#39;, default=&#39; Li &#39;)
    parser.add_argument(&#39;-y&#39;,&#39;--year&#39;, default=&#39;20&#39;)
    parser.add_argument(&#39;-s&#39;,&#39;--sex&#39;, default=&#39;man&#39;)
    args = parser.parse_args()
    print(args)
    name = args.name
    year = args.year
    sex = args.sex
    print(&#39;Hello &#123;&#125; &#123;&#125; &#123;&#125;&#39;.format(name,year,sex))

if __name__ == &#39;__main__&#39;:
  main()
</code></pre>
<p>执行<code>python main.py -n Tom --year 40</code></p>
<pre><code>Namespace(name=&#39;Tom&#39;, sex=&#39;man&#39;, year=&#39;40&#39;)
Hello Tom 40 man
</code></pre>
<p> <code>-n</code>,<code>--name</code>表示同一个参数，default参数表示在运行命令时的缺省参数</p>
<h3 id="glob"><a href="#glob" class="headerlink" title="glob"></a>glob</h3><p>该模块可根据 Unix 终端所用规则找出所有匹配特定模式的路径名</p>
<pre><code>import glob

print(glob.glob(&#39;*.py&#39;))  # 找出当前目录下的所有的py文件（不含子目录） [&#39;hello.py&#39;, &#39;index.py&#39;, &#39;io.py&#39;, &#39;main.py&#39;, &#39;main2.py&#39;]
</code></pre>
<h3 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h3><p>此模块为需要数据压缩的程序提供了一系列函数，且与gzip兼容</p>
<pre><code>import zlib

s = b&#39;witch which has which witches wrist watch&#39;
print(len(s))                # 41

t = zlib.compress(s)    
print(t)                     # b&#39;x\x9c+\xcf,I\xceP(\xcf\xc8\x04\x92\x19\x89\xc5PV9H4\x15\xc8+\xca,.Q(O\x04\xf2\x00D?\x0f\x89&#39;
print(len(t))                # 37

print(zlib.decompress(t))    # b&#39;witch which has which witches wrist watch&#39;
</code></pre>
<h3 id="json-amp-amp-urllib"><a href="#json-amp-amp-urllib" class="headerlink" title="json &amp;&amp; urllib"></a>json &amp;&amp; urllib</h3><p>urllib 是一个收集了多个用到 URL 的模块的包（写爬虫会经常用到）：</p>
<ul>
<li><p>urllib.request 打开和读取 URL</p>
</li>
<li><p>urllib.error 包含 urllib.request 抛出的异常</p>
</li>
<li><p>urllib.parse 用于解析 URL</p>
</li>
<li><p>urllib.robotparser 用于解析 robots.txt 文件</p>
</li>
</ul>
<pre><code>  import urllib.request
  import urllib.parse

  url = &#39;https://www.baidu.com/&#39;

  # 解析url参数
  print(urllib.parse.urlparse(url))  

  # 定义一个请求头的User-Agent字段
  headers = &#123;&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36&#39;&#125;

  # 自定义请求头信息，返回一个请求的对象request，Request()参数，还可以接收data参数，表示请求体
  request = urllib.request.Request(url,headers = headers)

  # 通过urlopen访问url，服务器返回response对象
  response = urllib.request.urlopen(request)

  # 读取返回结果
  result = response.read()

  with open(&#39;baidu.html&#39;,&#39;wb&#39;) as f:
      f.write(result)
</code></pre>
<p>运行结果：</p>
<pre><code>  ParseResult(scheme=&#39;https&#39;, netloc=&#39;www.baidu.com&#39;, path=&#39;/&#39;, params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)
  # 本地出现baidu.html文件，跟正常访问时返回的源码一样
</code></pre>
<h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><p>json 模块提供了一种很简单的方式来编码和解码JSON数据。 其中两个主要的函数是 json.dumps() 和 json.loads()</p>
<pre><code>  import json

  data=&#123;&quot;status&quot;:&quot;1&quot;,&quot;notice&quot;:&#123;&quot;title&quot;:&quot;测试&quot;&#125;&#125;

  # 将一个Python数据结构转换为JSON 类似js中的JSON.stringify
  # 只对Number,String,List,Dict 有效，其他类型如Tuple会报错
  obj=json.dumps(data)
  print(obj)                   # &#123;&quot;status&quot;: &quot;1&quot;, &quot;notice&quot;: &#123;&quot;title&quot;: &quot;\u6d4b\u8bd5&quot;&#125;&#125;
  print(isinstance(obj,str))   # True


  # 将一个JSON编码的字符串转换回一个Python数据结构,类似js中的JSON.parse
  strs=json.loads(obj)
  print(strs)                   # &#123;&#39;status&#39;: &#39;1&#39;, &#39;notice&#39;: &#123;&#39;title&#39;: &#39;测试&#39;&#125;&#125;
  print(isinstance(strs,dict))  # True
</code></pre>
<p>而 <code>json.dump()</code> 和 <code>json.load()</code> 来编码和解码JSON数据,用于处理文件:</p>
<pre><code>  with open(&#39;test.json&#39;, &#39;w&#39;) as f:
      json.dump(data, f)
  
  with open(&#39;test.json&#39;, &#39;r&#39;) as f:
      data = json.load(f)
</code></pre>
<h3 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h3><p>此模块提供了将二进制数据编码为可打印的 ASCII 字符以及将这些编码解码回二进制数据的函数。</p>
<h2 id="关于-Python"><a href="#关于-Python" class="headerlink" title="关于 Python"></a>关于 Python</h2><p>Python2.x已经是遗产，已经不再维护，Python3.x是现在和未来的语言。</p>
<p>目前，Python最流行的发行版是 <a href="https://www.anaconda.com/">Anaconda</a>, 除了标准库以外，集成了很多常用软件包（尤其科学计算相关依赖）,安装后可以使用conda来管理Python环境和依赖。</p>
<p>Python的优点：</p>
<ul>
<li>语法简洁：容易上手，入门简单</li>
<li>跨平台：windows, mac, linux 均支持</li>
<li>可扩展性：可以直接调用c/c++代码</li>
<li>开放源码：开源生态圈，源码可查</li>
<li>类库丰富：得力于开源，相关工具类库非常丰富</li>
</ul>
<p>jupyter notebook 可以能将代码、文档等这一切集中到一处，让用户一目了然。可以随时运行多个自己编写的py代码</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.python.org/zh-cn/3.7/library/index.html">Python 标准库 - 3.7</a></li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a></li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">清华大学开源软件镜像站-Anaconda 镜像使用帮助</a></li>
<li><a href="https://jupyter-notebook.readthedocs.io/en/latest/">The Jupyter Notebook</a></li>
<li><a href="https://www.python.org/doc/">Python官方文档</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/44398592">Conda使用指南</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>VueJs设计与实现笔记</title>
    <url>/VueJs%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本文记录霍春阳-《VueJs设计与实现》阅读过程中的一些笔记</p>
<span id="more"></span>

<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="命令式与声明式"><a href="#命令式与声明式" class="headerlink" title="命令式与声明式"></a>命令式与声明式</h3><p>视图框架通常分为命令式与声明式，各自有优点，声明式代码的性能不优与命令式代码的性能</p>
<h3 id="运行时与编译时"><a href="#运行时与编译时" class="headerlink" title="运行时与编译时"></a>运行时与编译时</h3><p>一个框架可以是运行时、编译时以及运行时+编译时。<br>举个例子，现在有一个render函数</p>
<pre><code>function Render(obj,root) &#123;
  const el = document.createElement(obj.tag)
  if( typeof obj.children === &quot;string&quot; )&#123;
    const text = document.createTextNode(obj.children)
    el.appendChild(text)
  &#125; else if (obj.children) &#123;
     obj.children.forEach(child =&gt; Render(child,el))
  &#125;
  root.appendChild(el)
&#125;
</code></pre>
<p>用户可以这样使用：</p>
<pre><code>Render(&#123;
  tag:&quot;div&quot;,
  children:[&#123;
    tag:&quot;span&quot;,
    children:&quot;Hello world&quot;
  &#125;]
&#125;,document.body)
</code></pre>
<p>上述就是一个纯运行时的功能，但用户会觉得Render函数调用太复杂，直接使用HTML标签的描述方式来调用更直观，于是便引入编译器实现如下功能</p>
<pre><code>&lt;div&gt;
  &lt;span&gt;Hello world&lt;/span&gt;
&lt;/div&gt;

编译为

&#123;
  tag:&quot;div&quot;,
  children:[&#123;
    tag:&quot;span&quot;,
    children:&quot;Hello world&quot;
  &#125;]
&#125;
</code></pre>
<p>然后再调用Render函数得到了一样的结果，上述过程就是 编译时 + 运行时。<br>而纯编译时就是直接编译为命令式代码，Render函数也省了</p>
<pre><code>&lt;div&gt;
  &lt;span&gt;Hello world&lt;/span&gt;
&lt;/div&gt;

编译为

const div = document.createElement(&#39;div&#39;)
const span = document.createElement(&#39;span&#39;)
span.innerText = &#39;hello world&#39;
div.appendChild(span)
document.body.appendChild(div)
</code></pre>
<p>编译时代码运行效率更高，性能可能会更好，但没有什么灵活性，纯运行时又无法提前分析用户代码进而优化，VueJs采用的编译时+运行时架构，在保持灵活性的同时尽可能地优化代码</p>
]]></content>
      <categories>
        <category>Vue 系列</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Web Worker 与 Service Worker 以及CacheStorage使用指北</title>
    <url>/Web%20Worker%20%E4%B8%8E%20Service%20Worker%20%E4%BB%A5%E5%8F%8ACacheStorage%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>工作中用到两个iframe（兄弟关系）互相通信的问题，除了通过统一的父级之外，在思考还有没有其他更优解，这时候想到了Service Worker,既然谈到这个，那就重头捋一下，各种“woker”的前世今生。</p>
<p>谈到Web Worker 与 Service Worker，经常出现的高频词汇还有PWA，离线应用，缓存等，我们先了解下，这些名词的含义：</p>
<span id="more"></span>
<h2 id="Application-Cache"><a href="#Application-Cache" class="headerlink" title="Application Cache"></a>Application Cache</h2><p>应用缓存，最早HTML5 规范中设计了应用缓存（Application Cache）这么一个新的概念。通过它，我们可以做离线应用。在控制台中我们也能发现它的身影：</p>
<p><img src="./1.png"></p>
<p>然而，由于这个 API 的设计有太多的缺陷，被很多人吐槽，最终被废弃。废弃的原因有兴趣的可以查看：<a href="https://www.zhihu.com/question/29876535">为什么app cache没有得到大规模应用？它有哪些硬伤吗？</a></p>
<p>并且该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性（源自MDN 描述）。</p>
<h2 id="CacheStorage"><a href="#CacheStorage" class="headerlink" title="CacheStorage"></a>CacheStorage</h2><p>为了能够精细地、可编程地控制缓存，CacheStorage 被设计出来。有了它，开发者就可以用 JS 对缓存进行增删改查。MDN web docs上是这么定义的：</p>
<p>CacheStorage 接口表示 Cache 对象的存储。它提供了一个 ServiceWorker 、其它类型worker或者 window 范围内可以访问到的所有命名cache的主目录（它并不是一定要和service workers一起使用，即使它是在service workers规范中定义的），并维护一份字符串名称到相应 Cache 对象的映射。</p>
<p><img src="./2.png"></p>
<h2 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h2><p>JS是单线程的，并且与 GUI 渲染线程是互斥的(<a href="https://weblog.wangminghuan.cn/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/#more/">想了解更多请点我</a>), 如果进行一些密集型或耗时计算，UI页面会被阻塞住（或放慢），进入“假死”状态，这时 Web Workers 便诞生了。Web Worker属于HTML5的标准，ECMAScript中并没有，换言之就是nodejs中并不存在各种“woker”。他有如下特点：</p>
<ul>
<li>同源限制：分配给 Worker 线程运行的脚本文件，必须与当前站点域名一致,且无法加载本地文件。</li>
<li>DOM 限制：无法读取主线程所在网页的 DOM 对象，但可以读取navigator对象和location对象。</li>
<li>Web Worker只能服务于新建它的页面，不同页面之间不能共享同一个 Web Worker（如需共享需使用Shared Worker）。</li>
<li>当页面关闭时，该页面新建的 Web Worker 也会随之关闭，不会常驻在浏览器中。</li>
</ul>
<p>下面我们通过一个实际的例子来说明：</p>
<p>html文件逻辑如下（省略部分公共部分）：</p>
<pre><code>    &lt;input type=&quot;number&quot; id=&quot;ipt&quot;&gt;
    &lt;button id=&quot;btns&quot;&gt;发送&lt;/button&gt;
    &lt;button id=&quot;close&quot;&gt;关闭worker&lt;/button&gt;
    &lt;ul class=&quot;list&quot;&gt;
      &lt;p&gt;执行结果为：&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
    &lt;/ul&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    var worker= new Worker(&#39;ww.js&#39;)
    worker.onmessage= e=&gt;&#123;
      $(&quot;.list b&quot;).text($(&quot;#ipt&quot;).val()+&quot; x 100 = &quot;+e.data)
      console.log(&quot;worker run result is &quot;+e.data)
    &#125;
    $(&quot;#btns&quot;).click(()=&gt;&#123;
      var num=$(&quot;#ipt&quot;).val();
      console.log(&quot;send data is &quot;+num)
      worker.postMessage(num)
    &#125;)
    $(&quot;#close&quot;).click(()=&gt;&#123;
      console.log(&quot;---worker is close---&quot;)
      worker.terminate();
    &#125;)
    &lt;/script&gt;
</code></pre>
<p>执行的worker文件ww.js，代码如下：</p>
<pre><code>    this.onmessage=e=&gt;&#123;  //self和this都代表线程本身，也可省略不写
      const message=e.data;
      console.log(&quot;web worker get message&quot;)
      self.postMessage(message*100)
    &#125;
</code></pre>
<p>得到执行结果为：</p>
<p><img src="./4-1.png"></p>
<ul>
<li>主线程采用new命令，调用Worker()构造函数，新建一个 Worker 线程</li>
<li>worker线程与主线程之间通过postmessage与onmessage完成通信</li>
<li>然woker线程也可以关闭自身：<code>self.close()</code></li>
</ul>
<p>在控制台此处可以看到ww.js中的代码（Network中也可以看到ww.js的请求）</p>
<p><img src="./4-2.png"></p>
<h2 id="Shared-Worker"><a href="#Shared-Worker" class="headerlink" title="Shared Worker"></a>Shared Worker</h2><p>上面提到 Web Worker 无法共享的问题，Shared Worker可以说就是专门解决此问题而出现的。它可以创建一个执行指定 url 脚本的共享 web worker。不过这些页面必须是同源的（相同的协议、host 以及端口）</p>
<p>依旧创建两个页面进行测试（share 与 share2，代码基本一致）：</p>
<pre><code>  &lt;input type=&quot;text&quot; id=&quot;ipt&quot;&gt;
    &lt;button id=&quot;btns&quot;&gt;发送消息&lt;/button&gt;
    &lt;button id=&quot;close&quot;&gt;关闭worker&lt;/button&gt;
    &lt;ul class=&quot;list&quot;&gt;
      &lt;p&gt;对话消息列表1：&lt;/p&gt;
    &lt;/ul&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    var worker= new SharedWorker(&#39;swk.js&#39;,&quot;share-worker-v1&quot;);
    worker.port.start();
    worker.port.onmessage= e=&gt;&#123;
      console.log(e)
      $(&quot;.list&quot;).append(&quot;&lt;li style=&#39;color:red&#39;&gt;worker回：&quot;+e.data+&quot;&lt;/li&gt;&quot;)
    &#125;
    $(&quot;#btns&quot;).click(()=&gt;&#123;
      const val=$(&quot;#ipt&quot;).val()
      $(&quot;.list&quot;).append(&quot;&lt;li style=&#39;color:red&#39;&gt;share1问：&quot;+val+&quot;&lt;/li&gt;&quot;)
      worker.port.postMessage(val)
    &#125;)
    $(&quot;#close&quot;).click(()=&gt;&#123;
      console.log(&quot;---worker is close---&quot;)
      worker.port.close()
    &#125;)
    &lt;/script&gt;
</code></pre>
<p>执行的 Share Worker文件swk.js，代码如下：</p>
<pre><code>  this.onconnect = function(e) &#123;
      var port = e.ports[0];
      port.onmessage = function (e) &#123;
        console.log(e)
        port.postMessage(&quot;Hi! &quot;+e.data)
    &#125;
  &#125;
</code></pre>
<p>执行结果：<br><img src="./1.gif"></p>
<p>可以发现：</p>
<ul>
<li>通过构造函数<code>SharedWorker</code>来创建Share Worker。</li>
<li>创建的 Share Worker 可以在多个页面运行，且互不干扰，各自监听各自的端口。</li>
<li>关闭当前页面的 share worker 并不会影响其他页面worker正常运行。</li>
<li>只有运行Share Worker的所有页面关闭，Share Worker也会自动关闭。</li>
<li>share worker的执行可以通过<code>chrome://inspect/#workers</code>进行调试，当前页面无法调试（Network中不会出现swk.js文件）</li>
</ul>
<p><img src="./9.png"></p>
<p>我们将swk.js文件稍加改造，设置为广播模式，所有页面均可”共享”数据了</p>
<pre><code>  const clients=[]
  this.onconnect = function(e) &#123;
      var port = e.ports[0];
      clients.push(port)
      port.onmessage = function (e) &#123;
        clients.map((item)=&gt;&#123;
          item.postMessage(e.data)
        &#125;)
    &#125;
  &#125;
</code></pre>
<p>此时我们在share页面与share2页面分别根据消息类型做不同的判断，即可获取对方页面的数据，实现”共享”：</p>
<pre><code>// share页面，share2页面与之类似
worker.port.onmessage= e=&gt;&#123;
    if(e.data &amp;&amp; e.data.type==&#39;b&#39;)&#123;
      $(&quot;.list&quot;).append(&quot;&lt;li style=&#39;color:red&#39;&gt;接受到share2消息：&quot;+e.data.msg+&quot;&lt;/li&gt;&quot;)
    &#125;
  &#125;
  $(&quot;#btns&quot;).click(()=&gt;&#123;
    const val=$(&quot;#ipt&quot;).val()
    $(&quot;.list&quot;).append(&quot;&lt;li style=&#39;color:red&#39;&gt;share1发送：&quot;+val+&quot;&lt;/li&gt;&quot;)
    worker.port.postMessage(&#123;
      type:&quot;a&quot;,
      msg:val
    &#125;)
  &#125;)
</code></pre>
<p>运行结果：</p>
<p><img src="./2.gif"></p>
<h2 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h2><p>Service Worker 与 Web Worker 相比，相同点是：它们都是在常规的 JS 引擎线程以外开辟了新的 JS 线程。不同点主要包括以下几点：</p>
<ul>
<li>Service Worker 不是服务于某个特定页面的，而是服务于多个页面的。（按照同源策略）</li>
<li>Service Worker 会常驻在浏览器中，即便注册它的页面已经关闭，Service Worker 也不会停止。本质上它是一个后台线程，只有你主动终结，或者浏览器回收，这个线程才会结束。</li>
<li>生命周期、可调用的 API 等等也有很大的不同。</li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>Service Worker必须是https协议的（本地服务可以为http），里面大量使用Promise来设计，且基本不能使用同步接口（localStorage与sessionStorage）,他的基本生命周期如下：</p>
<ul>
<li>Download – 下载注册的JS文件</li>
<li>Install – 安装</li>
<li>Activate – 激活</li>
</ul>
<p>可以通过对应API监听到以下几种状态：</p>
<pre><code>installing → installed → activating → activated
</code></pre>
<p>只有处于activated 状态时才可正常使用。</p>
<p>参照张鑫旭的代码，我们创建一个Service Worker：</p>
<pre><code>  if (&#39;serviceWorker&#39; in navigator) &#123;
      // 开始注册service workers
      navigator.serviceWorker.register(&#39;sw.js&#39;).then( (registration)=&gt; &#123;
          console.log(&#39;注册成功&#39;);
          var serviceWorker;
          if (registration.installing) &#123;
            serviceWorker = registration.installing;
            console.log(&#39;installing&#39;);
          &#125; else if (registration.waiting) &#123;
            serviceWorker = registration.waiting;
            console.log(&#39;waiting&#39;);
          &#125; else if (registration.active) &#123;
            serviceWorker = registration.active;
            console.log(&#39;active&#39;);
          &#125;
          if (serviceWorker) &#123;
            $(&#39;#swState&#39;).text(serviceWorker.state);
              serviceWorker.addEventListener(&#39;statechange&#39;, function (e) &#123;
                $(&#39;#swState&#39;).append(&#39;&amp;emsp;状态变化为&#39; + e.target.state);
              &#125;);
          &#125;
      &#125;).catch ((error) =&gt;&#123;
        console.log(&#39;注册失败&#39;);
      &#125;);
  &#125;
</code></pre>
<p>执行结果为：</p>
<p><img src="./4.png"></p>
<h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><p>在此基础上测试下Service Worker的通信功能，修改html文件：</p>
<pre><code>   btns.addEventListener(&#39;click&#39;,()=&gt;&#123;
      console.log(&quot;send message to service!!&quot;)
      navigator.serviceWorker.controller.postMessage(&quot;Hi!&quot;);
    &#125;);

   navigator.serviceWorker.addEventListener(&quot;message&quot;, function(event) &#123;
    console.log(&quot;***main process get message***&quot;)
    console.log(event.data)
  &#125;);
</code></pre>
<p>sw.js文件内容为：</p>
<pre><code>  self.addEventListener(&quot;message&quot;, function(event) &#123;
    console.log(&quot;--- service get data ---&quot;)
    self.clients.matchAll().then((clientList)=&gt;&#123;
      clientList.forEach(client =&gt; &#123;
        client.postMessage(&quot;Hello service,I get you message:&quot;+event.data)
      &#125;)
    &#125;)
  &#125;);
</code></pre>
<p>我们再次执行，此处有个小插曲，就是sw.js文件的更新，需要在控制台中手动进行Unregister操作，否则无法更新Service Worker中的代码，在sw.js文件后面加时间戳也只会进入waiting状态：</p>
<p><img src="./5.png"></p>
<p>也可结合业务实现自动更新，参见：<a href="https://zhuanlan.zhihu.com/p/51118741">谨慎处理 Service Worker 的更新</a>，此处不再赘述。</p>
<p>接着上面的代码，重新执行后，点击按钮向service worker发送消息：</p>
<p><img src="./6.png"></p>
<h3 id="拦截请求"><a href="#拦截请求" class="headerlink" title="拦截请求"></a>拦截请求</h3><p>Service Worker 可以拦截页面的所有的请求（包括图片，静态资源，ajax）,在sw.js中增加监听:</p>
<pre><code>self.addEventListener(&#39;fetch&#39;, function(event) &#123; 
  console.log(&quot;拦截请求~&quot;)
  console.log(event)
&#125;);
</code></pre>
<p>此时页面发出的请求均会被拦截到：</p>
<p><img src="./7.png"></p>
<h3 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h3><p>Service Worker因为可以常驻浏览器，所以很多时候被拿来做缓存应用，可以参照张鑫旭童鞋的<a href="https://zhangxinxu.github.io/https-demo/cache/start.html">demo</a>，Service Worker其实只是开了一个后台线程，所以具体怎么用，全凭与其他api的配合使用:</p>
<ul>
<li>与 Fetch 搭配，可以从浏览器层面拦截请求，做数据 mock；</li>
<li>与 Fetch 和 CacheStorage 搭配，可以做离线应用；</li>
<li>与 Push 和 Notification 搭配，可以做类似 Native APP 的消息推送</li>
</ul>
<p>Service Worker 是 Web Worker 进一步发展的产物，从其起步至今也不过两三年的时间，尚处在发展期，希望今后更加完善与易用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API">MDN-Web Worker API</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/SharedWorker/SharedWorker">MDN-Share Worker API</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">MDN-Service Worker API</a></li>
<li><a href="http://kailian.github.io/2017/03/01/service-worker">kailian blog - Service Worker是什么?</a></li>
<li><a href="https://github.com/youngwind/blog/issues/113">浏览器缓存、CacheStorage、Web Worker 与 Service Worker</a></li>
<li><a href="https://www.zhangxinxu.com/wordpress/2017/07/service-worker-cachestorage-offline-develop/">借助Service Worker和cacheStorage缓存及离线开发-张鑫旭</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Web Worker</tag>
        <tag>Service Worker</tag>
        <tag>CacheStorage</tag>
      </tags>
  </entry>
  <entry>
    <title>cef wek electron nwjs和miniblink的简单介绍</title>
    <url>/cef%20wek%20electron%20nwjs%E5%92%8Cminiblink%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前端这两年的发展开始出现一个新的分支，PC桌面应用，类比移动端的混合开发，PC端的各种“壳子”也是百花齐放。我们来细数下这些年出现的相关内核</p>
<span id="more"></span>

<h2 id="wke"><a href="#wke" class="headerlink" title="wke"></a>wke</h2><p>wke出现的比较早，wke 是一个基于 WebKit 精简的浏览器引擎，<a href="https://github.com/BlzFans/wke">github</a>上可以发现这个项目早在2013年左右已经停止更新了，同时有一个新的fork的<a href="https://github.com/cexer/wke">github项目</a>目前还在维护，同时介（吐）绍（槽）了原项目的相关发展。因为wke 是由 WebKit 2011 年的版本精简而来，之后一直没有同步 WebKit 更新过，因此 wke 对 HTML5 的支持能力停留在 2011 年，一直未改进。所以，bug很多，但是，体积很小!!</p>
<h2 id="cef（Chromium-Embeded-Framework）"><a href="#cef（Chromium-Embeded-Framework）" class="headerlink" title="cef（Chromium Embeded Framework）"></a>cef（Chromium Embeded Framework）</h2><p>CEF的历史：</p>
<ul>
<li>CEF有两种版本的Chromium Embedded Framework：CEF 1和CEF 3</li>
<li>在Chromium Content API出现后，CEF 2的开发被放弃。</li>
<li>CEF 1是基于Chromium WebKit API的单进程实现。它不再积极发展或支持。</li>
<li>CEF 3是基于Chromium Content API的多进程实现，其性能类似于Google Chrome。</li>
</ul>
<p>优点: 是由于集成的chromium内核，所以对H5支持的很全，同时因为使用的人也多，各种教程、示例，资源很多。  </p>
<p>缺点: 最新的cef已经夸张到了100多M，不支持xp了（chromium对应版本是M49）。而且由于是多进程架构，对资源的消耗也很大。</p>
<h2 id="nwjs-和-electron"><a href="#nwjs-和-electron" class="headerlink" title="nwjs 和 electron"></a>nwjs 和 electron</h2><p>二者都是基于chromium内核，提供了一个能通过 JavaScript 和 HTML 创建桌面应用的平台，同时集成 Node 来授予网页访问底层系统的权限，所以支持性对前端友好。</p>
<p>功能上看，二者差不多，主要的区别是入口方式。Electron是基于node的，入口是类似node module的index.js，这是因为Electron是基于node的event-loop将chromium的功能和event全部整合app，Electron的开发跟其他的node应用没区别。NW.js像一个跑在node-platform上的浏览器，所以他的入口是index.html，NW.js将自己的功能都整合进了chromium-runtime，因此更接近一个前端的应用开发方式。NW.js也可以用到node的api，这是通过binding到chromium-runtime来调用的。</p>
<p>同时，nwjs支持xp，新版的electron已经不支持xp了。  </p>
<p>安装包依旧比较大，且内存占用高居不下。</p>
<h2 id="miniblink"><a href="#miniblink" class="headerlink" title="miniblink"></a>miniblink</h2><p>miniblink是一个开源的、单文件、且目前已知的最小的基于chromium的，浏览器控件，主要就是把blink从chromium抽离了出来，同时补上了cc层（硬件渲染层）。github地址：<a href="https://github.com/weolar/miniblink49">https://github.com/weolar/miniblink49</a></p>
<p>缺点应该是，目前文档较少，遇到问题需要自己解决。</p>
<h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><h3 id="浏览器内核知多少"><a href="#浏览器内核知多少" class="headerlink" title="浏览器内核知多少"></a>浏览器内核知多少</h3><p>浏览器的内核是分为两个部分的：渲染引擎（layout engineer）或（Rendering Engine）和 JS 引擎。</p>
<p>渲染引擎：负责对网页语法的解释（HTML、javaScript、引入css等），并渲染（显示）网页。<br>JS引擎：javaScript的解释、编译、执行。    </p>
<p>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于单指渲染引擎。 主流的内核有：Trident(IE)、Gecko(FireFox)、Webkit(Safari)、Presto(opera前内核、已废弃)、blink(Chrome)、edgehtml(IE Edge)PS:国内很多的双核浏览器的其中一核便是 Trident，美其名曰 “兼容模式”。</p>
<table>
<thead>
<tr>
<th>主流浏览器</th>
<th>内核</th>
</tr>
</thead>
<tbody><tr>
<td>IE -&gt; Edge</td>
<td>trident-&gt;EdgeHTML</td>
</tr>
<tr>
<td>Chrome</td>
<td>webkit-&gt;blink</td>
</tr>
<tr>
<td>Safari</td>
<td>webkit</td>
</tr>
<tr>
<td>Firefox</td>
<td>Gecko</td>
</tr>
<tr>
<td>Opera</td>
<td>Presto-&gt;blink</td>
</tr>
</tbody></table>
<p>关于浏览器内核的纷争和发展，具体访问参考4即可。此处着重说下WebKit。</p>
<h3 id="WebKit"><a href="#WebKit" class="headerlink" title="WebKit"></a>WebKit</h3><p>WebKit内核则是苹果基于KDE小组（Linux桌面系统）的 KHTML 引擎开发出来的，可以说 WebKit 是 KHTML 的一个开源的分支（感谢苹果当年弃用了Gecko）。webkit内核的轻便得到了谷歌的青睐，2008 年谷歌公司发布 chrome 浏览器，采用的 chromium 内核便 fork 了Webkit，同时，chrome将webkit内核发扬光大。</p>
<h3 id="Chromium"><a href="#Chromium" class="headerlink" title="Chromium"></a>Chromium</h3><p>Chromium是谷歌为了研发Chrome而启动的项目，两者基于相同的源代码构建，Chrome所有的新功能都会先在Chromium上实现，待验证稳定后才会移植，因此Chromium的版本更新频率更高，也会包含很多新的功能，但作为一款独立的浏览器，Chromium的用户群体要小众得多。由于两款浏览器“同根同源”，因此它们有着同样的logo，只是配色不同。谷歌发布的 chrome 浏览器使用的内核被命名为 chromium。chromium 虽然是开源引擎webkit的一个分支，却把 WebKit 的代码梳理得可读性提高很多。也有很多人将chrome内核依旧称为webkit内核。  </p>
<p>因为一些利益原因和项目问题（个人认为主要是利益原因），Google 决定从 WebKit 衍生出自己的 Blink 引擎。</p>
<h3 id="Blink"><a href="#Blink" class="headerlink" title="Blink"></a>Blink</h3><p>Blink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支一样，Google 和 Opera Software 将共同研发该内核。自chrome 28开始，已经改用blink内核了。</p>
<h3 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h3><p>说起JS引擎，大家估计首先想到的就是V8，这是chrome内置的js解释器，同时万能的node也是基于V8开发的。</p>
<p>其实各大浏览器也有自己的js引擎，只是没有V8那么出名而已</p>
<table>
<thead>
<tr>
<th>主流浏览器</th>
<th>js引擎</th>
</tr>
</thead>
<tbody><tr>
<td>IE</td>
<td>EdgeJScript（IE3.0-IE8.0） / Chakra（IE9+之后，查克拉，微软也看火影么..）</td>
</tr>
<tr>
<td>Chrome</td>
<td>V8（大名鼎鼎）</td>
</tr>
<tr>
<td>Safari</td>
<td>Nitro（4-）</td>
</tr>
<tr>
<td>Firefox</td>
<td>SpiderMonkey（1.0-3.0）/ TraceMonkey（3.5-3.6）/ JaegerMonkey（4.0-）OperaLinear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-）</td>
</tr>
<tr>
<td>Firefox</td>
<td>SpiderMonkey（1.0-3.0）/ TraceMonkey（3.5-3.6）/ JaegerMonkey（4.0-）OperaLinear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-）</td>
</tr>
</tbody></table>
<h3 id="UserAgent"><a href="#UserAgent" class="headerlink" title="UserAgent"></a>UserAgent</h3><p>关于UserAgent其实它的发展更有趣，可以访问参考6。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://github.com/cexer/wke">github之wke</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22611497">屌炸天的内核来袭，史上最小chromium内核miniblink</a></li>
<li><a href="https://github.com/chromiumembedded/cef">github之cef</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34250289">Electron 和 NW.js 在技术上的差异</a></li>
<li><a href="https://www.jianshu.com/p/db1b230e3415">全面了解浏览器（内核）发展史</a></li>
<li><a href="http://litten.me/2014/09/26/history-of-browser-useragent/">浏览器野史 UserAgent列传</a></li>
<li><a href="https://juejin.im/post/5ada727c518825670b33a584">主流浏览器内核及JS引擎</a></li>
<li><a href="https://www.zhihu.com/question/36292298">维护一个大型开源项目是怎样的体验?</a></li>
</ol>
]]></content>
      <categories>
        <category>Chromium</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>闲话前端</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins搭建前端上线系统小试</title>
    <url>/jenkins%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AF%E4%B8%8A%E7%BA%BF%E7%B3%BB%E7%BB%9F%E5%B0%8F%E8%AF%95/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一次在跟同事讨论中忽然萌生了自己手动搭建一套上线系统的想法，第一次上手，所以选用了业内比较成熟的方案-jenkins。之前只是用过jenkins进行过一些操作，并未自己从0到1完成搭建，本文记录下自己整个过程中的遇到的一些问题与解决方案。</p>
<span id="more"></span>

<h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><p>linux安装软件的方式（知道的可以直接跳过本节）：</p>
<p>一般有三种方式：<a href="https://blog.csdn.net/qq_36119192/article/details/82866329">Linux系统中安装软件的几种方式</a>  </p>
<ol>
<li><p>源码包安装：<br> 下载源码 -&gt; 解压 -&gt; 运行configure配置等 -&gt; make 编译 -&gt; make  install 安装</p>
</li>
<li><p>rpm包安装：<br>RedHat Package Manager，由红帽公司提出，建议统一的数据库文件，详细记录软件包的安装、卸载等变化信息，能够自动分析软件包依赖关系。用RPM工具可以将二进制程序进行打包，包被称为RPM包。RPM包并不是跨平台的。</p>
</li>
<li><p>yum源安装：<br>Yellow dog Updater, Modified, 是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装</p>
</li>
</ol>
<p>linux启动服务管理两种方式service和systemctl：</p>
<p>service作为启动init进程的主命令存在一些历史缺陷，Systemd就是他的升级版，他为系统的启动和管理提供一套完整的解决方案。Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面：systemctl是 Systemd 的主命令，用于管理系统。</p>
<h2 id="方案一：-docker安装"><a href="#方案一：-docker安装" class="headerlink" title="方案一： docker安装"></a>方案一： docker安装</h2><p>docker作为目前比较火的一个名词，自己一直没机会使用，了解到jenkins可以通过docker来安装，于是，从docker开始，进入了采坑之旅。</p>
<h3 id="centos上安装docker"><a href="#centos上安装docker" class="headerlink" title="centos上安装docker"></a>centos上安装docker</h3><p>自己的服务器为阿里云，版本如下（以下所有操作均是基于此台机器）：</p>
<pre><code>uname -a
Linux iZ2zeb34hcp1ui0lowu4atZ 3.10.0-957.5.1.el7.x86_64 #1 SMP Fri Feb 1 14:54:57 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
</code></pre>
<p>docker的安装还是比较简单的，参照<a href="https://help.aliyun.com/document_detail/51853.html">阿里云官方文档</a>几分钟搞定：</p>
<p>添加yum源</p>
<pre><code>  # yum install epel-release –y // 安装并启用 EPEL 源。
  # yum clean all
  # yum list
</code></pre>
<p>安装并运行Docker</p>
<pre><code>  # yum install docker-io –y
  # systemctl start docker // 启动docker服务
</code></pre>
<p>检查安装结果。</p>
<pre><code>  # docker info
</code></pre>
<h3 id="关于-docker"><a href="#关于-docker" class="headerlink" title="关于 docker"></a>关于 docker</h3><p>“Docker” 的本质其实是解决了应用服务的 “隐私” 问题，实现进程、内存、文件、网络之间相互隔离。也可以简单把 Docker 理解成一种虚拟机，很多应用服务可以像桌面软件那样一键安装，免部署和环境配置。</p>
<h4 id="前端为什么需要使用-Docker？"><a href="#前端为什么需要使用-Docker？" class="headerlink" title="前端为什么需要使用 Docker？"></a>前端为什么需要使用 Docker？</h4><ol>
<li>对于 Full Stack 工程师。Docker 可以提供一种简单轻便的服务器编程环境，而且可以随用随删、降低环境配置成本。</li>
<li>很多 FE 日常工作中需要跟 Nginx、MongoDB、MySQL 等服务器应用打交道。用 Docker 可以很容易部署一个测试环境，学习和倒腾.</li>
</ol>
<h4 id="Docker-中的三个概念"><a href="#Docker-中的三个概念" class="headerlink" title="Docker 中的三个概念"></a>Docker 中的三个概念</h4><pre><code>Container - 容器
Image - 镜像
Registry - 仓库
</code></pre>
<p>可以像下面这张图来类比：</p>
<p><img src="1.jpg"></p>
<h3 id="docker-安装jenkins"><a href="#docker-安装jenkins" class="headerlink" title="docker 安装jenkins"></a>docker 安装jenkins</h3><p>使用下面的 docker run 命令运行 jenkinsci/blueocean 镜像作为Docker中的一个容器(如果本地没有镜像，这个命令会自动下载):</p>
<pre><code>docker run \
  --rm \
  -u root \
  -p 8080:8080 \
  -v jenkins-data:/var/jenkins_home \
  -v /var/run/docker.sock:/var/run/docker.sock \
  -v &quot;$HOME&quot;:/home \
  jenkinsci/blueocean
</code></pre>
<p>此时就进入jenkins安装流程，具体参照此处<a href="https://jenkins.io/zh/doc/tutorials/build-a-node-js-and-react-app-with-npm/#setup-wizard">jenkins官网安装示例</a>：</p>
<p>启动服务，输入密码继续(安装过程忘记截图了，以下图收集于网络)；</p>
<p><img src="1.png"></p>
<p>启动后安装推荐插件:</p>
<p><img src="2.png"><br><img src="3.png"><br>安装插件完成后，进入设置初始账号密码:</p>
<p><img src="4.png"></p>
<p>设置完毕即可进入jenkins主页：</p>
<p><img src="5.png"></p>
<p>可能遇到的问题：<br>1.访问接口出现：Error:403 No valid crumb was included in the request<br>解决：关闭安全设置里面的-防止款站点请求伪造选项，具体参照<a href="https://www.jianshu.com/p/959a7d07273f">此处</a>。</p>
<h3 id="jenkins-配置nodejs"><a href="#jenkins-配置nodejs" class="headerlink" title="jenkins 配置nodejs"></a>jenkins 配置nodejs</h3><p>进入插件管理，安装Nodejs Plugin: </p>
<p><img src="6.png"></p>
<p>进入全局工具配置，配置项目中会用到的nodejs版本，可以配置多个</p>
<p><img src="7.png"></p>
<h3 id="jenkins-github-配置项目"><a href="#jenkins-github-配置项目" class="headerlink" title="jenkins + github 配置项目"></a>jenkins + github 配置项目</h3><p>开始创建项目，选择自由风格：</p>
<p><img src="8.png"></p>
<p>开始配置项目（以github私有项目为例）</p>
<p><img src="9.png"></p>
<p>此处我们填写完git地址后需要添加凭证，添加其他个人私有密钥不知道为啥一直在下拉菜单中选不到，添加用户名密码则可以，暂时还不知道啥原因~</p>
<p><img src="10.png"></p>
<p><img src="11.png"></p>
<p>触发器中我们选择hook，push之后，自动触发构建</p>
<p><img src="12.png"></p>
<p>此处在github中也要做对应配置才可出发hook功能：<br><img src="16.png"></p>
<p>也可以自定义配置，譬如，push 与 merge时触发，选择Let me select individual events，勾选以下选项：</p>
<pre><code>Deployments
Deployment statuses
Pull requests
Pushes
</code></pre>
<p>接下来我们配置拉去完代码后需要执行的脚本，centos上我们选择shell脚本：</p>
<p><img src="14.png"></p>
<p>至此，一个简单的配置已经完毕，可以进行自动构建测试了！！</p>
<h3 id="doker-模式下遇到的问题"><a href="#doker-模式下遇到的问题" class="headerlink" title="doker 模式下遇到的问题"></a>doker 模式下遇到的问题</h3><p>我们随便改一点东西，向master分支push代码，触发构建；构建任务正常触发，但执行到shell脚本时却出现了异常：</p>
<pre><code>[test-project] $ /bin/sh -xe /tmp/jenkins6958996694563138608.sh
+ node -v
/tmp/jenkins6958996694563138608.sh: line 2: node: not found
Build step &#39;Execute shell&#39; marked build as failure
Finished: FAILURE
</code></pre>
<p>通过<code>docker exec -it 4c0fd5e5f2c5 bash</code> 命令进入容器内部bash访问：</p>
<pre><code>    cd /var/jenkins_home/tools/jenkins.plugins.nodejs.tools.NodeJSInstallation/nodejs_10.15.3/
</code></pre>
<p>nodejs文件夹存在，但执行 <code>bin/node -v</code> 报错，提示 : No such file or directory</p>
<p>解决：终于在<a href="https://stackoverflow.com/questions/43307107/jenkins-nodejsplugin-node-command-not-found">stackoverflow</a> 翻到一个大佬的回答，原因如下：</p>
<pre><code>This happens because the image doesn&#39;t contain libstdc++.so.6 as needed by nodejs
    
In other words, node: not found does not mean node is not installed (it is, it is executable and found in the $PATH).  
     
It means one of node dependencies is not found.
</code></pre>
<p>我们通过，手动安装：</p>
<pre><code>apk add --no-cache --update nodejs nodejs-npm
</code></pre>
<p>拉取的是Node.js Alpine <a href="https://blog.csdn.net/weixin_33735077/article/details/91372328">镜像</a>，这个镜像做个优化，并没有内置npm包（本人验证 10.14.2是没有的）需要手动再安装npm；</p>
<p>再次构建</p>
<pre><code>/var/jenkins_home/tools/jenkins.plugins.nodejs.tools.NodeJSInstallation/nodejs_10.15.3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/lib/jvm/java-1.8-openjdk/jre/bin:/usr/lib/jvm/java-1.8-openjdk/bin
+ node -v
v10.14.2
+ npm -v
6.4.1
Finished: SUCCESS
</code></pre>
<p>执行成功，考虑到调试困难和后续还需要全局安装vue-cli3.0 于是决定放弃docker方式，改用RPM方式再次安装jenkins</p>
<h2 id="RPM方式安装jenkins"><a href="#RPM方式安装jenkins" class="headerlink" title="RPM方式安装jenkins"></a>RPM方式安装jenkins</h2><p>因为Jenkins是基于java的,所以需要先安装jdk</p>
<h3 id="安装java环境"><a href="#安装java环境" class="headerlink" title="安装java环境"></a>安装java环境</h3><pre><code>sudo yum install java
</code></pre>
<h3 id="下载rpm包："><a href="#下载rpm包：" class="headerlink" title="下载rpm包："></a>下载rpm包：</h3><p> 通过<a href="https://pkg.jenkins.io/redhat-stable/">RedHat Linux RPM packages for Jenkins</a>网站下载所需的rpm包，我安装的是jenkins-2.195-1.1.noarch.rpm</p>
<h3 id="安装jenkins"><a href="#安装jenkins" class="headerlink" title="安装jenkins"></a>安装jenkins</h3><pre><code>sudo rpm -ih jenkins-2.73.2-1.1.noarch.rpm
</code></pre>
<p>自动安装完成之后： </p>
<p>/usr/lib/jenkins/jenkins.war    WAR包 </p>
<p>/etc/sysconfig/jenkins       配置文件</p>
<p>/var/lib/jenkins/       默认的JENKINS_HOME目录</p>
<p>/var/log/jenkins/jenkins.log    Jenkins日志文件</p>
<h3 id="启动jenkins"><a href="#启动jenkins" class="headerlink" title="启动jenkins"></a>启动jenkins</h3><pre><code>sudo systemctl start jenkins.service
</code></pre>
<p>之后的操作与上一步docker安装方式基本一摸一样，唯一区别的就是器nodejs安装方式</p>
<h3 id="node调用centos全局配置"><a href="#node调用centos全局配置" class="headerlink" title="node调用centos全局配置"></a>node调用centos全局配置</h3><p>取消构建环境配置下的：Provide Node &amp; npm bin/ folder to PATH 即可</p>
<h3 id="完善整个构建流程"><a href="#完善整个构建流程" class="headerlink" title="完善整个构建流程"></a>完善整个构建流程</h3><p>其实主要就是shell脚本的编写，项目中配置如下(新建了另外一个项目vue-build-project)：</p>
<pre><code>node -v 
echo &quot;开始安装依赖...&quot;
npm install
echo &quot;开始打包...&quot;
npm run build

base=&quot;/home/upload-upyun&quot;
dest=&quot;vue-build-project&quot;
cp -r ./dist  $&#123;base&#125;/$&#123;dest&#125;
echo &quot;开始上传...&quot;
node  $&#123;base&#125;/index.js $&#123;dest&#125;
rm -rf $&#123;base&#125;/$&#123;dest&#125;
</code></pre>
<p><code>/home/upload-upyun/index.js</code> 内容如下：</p>
<pre><code>const argPath=(process.argv.splice(2));//通过透传参数获取文件夹目录
const uploadFolder=(argPath[0]?argPath[0]:&#39;&#39;).replace(/^--/g,&#39;&#39;);
const rootPath=(argPath[1]?argPath[1]:&#39;&#39;).replace(/^--/g,&#39;&#39;); //静态资源服务器的上传根路径
const fs=require(&quot;fs&quot;);
const path=require(&quot;path&quot;);
const upyun = require(&quot;upyun/dist/upyun.common&quot;);
const localFileArr=[];
function readPathSync (p) &#123;
  if(!fs.existsSync(p)) return;
  const stat = fs.statSync(p)
  if (stat.isDirectory()) &#123;
    const ls = fs.readdirSync(p).map(file =&gt; path.join(p, file))
    for (let i = 0; i &lt; ls.length; i++) &#123;
      readPathSync(ls[i])
    &#125;
  &#125; else &#123;
    localFileArr.push(p)
  &#125;
&#125;
const ypyConf=&#123;
    &quot;serviceName&quot; : &quot;xxx&quot;,
    &quot;operatorName&quot; : &quot;xxx&quot;,
    &quot;password&quot; :&quot;xxx&quot;,
    &quot;remotePath&quot; rootPath,
&#125;;

  // 需要填写本地路径，云存储路径
  const remoteRoot = ypyConf.remotePath;
  const upService = new upyun.Service(ypyConf.serviceName, ypyConf.operatorName, ypyConf.password);
  const upClient = new upyun.Client(upService);
  const prefix=(path.join(__dirname))
  // 上传参数
  // console.log(upClient)
  function uploadFile(localFile)&#123;
    const remoteFile= remoteRoot+(localFile.replace(prefix,&#39;&#39;)).split(path.sep).join(&quot;/&quot;)
    upClient.putFile(remoteFile, fs.createReadStream(localFile), &#123;
      &#39;Date&#39;: new Date(),
      &#39;Content-Length&#39;: fs.statSync(localFile).size,
    &#125;).then(res =&gt; &#123;
      if (res) &#123;
        console.log(remoteFile+&quot;:上传成功&quot;)
      &#125; else &#123;
        console.log(remoteFile+&quot;:上传失败&quot;)
      &#125;
    &#125;).catch(err =&gt; &#123;
      console.log(&quot;上传出现异常！&quot;)
    &#125;)
&#125;
readPathSync(path.join(__dirname,uploadFolder));
localFileArr.map((item)=&gt;&#123;
  uploadFile(item)
&#125;)
</code></pre>
<h3 id="最终构建效果"><a href="#最终构建效果" class="headerlink" title="最终构建效果"></a>最终构建效果</h3><pre><code>16:21:48 [vue-build-project] $ /bin/sh -xe /tmp/jenkins8111626610056806132.sh
16:21:48 + node -v
16:21:48 v10.15.3
16:21:48 + echo 开始安装依赖...
16:21:48 开始安装依赖...
16:21:48 + echo 开始打包...
16:21:48 开始打包...
16:21:48 [vue-build-project] $ /bin/sh -xe /tmp/jenkins6507915611034625552.sh
16:21:48 + cd /var/lib/jenkins/workspace
16:21:48 + cd vue-build-project
16:21:48 + cp -r ./dist /home/upload-upyun/vue-build-project
16:21:48 + echo 开始上传...
16:21:48 开始上传...
16:21:48 + node /home/upload-upyun/index.js vue-build-project
16:21:48 /test/vue-build-project/favicon.ico:上传成功
16:21:48 /test/vue-build-project/index.html:上传成功
16:21:48 /test/vue-build-project/static/js/app.6e3674b9.js:上传成功
16:21:48 /test/vue-build-project/static/css/app.e2713bb0.css:上传成功
16:21:48 /test/vue-build-project/static/img/logo.82b9c7a5.png:上传成功
16:21:48 /test/vue-build-project/static/js/chunk-vendors.a1771d7d.js:上传成功
16:21:48 + rm -rf /home/upload-upyun/vue-build-project
16:21:48 Finished: SUCCESS
</code></pre>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>在npm install 这一步出现了一个问题困扰了我两天，执行过程中jenkins进程会忽然挂掉,一直以为是配置的问题，后来忽然意识到可能是被centos给干掉了，查看日志：</p>
<pre><code>grep &quot;Out of memory&quot; /var/log/messages
</code></pre>
<p>得到日志如下：</p>
<p><img src="17.png"></p>
<p>时间节点与我构建时完全相同！！！！，坑啊！！！查阅资料明白是触发了 <a href="https://blog.51cto.com/vaedit/2112627">linux 的 OOM killer 机制</a>：</p>
<p>于是乎重启服务器，只开启Jenkins，重新构建。我的阿里云服务器可怜的1G内存在构建过程中的内存变化如下：</p>
<p><img src="18.png"></p>
<p>所以，都是贫穷惹的祸~</p>
<h2 id="根据git-diff-选择性上传文件"><a href="#根据git-diff-选择性上传文件" class="headerlink" title="根据git diff 选择性上传文件"></a>根据git diff 选择性上传文件</h2><p>有些情况下，我们只需要上传变动的文件，并不需要上传所有文件，此时shell部分可以这样编写：</p>
<pre><code>diff=`git diff --name-only HEAD~1 HEAD~0`
base=&quot;/home/upload-upyun&quot;
dest=&quot;static-demo&quot;
rm -rf $&#123;base&#125;/$&#123;dest&#125;
# 创建目标文件夹
mkdir -p $&#123;base&#125;/$&#123;dest&#125;
# 循环复制变动文件(被删除文件忽略，只做新增与覆盖)
for line in $diff
do 
if [ -f $line ];then
  cp --parents -afv $line $&#123;base&#125;/$&#123;dest&#125;
fi
done

echo &quot;开始上传...&quot;
node  $&#123;base&#125;/index.js --$&#123;dest&#125;
rm -rf $&#123;base&#125;/$&#123;dest&#125;
</code></pre>
<h2 id="jenkins的其他安装方式"><a href="#jenkins的其他安装方式" class="headerlink" title="jenkins的其他安装方式"></a>jenkins的其他安装方式</h2><p>也可以通过以下方式安装Jenkins，本文不再尝试，效果与rpm方式理论应该等同，具体可参照:</p>
<ol>
<li>yum进行安装：<a href="https://blog.csdn.net/lazycheerup/article/details/83928548">jenkins yum 安装</a></li>
<li>war包安装：<a href="https://blog.51cto.com/bigboss/2129358">WAR包方式安装Jenkins</a></li>
</ol>
<h2 id="Generic-Webhook-Trigger-Plugin"><a href="#Generic-Webhook-Trigger-Plugin" class="headerlink" title="Generic Webhook Trigger Plugin"></a>Generic Webhook Trigger Plugin</h2><p>上述的webhook是通过github-plugin 进行触发，但对于其他git托管，如腾讯云，阿里云，码云等其他第三方git服务提供平台，并没有对应的插件，此时，就轮到 <code>Generic Webhook Trigger Plugin</code> 插件登场：  </p>
<p>首先，进行安装，过程省略。安装完毕后在项目配置页面可以看到多出一个配置：</p>
<p><img src="20.png"></p>
<p>我们需要拿到webhook的地址，根据官方文档可以知道，我们需要拿到Jenkins管理员的API token, 进入管理用户页面，选择admin生成一个：</p>
<p><img src="21.png"></p>
<p>最终得到的webhook地址为：<code>http://xxx:8080/generic-webhook-trigger/invoke?token=11d85c3af55e018axxxxxx</code>, 这里我们以腾讯云为例，配置下webhook:</p>
<p><img src="22.png"></p>
<p>我们再回到项目配置页面，需要对该插件做一些配置, 默认我们配置好webhook后，所有配置过该webhook的页面，所有项目与分支的任意一个变动都可以触发所有项目的构建，这显然不是我想要的，我们需要做一些区分，参照<a href="https://blog.csdn.net/xlgen157387/article/details/76216351">此文章</a>：  </p>
<ol>
<li>区分分支</li>
</ol>
<p><img src="24.png"></p>
<ol start="2">
<li>区分项目（不同服务提供商字段会有差异，腾讯云是在repository下）</li>
</ol>
<p><img src="25.png"></p>
<ol start="3">
<li>配置token</li>
</ol>
<p><img src="26.png"></p>
<ol start="4">
<li>过滤字段匹配项目（此处为每个项目特有配置，区分好项目与分支）</li>
</ol>
<p><img src="27.png"></p>
<p>我们手动构建一次可以看到webhook返回结果如下：</p>
<pre><code>&#123;
  &quot;ref&quot;: &quot;refs/heads/dev&quot;,
  &quot;before&quot;: &quot;6b53d96f0ee3dc5b1b60d389105d330641ac1612&quot;,
  &quot;after&quot;: &quot;9370030232017ff649a070ae6bf1bdd7522a037c&quot;,
  &quot;created&quot;: false,
  &quot;deleted&quot;: false,
  &quot;compare&quot;: &quot;\u003ca href\u003d\u0027https://coding.net/u/wangminghuan/p/jenkins-autoupload\u0027 target\u003d\u0027_blank\u0027\u003ejenkins-autoupload\u003c/a\u003e/git/compare/6b53d96f0ee3d...9370030232017&quot;,
  &quot;commits&quot;: [&#123;
    &quot;id&quot;: &quot;9370030232017ff649a070ae6bf1bdd7522a037c&quot;,
    &quot;distinct&quot;: false,
    &quot;message&quot;: &quot;fix:添加文件\n&quot;,
    &quot;timestamp&quot;: 1569831379000,
    &quot;url&quot;: &quot;\u003ca href\u003d\u0027https://coding.net/u/wangminghuan/p/jenkins-autoupload\u0027 target\u003d\u0027_blank\u0027\u003ejenkins-autoupload\u003c/a\u003e/git/commit/9370030232017ff649a070ae6bf1bdd7522a037c&quot;,
    &quot;author&quot;: &#123;
      &quot;name&quot;: &quot;wangminghuan&quot;,
      &quot;email&quot;: &quot;m.h.wang@foxmail.com&quot;,
      &quot;username&quot;: &quot;wangminghuan&quot;
    &#125;,
    &quot;committer&quot;: &#123;
      &quot;name&quot;: &quot;wangminghuan&quot;,
      &quot;email&quot;: &quot;m.h.wang@foxmail.com&quot;,
      &quot;username&quot;: &quot;wangminghuan&quot;
    &#125;,
    &quot;added&quot;: [&quot;dofun.png&quot;],
    &quot;removed&quot;: [],
    &quot;modified&quot;: []
  &#125;],
  &quot;head_commit&quot;: &#123;
    &quot;id&quot;: &quot;9370030232017ff649a070ae6bf1bdd7522a037c&quot;,
    &quot;distinct&quot;: false,
    &quot;message&quot;: &quot;fix:添加文件\n&quot;,
    &quot;timestamp&quot;: 1569831379000,
    &quot;url&quot;: &quot;\u003ca href\u003d\u0027https://coding.net/u/wangminghuan/p/jenkins-autoupload\u0027 target\u003d\u0027_blank\u0027\u003ejenkins-autoupload\u003c/a\u003e/git/commit/9370030232017ff649a070ae6bf1bdd7522a037c&quot;,
    &quot;author&quot;: &#123;
      &quot;name&quot;: &quot;wangminghuan&quot;,
      &quot;email&quot;: &quot;m.h.wang@foxmail.com&quot;,
      &quot;username&quot;: &quot;wangminghuan&quot;
    &#125;,
    &quot;committer&quot;: &#123;
      &quot;name&quot;: &quot;wangminghuan&quot;,
      &quot;email&quot;: &quot;m.h.wang@foxmail.com&quot;,
      &quot;username&quot;: &quot;wangminghuan&quot;
    &#125;,
    &quot;added&quot;: [&quot;dofun.png&quot;],
    &quot;removed&quot;: [],
    &quot;modified&quot;: []
  &#125;,
  &quot;pusher&quot;: &#123;
    &quot;name&quot;: &quot;王明欢&quot;,
    &quot;email&quot;: &quot;m.h.wang@foxmail.com&quot;,
    &quot;username&quot;: &quot;wangminghuan&quot;
  &#125;,
  &quot;sender&quot;: &#123;
    &quot;id&quot;: 2222972,
    &quot;login&quot;: &quot;wangminghuan&quot;,
    &quot;avatar_url&quot;: &quot;https://coding-net-production-static-ci.codehub.cn/e4ed6f51-7033-4c66-bb1c-d567795c88a9.jpg?imageMogr2/auto-orient/format/jpeg/cut/!640x640x0x0&quot;,
    &quot;url&quot;: &quot;https://dev.tencent.com/api/user/key/wangminghuan&quot;,
    &quot;html_url&quot;: &quot;https://dev.tencent.com/u/wangminghuan&quot;,
    &quot;name&quot;: &quot;王明欢&quot;,
    &quot;name_pinyin&quot;: &quot;|wmh|wangminghuan&quot;
  &#125;,
  &quot;repository&quot;: &#123;
    &quot;id&quot;: 4733490,
    &quot;name&quot;: &quot;jenkins-autoupload&quot;,
    &quot;full_name&quot;: &quot;wangminghuan/jenkins-autoupload&quot;,
    &quot;owner&quot;: &#123;
      &quot;id&quot;: 2222972,
      &quot;login&quot;: &quot;wangminghuan&quot;,
      &quot;avatar_url&quot;: &quot;https://coding-net-production-static-ci.codehub.cn/e4ed6f51-7033-4c66-bb1c-d567795c88a9.jpg?imageMogr2/auto-orient/format/jpeg/cut/!640x640x0x0&quot;,
      &quot;url&quot;: &quot;https://dev.tencent.com/api/user/key/wangminghuan&quot;,
      &quot;html_url&quot;: &quot;https://dev.tencent.com/u/wangminghuan&quot;,
      &quot;name&quot;: &quot;王明欢&quot;,
      &quot;name_pinyin&quot;: &quot;|wmh|wangminghuan&quot;
    &#125;,
    &quot;private&quot;: true,
    &quot;html_url&quot;: &quot;\u003ca href\u003d\u0027https://dev.tencent.com/u/wangminghuan/p/jenkins-autoupload\u0027 target\u003d\u0027_blank\u0027\u003ejenkins-autoupload\u003c/a\u003e&quot;,
    &quot;description&quot;: &quot;测试jenkins自动化部署上传&quot;,
    &quot;fork&quot;: false,
    &quot;url&quot;: &quot;https://dev.tencent.com/api/user/wangminghuan/project/jenkins-autoupload&quot;,
    &quot;created_at&quot;: 1568866930000,
    &quot;updated_at&quot;: 1568866930000,
    &quot;clone_url&quot;: &quot;https://git.dev.tencent.com/wangminghuan/jenkins-autoupload.git&quot;,
    &quot;ssh_url&quot;: &quot;git@git.dev.tencent.com:wangminghuan/jenkins-autoupload.git&quot;,
    &quot;default_branch&quot;: &quot;master&quot;
  &#125;
&#125;
</code></pre>
<p>至此，配置基本完毕。</p>
<h2 id="权限部分配置"><a href="#权限部分配置" class="headerlink" title="权限部分配置"></a>权限部分配置</h2><p>通过插件 <code>Role-based Authorization Strategy</code> 配置完成，安装完插件，重启Jenkins，会发现配置页面多一个选项：</p>
<p><img src="28.png"></p>
<p>首先需要在全局安全配置页面将授权策略改为：Role-Based Strategy</p>
<p><img src="31.png"></p>
<p>进入 Manage Role 选项，配置用户角色与所在组角色权限</p>
<p><img src="29.png"></p>
<p>进入 Assign Roles 选项，为用户分配角色（首先需要在用户管理板块创建用户）</p>
<p><img src="30.png"></p>
<p>具体可参考<a href="https://www.cnblogs.com/peng-lan/p/9809644.html">jenkins配置用户角色权限，根据不同权限显示视图、Job</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>docker安装方式比较傻瓜，而且整个插件安装的过程都比较快，但是因为docker就像一个封闭的黑盒，很多东西与系统是隔离开的（废话，设计初衷就是这样），导致我这个菜鸟遇到问题想不到好的解决方案。嗯，还是RPM用起来更顺手一些，遇到问题基本还能应对。最后，不差钱的，请上大内存服务器~</p>
<h2 id="可能用到的linux命令"><a href="#可能用到的linux命令" class="headerlink" title="可能用到的linux命令"></a>可能用到的linux命令</h2><pre><code># 启动docker
systemctl start docker
      
# 停止docker
systemctl stop docker 

# 列出docker内正在运行的容器
docker ps

# 列出docker内的容器
docker ps -a
      
# 启动docker内容器
docker start &lt;id&gt; 
docker restart &lt;id&gt;
docker stop &lt;id&gt;

# 进入docker容器内部执行命令
docker exec -it &lt;id&gt; bash

# 查看jenkins启动状态
systemctl status jenkins.service 

# 查看jenkins日志
sudo tail -f /var/log/jenkins/jenkins.log  查看日志
</code></pre>
<h2 id="补充：增加swap分区解决阿里云内存不足"><a href="#补充：增加swap分区解决阿里云内存不足" class="headerlink" title="补充：增加swap分区解决阿里云内存不足"></a>补充：增加swap分区解决阿里云内存不足</h2><p>发现可以扩展Swap分区，即交换区，系统在物理内存（这里应该是运行内存）不够时，与Swap进行交换，来解决内存不足的问题。设置步奏如下：</p>
<ol>
<li><p>首先创建用于交换分区的文件，并设置交换分区文件</p>
<pre><code> dd if=/dev/zero of=/var/swap bs=1024 count=4096000
</code></pre>
</li>
<li><p>创建 swap 文件</p>
<pre><code> mkswap /var/swap
</code></pre>
</li>
<li><p>加载这个文件</p>
<pre><code> swapon /var/swap
</code></pre>
<p>执行以上命令可能会出现：“不安全的权限 0644，建议使用 0600”提示，其实已经激活了，可以忽略，修改权限：</p>
<pre><code> chmod -R 0600 /var/swap
</code></pre>
</li>
<li><p>设置系统启动时自动挂载分区</p>
<pre><code> echo &quot;/var/swap swap swap defaults 0 0&quot; &gt;&gt; /etc/fstab
</code></pre>
</li>
<li><p>确定系统对SWAP分区的使用原则，当swappiness内容的值为0时，表示最大限度地使用物理内存，物理内存使用完毕后，才会使用SWAP分区。当swappiness内容的值为100时，表示积极地使用SWAP分区，并且把内存中的数据及时地置换到SWAP分区。liunx默认为60，此处我们设置为默认大小60</p>
<pre><code> echo 60 &gt; /proc/sys/vm/swappiness
</code></pre>
</li>
</ol>
<p>再次运用构建命令，查看内存变化，会发现swap区已经得到了利用：</p>
<p><img src="32.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/zwcry/p/9602756.html">Systemd 入门教程：实战篇</a></li>
<li><a href="https://blog.csdn.net/yangzaizi/article/details/83505026">Jenkins入门教程之linux下安装配置jenkins(rpm方式)</a></li>
<li><a href="https://blog.csdn.net/lazycheerup/article/details/83928548">jenkins yum 安装</a></li>
</ul>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>npm audit 指令</title>
    <url>/npm%20audit%20%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们在安装依赖的时候，安装完毕后遇到一些提示：</p>
<pre><code>added 1272 packages from 726 contributors and audited 11912 packages in 26.194s
found 10 vulnerabilities (6 moderate, 4 high)
  run `npm audit fix` to fix them, or `npm audit` for details
</code></pre>
<p>可能你已经注意到了 <code>npm audit fix</code> ，这个指令到底是干嘛的？</p>
<span id="more"></span>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>audit 的英文含义为审查，根据提示，我们运行 <code>npm audit</code> 指令，得到如下结果</p>
<pre><code>                      === npm audit security report ===

# Run  npm install --save-dev css-loader@3.0.0  to resolve 2 vulnerabilities
SEMVER WARNING: Recommended action is a potentially breaking change

  Moderate        Denial of Service

  Package         js-yaml

  Dependency of   css-loader [dev]

  Path            css-loader &gt; cssnano &gt; postcss-svgo &gt; svgo &gt; js-yaml

  More info       https://npmjs.com/advisories/788




  High            Code Injection

  Package         js-yaml

  Dependency of   css-loader [dev]

  Path            css-loader &gt; cssnano &gt; postcss-svgo &gt; svgo &gt; js-yaml

  More info       https://npmjs.com/advisories/813



# Run  npm install --save-dev url-loader@2.0.1  to resolve 1 vulnerability
SEMVER WARNING: Recommended action is a potentially breaking change

  Moderate        Regular Expression Denial of Service

  Package         mime

  Dependency of   url-loader [dev]

  Path            url-loader &gt; mime

  More info       https://npmjs.com/advisories/535



# Run  npm install --save-dev webpack-bundle-analyzer@3.3.2  to resolve 1 vulnerability
SEMVER WARNING: Recommended action is a potentially breaking change

  Moderate        Cross-Site Scripting

  Package         webpack-bundle-analyzer

  Dependency of   webpack-bundle-analyzer [dev]

  Path            webpack-bundle-analyzer

  More info       https://npmjs.com/advisories/826



# Run  npm update js-yaml --depth 5  to resolve 6 vulnerabilities

  Moderate        Denial of Service

  Package         js-yaml

  Dependency of   vue-loader [dev]

  Path            vue-loader &gt; postcss-load-config &gt; cosmiconfig &gt; js-yaml

  More info       https://npmjs.com/advisories/788




  Moderate        Denial of Service

  Package         js-yaml

  Dependency of   vue-loader [dev]

  Path            vue-loader &gt; postcss-load-config &gt; postcss-load-options &gt;
                  cosmiconfig &gt; js-yaml

  More info       https://npmjs.com/advisories/788




  Moderate        Denial of Service

  Package         js-yaml

  Dependency of   vue-loader [dev]

  Path            vue-loader &gt; postcss-load-config &gt; postcss-load-plugins &gt;
                  cosmiconfig &gt; js-yaml

  More info       https://npmjs.com/advisories/788




  High            Code Injection

  Package         js-yaml

  Dependency of   vue-loader [dev]

  Path            vue-loader &gt; postcss-load-config &gt; cosmiconfig &gt; js-yaml

  More info       https://npmjs.com/advisories/813




  High            Code Injection

  Package         js-yaml

  Dependency of   vue-loader [dev]

  Path            vue-loader &gt; postcss-load-config &gt; postcss-load-options &gt;
                  cosmiconfig &gt; js-yaml

  More info       https://npmjs.com/advisories/813




  High            Code Injection

  Package         js-yaml

  Dependency of   vue-loader [dev]

  Path            vue-loader &gt; postcss-load-config &gt; postcss-load-plugins &gt;
                  cosmiconfig &gt; js-yaml

  More info       https://npmjs.com/advisories/813



found 10 vulnerabilities (6 moderate, 4 high) in 23855 scanned packages
  run `npm audit fix` to fix 6 of them.
  4 vulnerabilities require semver-major dependency updates.
</code></pre>
<p>当我试图忽略这些提示的时候，build的时候报错了：</p>
<pre><code>Error processing file: static/css/app.372750ed4ded50947770c65a8100b5d6.css
(node:15776) UnhandledPromiseRejectionWarning: CssSyntaxError: E:\myProject\ug_zh_exe_old\html\static\css\app.372750ed4ded50947770c65a8100b5d6.css:254:8: Unknown word
</code></pre>
<p>提示我出现css的语法错误，关键是同事的macOS是正常的，只能根据官方的提示进行尝试修复，根据推测应该是package.json中某些包依赖兼容问题导致的（dev模式及是ok的）。于是执行 <code>npm audit fix</code>,但并没有帮我修正所有错误： </p>
<pre><code>npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)

added 1 package from 4 contributors and updated 1 package in 6.45s
fixed 6 of 10 vulnerabilities in 23855 scanned packages
  3 package updates for 4 vulns involved breaking changes
  (use `npm audit fix --force` to install breaking changes; or refer to `npm audit` for steps to fix these manually)
</code></pre>
<p>来吧，执行<code>npm audit fix --force</code>：</p>
<pre><code>npm WARN using --force I sure hope you know what you are doing.

&gt; fsevents@1.2.9 install E:\myProject\ug_zh_exe_old\html\node_modules\fsevents
&gt; node install

npm WARN url-loader@2.0.1 requires a peer of webpack@^4.0.0 but none is installed. You must install peer dependencies yourself.
npm WARN css-loader@3.0.0 requires a peer of webpack@^4.0.0 but none is installed. You must install peer dependencies yourself.

+ url-loader@2.0.1
+ css-loader@3.0.0
+ webpack-bundle-analyzer@3.3.2
added 92 packages from 43 contributors, removed 256 packages and updated 16 packages in 8.374s
fixed 10 of 10 vulnerabilities in 23855 scanned packages
  3 package updates for 4 vulns involved breaking changes
  (installed due to `--force` option)
</code></pre>
<p>看来是ok了，再次build, 成功了，同时package.json中相应的版本也发生了变化</p>
<pre><code>  -    &quot;css-loader&quot;: &quot;^0.28.0&quot;,
  +    &quot;css-loader&quot;: &quot;^3.0.0&quot;,

  -    &quot;url-loader&quot;: &quot;^0.5.8&quot;,
  +    &quot;url-loader&quot;: &quot;^2.0.1&quot;,
    
  -    &quot;webpack-bundle-analyzer&quot;: &quot;^2.9.0&quot;,
  +    &quot;webpack-bundle-analyzer&quot;: &quot;^3.3.2&quot;,
</code></pre>
<h2 id="npm-audit-作用"><a href="#npm-audit-作用" class="headerlink" title="npm audit 作用"></a>npm audit 作用</h2><p>根据官方文档可以看到如下介绍：</p>
<pre><code>Scan your project for vulnerabilities and automatically install any compatible updates to vulnerable dependencies
</code></pre>
<p>大意就是：检测项目依赖中的漏洞并自动安装需要更新的有漏洞的依赖，而不必再自己进行跟踪和修复</p>
<p>从官方文档看到还有其他指令：</p>
<pre><code># 扫描项目漏洞把不安全的依赖项自动更新到兼容性版本
npm audit fix

# 在不修改 node_modules 的情况下执行 audit fix，仍然会更改 pkglock
npm audit fix --package-lock-only

# 跳过更新 devDependencies
npm audit fix --only=prod

# 强制执行 audit fix 安装最新的依赖项（toplevel）
npm audit fix --force

# 单纯的获取 audit fix 会做的事，并以 json 格式输出。
npm audit fix --dry-run --json

# 获取详情
npm audit

# 以 JSON 格式打印报告
npm audit --json
</code></pre>
<h2 id="yarn-audit"><a href="#yarn-audit" class="headerlink" title="yarn audit"></a>yarn audit</h2><p><code>yarn install</code>的时候并没有相关audit的提示，只有一些warn提示：</p>
<pre><code>warning css-loader &gt; cssnano &gt; autoprefixer &gt; browserslist@1.7.7: Browserslist 2 could fail on reading Browserslist &gt;3.0 config used in other tools.
warning css-loader &gt; cssnano &gt; postcss-merge-rules &gt; browserslist@1.7.7: Browserslist 2 could fail on reading Browserslist &gt;3.0 config used in other tools.
warning css-loader &gt; cssnano &gt; postcss-merge-rules &gt; caniuse-api &gt; browserslist@1.7.7: Browserslist 2 could fail on reading Browserslist &gt;3.0 config used in other tools.
warning webpack-bundle-analyzer &gt; bfj-node4@5.3.1: Switch to the `bfj` package for fixes and new features!
</code></pre>
<p>build的时候也挂了，执行yarn autix(结果展示是表格，很赞~):</p>
<pre><code>  yarn audit v1.16.0
  ┌───────────────┬──────────────────────────────────────────────────────────────┐
  │ moderate      │ Denial of Service                                            │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ Package       │ js-yaml                                                      │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ Patched in    │ &gt;=3.13.0                                                     │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ Dependency of │ css-loader                                                   │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ Path          │ css-loader &gt; cssnano &gt; postcss-svgo &gt; svgo &gt; js-yaml         │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ More info     │ https://www.npmjs.com/advisories/788                         │
  └───────────────┴──────────────────────────────────────────────────────────────┘
  ┌───────────────┬──────────────────────────────────────────────────────────────┐
  │ high          │ Code Injection                                               │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ Package       │ js-yaml                                                      │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ Patched in    │ &gt;=3.13.1                                                     │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ Dependency of │ css-loader                                                   │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ Path          │ css-loader &gt; cssnano &gt; postcss-svgo &gt; svgo &gt; js-yaml         │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ More info     │ https://www.npmjs.com/advisories/813                         │
  └───────────────┴──────────────────────────────────────────────────────────────┘
  ┌───────────────┬──────────────────────────────────────────────────────────────┐
  │ moderate      │ Regular Expression Denial of Service                         │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ Package       │ mime                                                         │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ Patched in    │ &gt;= 1.4.1 &lt; 2.0.0 || &gt;= 2.0.3                                 │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ Dependency of │ url-loader                                                   │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ Path          │ url-loader &gt; mime                                            │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ More info     │ https://www.npmjs.com/advisories/535                         │
  └───────────────┴──────────────────────────────────────────────────────────────┘
  ┌───────────────┬──────────────────────────────────────────────────────────────┐
  │ moderate      │ Cross-Site Scripting                                         │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ Package       │ webpack-bundle-analyzer                                      │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ Patched in    │ &gt;=3.3.2                                                      │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ Dependency of │ webpack-bundle-analyzer                                      │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ Path          │ webpack-bundle-analyzer                                      │
  ├───────────────┼──────────────────────────────────────────────────────────────┤
  │ More info     │ https://www.npmjs.com/advisories/826                         │
  └───────────────┴──────────────────────────────────────────────────────────────┘
  4 vulnerabilities found - Packages audited: 11908
  Severity: 3 Moderate | 1 High
  Done in 3.61s.
</code></pre>
<p>执行<code>npm audit fix --force</code>，结果同<code>npm audit</code>，貌似yarn暂时只能手动处理，不会做相关自动化处理，详见参考三~</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://docs.npmjs.com/cli/audit">npm audit</a></li>
<li><a href="http://eux.baidu.com/blog/fe/npm%20aduit%E4%BA%8C%E4%B8%89%E4%BA%8B">npm audit 二三事</a></li>
<li><a href="https://github.com/yarnpkg/yarn/issues/7075">[feat] yarn audit fix #7075</a></li>
</ol>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>package-lock.json和yarn.lock文件的作用</title>
    <url>/package-lock-json%E5%92%8Cyarn-lock%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在node项目中如果我们使用 <code>npm install</code> 或 <code>yarn install</code> 时会发现本地会生成一个<code>package-lock.json</code> 或 <code>yarn.lock</code>文件，这个文件到底是做什么用？</p>
<span id="more"></span>
<h2 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h2><p>根据官方文档解释基本如下：  </p>
<p>package-lock.json is automatically generated for any operations where npm modifies either the node_modules tree, or package.json. It describes the exact tree that was generated, such that subsequent installs are able to generate identical trees, regardless of intermediate dependency updates.</p>
<p>翻译一下：package-lock.json是当 node_modules 或 package.json 发生变化时自动生成的文件。这个文件主要功能是确定当前安装的包的依赖，以便后续重新安装的时候生成相同的依赖，而忽略项目开发过程中有些依赖已经发生的更新。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>npm是一个用于管理package之间依赖关系的管理器，它允许开发者在pacakge.json中间标出自己项目对npm各库包的依赖。你可以选择以如下方式来标明自己所需要库包的版本，并且依赖版本管理非常宽松，默认生成的版本都是<code>^</code>写法，如：<code>&quot;vue&quot;: &quot;^2.5.0&quot;</code>。这里面的向上标号是向后（新）兼容的，如果vue的最新版本是超过2.5.0，并在大版本号（2）上相同，就允许下载最新版本的vue库包，例如实际上可能运行npm install时候下载的具体版本是2.6.1。同一个项目一天之内可能会 install 到不同版本的依赖。而依赖库包版本的不同，可能会导致其行为特征不同，甚至有时候会出现完全不兼容。</p>
<p>在受到 yarn.lock 的强烈冲击之后，npm 还是决定在 5.0.0+ 版本默认生成 package-lock.json。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>npm5.0以后的版本就开始提供自动生成package-lock.json功能，为的是让开发者知道只要你保存了源文件，到一个新的机器上、或者新的下载源，只要按照这个package-lock.json所标示的具体版本下载依赖库包，就能确保所有库包与你上次安装的完全一样。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://docs.npmjs.com/files/package-lock.json">package-lock.json官方文档</a></li>
<li><a href="https://www.zhihu.com/question/62331583">知乎-npm install 生成的package-lock.json是什么文件？有什么用？</a></li>
</ol>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>react系列-1-hooks</title>
    <url>/react%E7%B3%BB%E5%88%97-1-hooks/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>React 16.8 新增了hooks特性，这是一项激动人心的功能，可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>
<p>React的组件创建方式，一种是类组件，一种是纯函数组件，并且React团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。也就是说组件的最佳写法应该是函数，而不是类。</p>
<span id="more"></span>

<p>但目前开发中我们基本都在使用类组件开发，因为纯函数组件有类组件不具备的多种特点，如：</p>
<ul>
<li>纯函数组件没有状态</li>
<li>纯函数组件没有生命周期</li>
<li>纯函数组件没有this</li>
</ul>
<p>我们使用类组件实现一个简答的计时器功能：</p>
<pre><code>import React, &#123;Component&#125; from &#39;react&#39;;
class AddCount extends Component &#123;
  constructor(props)&#123;
    super(props)
    this.state=&#123;
      count: 0
    &#125;
  &#125;
  addcount = () =&gt; &#123;
    this.setState(&#123;
      count:this.state.count + 1
    &#125;)
  &#125;
  render()&#123;
    return (
      &lt;&gt;
        &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt;
        &lt;button rimary&quot; onClick=&#123;this.addcount&#125;&gt;Add&lt;/button&gt;
      &lt;/&gt;
    )
  &#125;
&#125;
export default AddCount
</code></pre>
<p>可以看到，一个小功能，但看起来却非常“重”，对于类组件，无论业务代码多少，constructor、render等都是必须的。</p>
<p>类组件功能齐全却很重，纯函数很轻便却有上文几点重大限制，为了解决上述问题。React团队设计了React Hooks。</p>
<h2 id="什么是React-Hooks"><a href="#什么是React-Hooks" class="headerlink" title="什么是React Hooks"></a>什么是React Hooks</h2><p>hooks,顾名思义，就是“钩子”的意思，因为函数组件没有状态，所以对于一个全功能的组件，，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。而React Hooks 就是我们所说的“钩子”。更进一步说，React Hooks就是加强版的函数组件。</p>
<p>我们先将上述类组件改为函数组件：</p>
<pre><code>import React, &#123;useState &#125; from &#39;react&#39;;
const AddCount = () =&gt; &#123;
  const [count, setCount] = useState(0);
  const addcount = () =&gt; &#123;
    let newCount = count
    setCount(newCount+=1)
  &#125; 
  return (
    &lt;div&gt;
      &lt;p&gt;Count: &#123;count&#125;&lt;/p&gt;
      &lt;button onClick=&#123;addcount&#125;&gt;Add&lt;/button&gt;
    &lt;/div&gt;
  );
&#125;;
export default AddCount;
</code></pre>
<p>可以看到函数组件 + React Hooks的写法更简洁：没有了渲染逻辑，没有了生命周期等。</p>
<p>下面介绍React Hooks的四种默认钩子：</p>
<h2 id="React-Hooks的钩子"><a href="#React-Hooks的钩子" class="headerlink" title="React Hooks的钩子"></a>React Hooks的钩子</h2><h3 id="userState-状态钩子"><a href="#userState-状态钩子" class="headerlink" title="userState():状态钩子"></a>userState():状态钩子</h3><p>纯函数组件没有状态，useState()用于为函数组件引入状态</p>
<p>在useState()中，它接受状态的初始值作为参数，即上例中计数的初始值，它返回一个数组：</p>
<p>数组第一项是一个变量，指向状态的当前值。类似this.state<br>数组第二项是一个函数，用来更新状态,类似setState  </p>
<h3 id="useContext-共享状态钩子"><a href="#useContext-共享状态钩子" class="headerlink" title="useContext():共享状态钩子"></a>useContext():共享状态钩子</h3><p>依旧从上面例子进行扩展，假设组件A与组件B共享状态:</p>
<pre><code>import React, &#123;useContext,createContext, useState  &#125; from &#39;react&#39;;
import &#123; Button &#125; from &#39;antd-mobile&#39;;
const Count=()=&gt;&#123;
  const [count,setCount]=useState(0);
  const AppContext =createContext(&#123;&#125;)
  const A=()=&gt;&#123;
    const &#123; val &#125; = useContext(AppContext)
    return(
    &lt;p&gt;我是组件A，我接收到的count值为&#123;val&#125;&lt;/p&gt;
    )
  &#125;
  const B=()=&gt;&#123;
    const &#123; val &#125; = useContext(AppContext)
    return(
    &lt;p&gt;我是组件A，我接收到的count值为&#123;val&#125;&lt;/p&gt;
    )
  &#125;
  return (
    &lt;AppContext.Provider value=&#123;&#123;val: count&#125;&#125;&gt;
      &lt;A&gt;&lt;/A&gt;
      &lt;B&gt;&lt;/B&gt;
      &lt;Button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;Add&lt;/Button&gt;
    &lt;/AppContext.Provider&gt;
  );
&#125;
export default Count;
</code></pre>
<p>运行结果：</p>
<p><img src="1.gif"></p>
<h3 id="useReducer-Action钩子"><a href="#useReducer-Action钩子" class="headerlink" title="useReducer():Action钩子"></a>useReducer():Action钩子</h3><p>因为react本身并不提供状态管理的功能，所以一般是通过外部库来解决，最常用到的就是redux。<br>redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，<br>Reducer函数的形式是<code>(state, action) =&gt; newstate</code>。</p>
<p>useReducers()钩子用来引入 Reducer 功能</p>
<pre><code>const [state, dispatch] = useReducer(reducer, initialState)
</code></pre>
<p>Reducer 函数和状态的初始值作为参数，返回一个数组:</p>
<p>数组的第一项是状态的当前值<br>数组的第一项是发送 action 的dispatch函数  </p>
<p>我们依旧实现一个计数器：</p>
<pre><code>import React, &#123;useReducer&#125; from &#39;react&#39;;
const AddCount = () =&gt; &#123;
  const reducer=(state,action)=&gt;&#123;

    if(action.type===&quot;add&quot;)&#123;
      return &#123;
        ...state,
        count:state.count+1
      &#125;
    &#125;else&#123;
      return state
    &#125;
  &#125;
  const addcount=()=&gt;&#123;
    dispatch(&#123;
      type:&quot;add&quot;
    &#125;)
  &#125;
  const [state, dispatch] = useReducer(reducer, &#123;count:0&#125;)
  return(
    &lt;div&gt;
      &lt;p&gt;Count: &#123;state.count&#125;&lt;/p&gt;
      &lt;button onClick=&#123;addcount&#125;&gt;Add&lt;/button&gt;
    &lt;/div&gt;
  )
&#125;
export default AddCount
</code></pre>
<p>由于 Hooks 可以提供共享状态和 Reducer 函数，所以它在这些方面可以取代 Redux。但是，它没法提供中间件（middleware）和时间旅行（time travel），如果你需要这两个功能，还是要用 Redux。</p>
<h3 id="useEffect-副作用钩子"><a href="#useEffect-副作用钩子" class="headerlink" title="useEffect():副作用钩子"></a>useEffect():副作用钩子</h3><p>useEffect()用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在componentDidMount里面的代码，现在可以放在useEffect()。</p>
<pre><code>import React, &#123;useEffect,useState&#125; from &#39;react&#39;;
const GetList = () =&gt; &#123;
const [loading, setLoading] = useState(true);
const [count, setCount] = useState(0);

useEffect(() =&gt; &#123;
  setLoading(true); 
  fetch(`https://xxx.xxx.com/InterfaceApi/News/noticeList`)
    .then(response =&gt; response.json())
    .then(data =&gt; &#123;
      setCount(data.data.count);
      setLoading(false);
    &#125;);
&#125;, [])

if (loading === true) &#123;
  return &lt;p&gt;Loading ...&lt;/p&gt;
&#125;
  return(
    &lt;div&gt;
      &lt;p&gt;list lens: &#123;count&#125;&lt;/p&gt;
    &lt;/div&gt;
  )
&#125;
export default GetList
</code></pre>
<p>运行结果：</p>
<p><img src="2.gif"></p>
<h3 id="创建自己的Hooks"><a href="#创建自己的Hooks" class="headerlink" title="创建自己的Hooks"></a>创建自己的Hooks</h3><p>react提供给我们了四种默认React Hooks,有时候我们需要创建自己想要的Hooks,来满足更便捷的开发，其实无非就是根据业务场景对以上四种Hooks进行组装，从而得到满足自己需求的钩子，此处不再展开。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2019/09/react-hooks.html">React Hooks 入门教程 - 阮一峰</a></li>
<li><a href="https://www.jianshu.com/p/7e778adec7d1">React Hooks,彻底颠覆React,它的未来应该是这样的</a></li>
</ul>
]]></content>
      <categories>
        <category>React 系列</category>
      </categories>
      <tags>
        <tag>hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>sentry部署前端监控系统</title>
    <url>/sentry%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>Sentry 是一个开源的实时错误监控的项目，它支持很多端的配置，包括 web 前端、服务器端、移动端及其游戏端。支持各种语言，例如 python、oc、java、node、javascript 等。也可以应用到各种不同的框架上面，如前端框架中的vue 、angular 、react 等最流行的前端框架中。最最最重要的是，他是提供收费服务的同时，也提供开源的版本。本文我们从零开始安装配置一套sentry项目。</p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>sentry官网提供两种安装方式，docker与python, 我们的主要目的是使用，安装尽量简单化，所以，选择了docker方式进行安装</p>
<h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>本次演示服务器是centos7的阿里云，首先安装docker</p>
<ul>
<li><p>安装依赖包</p>
<pre><code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2 
</code></pre>
</li>
<li><p>设置镜像（清华大学，也可使用阿里云的）</p>
<pre><code>sudo yum-config-manager --add-repo https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo
</code></pre>
</li>
<li><p>可以查看所有仓库中所有docker版本，并选择特定版本安装</p>
<pre><code>yum list docker-ce --showduplicates | sort -r
</code></pre>
<p><img src="./1.png"></p>
</li>
<li><p>安装docker</p>
<pre><code>sudo yum install docker-ce-19.03.13  #由于repo中默认只开启stable仓库，故这里安装的是最新稳定版19.03.13
</code></pre>
</li>
<li><p>启动docker</p>
<pre><code>sudo systemctl enable docker   # 开机自启

sudo systemctl start docker   # 启动docker服务  
</code></pre>
</li>
</ul>
<ul>
<li><p>测试docker</p>
<pre><code>sudo docker run hello-world  # 拉取hello-world 镜像
</code></pre>
</li>
</ul>
<p><img src="./4.png"></p>
<p>至此，docker安装成功~</p>
<h3 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h3><p>docker安装完毕后，需要安装docker-compose(macos 貌似docker安装完就自带了docker-compose，未确认)</p>
<p>Docker Compose是一个用来定义和运行复杂应用的Docker工具。一个使用Docker容器的应用，通常由多个容器组成。使用Docker Compose不再需要使用shell脚本来启动容器。</p>
<p>docker-compose的安装也有两种方式：pip(python的包管理工具)与二进制。本文我选用二进制文件进行安装：</p>
<ul>
<li><p>拉取二进制源码：</p>
<pre><code>sudo curl -L https://github.com/docker/compose/releases/download/1.27.4/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose  # uname -s 类似ES6中的模板字符串写法
</code></pre>
</li>
<li><p>添加可执行权限 </p>
<pre><code>sudo chmod +x /usr/local/bin/docker-compose
</code></pre>
</li>
<li><p>添加软连接</p>
<pre><code>sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
</code></pre>
</li>
<li><p>测试docker-compose</p>
<pre><code>docker-compose --version

# 返回
docker-compose version 1.27.4, build 40524192
</code></pre>
</li>
</ul>
<h3 id="安装sentry"><a href="#安装sentry" class="headerlink" title="安装sentry"></a>安装sentry</h3><ul>
<li><p>拉取sentry源码</p>
<pre><code>git clone https://github.com/getsentry/onpremise.git
</code></pre>
</li>
<li><p>执行安装shell文件</p>
<pre><code>cd  onpremise
sudo ./install.sh  
</code></pre>
</li>
</ul>
<p>这个过程会特别久（持续了差不多60分钟~），中间会提示你创建账户与密码<br><img src="./3.png"></p>
<p>安装完毕后，通过docker-compose启用sentry:</p>
<pre><code>  sudo docker-compose up -d
</code></pre>
<p>服务启用成功后界面：</p>
<p><img src="./2.png"></p>
<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>服务默认开启9000端口，可以通过修改onpremise/.env文件中的端口号来修改配置：</p>
<pre><code>SENTRY_BIND=9100  # 修改为9100
</code></pre>
<p>另外<code>config.yml</code>与<code>sentry/sentry.conf.py</code>也都有9000的值，最好一并都修改了</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>因为Sentry整个服务比较占用内存，导致机器内存只剩下170M左右，且访问直接502，为了不影响其他服务，暂时搁浅项目，后续继续研究。配置部分后续有机会再补上，可参照<a href="http://sinhub.cn/2019/07/getting-started-guide-of-sentry/">Sentry 入门实战</a></p>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><p>停止sentry服务及重新打包升级配置</p>
<pre><code>docker-compose stop   # 停止
docker-compose build   # 重新build
docker-compose run --rm web upgrade  # 升级配置

docker-compose up -d 
</code></pre>
<p>查看端口占用</p>
<pre><code>sudo netstat -tanlp               # 所有tcp端口
sudo netstat -tunlp | grep 9100   # 指定端口
</code></pre>
<p>停止docker</p>
<pre><code>sudo systemctl stop docker
</code></pre>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://blog.csdn.net/pushiqiang/article/details/78682323">docker-compose教程</a></li>
<li><a href="https://www.cnblogs.com/yufeng218/p/8370670.html">Centos7上安装docker</a></li>
<li><a href="https://github.com/docker/compose/releases/">docker-compose源码</a></li>
<li><a href="https://github.com/getsentry/sentry">sentry源码</a></li>
<li><a href="https://mp.weixin.qq.com/s/xOLMlpefDPWK6pzJEAVACg">转转商业前端错误监控系统(Sentry)策略升级</a></li>
</ul>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>sentry</tag>
      </tags>
  </entry>
  <entry>
    <title>shell,terminal,TTY与CLI</title>
    <url>/shell,%20terminal,%20TTY%E4%B8%8ECLI/</url>
    <content><![CDATA[<p>作为计算机非科班出身人员，经常会看到shell,terminal,TTY与CLI 这写名字，本文做下对应解释，以防后用</p>
<span id="more"></span>
<h2 id="命令行界面（CLI-command-line-interpreter）"><a href="#命令行界面（CLI-command-line-interpreter）" class="headerlink" title="命令行界面（CLI-command-line interpreter）"></a>命令行界面（CLI-command-line interpreter）</h2><p>命令行界面， 是使用文本命令与计算机进行交互的用户界面，通俗来讲，就是你看过的那种满屏幕都是字符的界面。在熟记命令的前提下，使用命令行界面往往要比使用图形用户界面效率高得多。</p>
<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>大家都知道，操作系统有一个叫做 内核 (Kernel) 的东西，它处于系统的底层，是不能让普通用户随意操作的，于是就需要一个专门的程序，它接受用户输入的命令，然后帮我们与内核沟通，最后让内核完成我们的任务。这个提供用户界面的程序被叫做 Shell (壳层)。</p>
<p>通俗理解的话，就是一个命令解释器（程序），专门解释语句或命令用的。</p>
<p>Unix 及类 Unix 系统下的：sh (Bourne shell)，bash (Bourne-Again shell)，zsh (Z shell)，fish (Friendly interactive shell)等；Windows 下的 cmd.exe (命令提示符) 与 PowerShell,都是shell程序，而这些程序的运行界面就是CLI</p>
<p>可以近似地认为linux shell=bash 而 windows=cmd, 但是二者有着最根本区别：linux shell是个linux 操作系统的用户交互层。而windows下的cmd只是一个小桌面应用，不能脱离图形界面单独存在。bash功能强大，cmd功能十分有限，windows也有强大的shell叫windows powershell</p>
<h2 id="终端-Terminal"><a href="#终端-Terminal" class="headerlink" title="终端 (Terminal)"></a>终端 (Terminal)</h2><p>早期的终端其实就是电传打字机(Teletype / Teletypewriter) ，Unix 的创始人把很多台 ASR-33 连接到计算机上，让每个用户都可以在终端登录并操作主机，从而创造了计算机历史上第一个真正的多用户操作系统 Unix。</p>
<p>电传打字机的英文缩写就是 tty，所以我们可以直接认为终端 (Terminal) = TTY。  </p>
<h3 id="终端与shell"><a href="#终端与shell" class="headerlink" title="终端与shell"></a>终端与shell</h3><p>终端的工作就是：从用户这里接收输入（键盘、鼠标等输入设备），扔给 Shell，然后把 Shell 返回的结果展示给用户（比如通过显示器）。  Shell的工作就是：从终端那里拿到用户输入的命令，解析后交给操作系统内核去执行，并把执行结果返回给终端。</p>
<p>随着计算机技术的发展，传统的终端硬件已被抛弃，我们现在用到的更多是终端模拟器 (Terminal Emulator)</p>
<p>譬如，我们登录阿里云时用的xshell，就可以理解为这一种终端模拟器:</p>
<p><img src="./1.png"></p>
<p>我们通过终端向主机发送命令，命令进入shell,shell 与内核交互，返给终端，终端展示出来，基本就是这个流程。  </p>
<p>而当在linux机器上直接操作时，一般默认进入的是linux的bash程序，此时通过该程序可以直接与内核进行交互（ps:简单理解，linux没有系统容学习过）,当在linux上打开一个terminal时，操作系统会将terminal和shell关联起来，当我们在terminal中输入命令后，shell就负责解释命令</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/sddai/p/9769086.html">命令行界面 (CLI)、终端 (Terminal)、Shell、TTY的区别</a></li>
<li><a href="https://www.zhihu.com/question/328533621/answer/711398711">如何通俗解释shell、kernel、bash、Terminal的关系？ - wrfly的回答 - 知乎</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机相关</category>
      </categories>
      <tags>
        <tag>shell.bash</tag>
      </tags>
  </entry>
  <entry>
    <title>shim 和 polyfill</title>
    <url>/shim%20%E5%92%8C%20polyfill/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文将介绍一下我们在各种项目中见到的 xx.shim.js 和 xx.polyfill.js，这两个文件命名各自有什么含义。</p>
<span id="more"></span>

<h2 id="shim"><a href="#shim" class="headerlink" title="shim"></a>shim</h2><p>Shim 指的是在一个旧的环境中模拟出一个新 API ，而且仅靠旧环境中已有的手段实现，以便所有的浏览器具有相同的行为。主要特征：</p>
<ol>
<li>该 API 存在于现代浏览器中;</li>
<li>浏览器有各自的 API 或 可通过别的 API 实现;</li>
<li>API 的所有方法都被重新实现；</li>
<li>拦截 API 调用，并提供自己的实现；</li>
<li>是一个优雅降级。</li>
</ol>
<h2 id="polyfill"><a href="#polyfill" class="headerlink" title="polyfill"></a>polyfill</h2><p>polyfill 是一段代码(或者插件)，提供了那些开发者们希望浏览器原生提供支持的功能。程序库先检查浏览器是否支持某个API，如果不支持则加载对应的 polyfill。主要特征：</p>
<ol>
<li>是一个浏览器 API 的 Shim;</li>
<li>与浏览器有关;</li>
<li>没有提供新的API，只是在 API 中实现缺少的功能;</li>
<li>以只需要引入 polyfill ，它会静静地工作;</li>
</ol>
<h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><p>shim 是一个库,将不同 api封装成一种，比如 jQuery的 $.ajax 封装了 XMLHttpRequest和 IE用ActiveXObject方式创建xhr对象, 它将一个新的 API 引入到一个旧的环境中,而且仅靠旧环境中已有的手段实现（没有遵循标准API规范，而是又实现了一套）</p>
<p>polyfill也是一个js库，它的做法通常是:先检查浏览器是否支持某个标准 API,如果不支持,就使用旧的技术对浏览器做兼容处理,这样就可以在旧的浏览器上使用新的标准 API。(polyfill 是 shim 的一种,它的 API 是遵循标准的)</p>
<p>这是处理js兼容性问题的两种思路，都可以解决实际问题，但polyfill的设计思想更优秀，首先，不需要额外的学习成本（譬如学习$.ajax的写法），其次，后续浏览器支持标准API后，移除polyfill相关js库即可，不需要做任何其他改动。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.html.cn/archives/8339">javascript术语shim 和 polyfill</a></li>
<li><a href="https://www.jianshu.com/p/ce84169a28f4">shim和polyfill</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>vue系列-1-数据绑定原理</title>
    <url>/vue%E7%B3%BB%E5%88%97-1-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>vue 的数据绑定内部是如何实现的，本文一探究竟。</p>
<span id="more"></span>

<h2 id="VUE设计思想之MVVM模式"><a href="#VUE设计思想之MVVM模式" class="headerlink" title="VUE设计思想之MVVM模式"></a>VUE设计思想之MVVM模式</h2><h3 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h3><p><img src="1.png"></p>
<ol>
<li>view:视图层,对应DOM</li>
<li>model:数据层,就是业务逻辑相关的数据对象(js对象等)</li>
<li>viewModel:连接数据和视图的中间件</li>
</ol>
<h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h3><ol>
<li>在MVVM架构下View和model是不能直接通讯的,需要ViewModel来做通讯。</li>
<li>ViewModel通常要实现一个observer（观察者），当model变化时，通知view层自动更新；当用户操作view层时，通知model层数据变化，这就是实现了数据跟视图的双向绑定。</li>
</ol>
<h3 id="Vue-js与MVVM模型的联系"><a href="#Vue-js与MVVM模型的联系" class="headerlink" title="Vue.js与MVVM模型的联系"></a>Vue.js与MVVM模型的联系</h3><p>可以这样理解vue框架对应MVVM模型关系：</p>
<p><img src="2.png"></p>
<pre><code>Observer相当于Model层：观察vue实例中的data数据，当数据发生变化时，通知Watcher订阅者。

Compile指令解析器位于View层，初始化View的视图，将数据变化与更新函数绑定，传给Watcher订阅者。

Watcher是整个模型的核心，对应ViewModel层，连接Observer和Compile。所有的Watchers存于Dep订阅器中，Watcher将Observer监听到的数据变化对应相应的回调函数，处理数据，反馈给View层更新界面视图。
</code></pre>
<h2 id="数据双向绑定方式"><a href="#数据双向绑定方式" class="headerlink" title="数据双向绑定方式"></a>数据双向绑定方式</h2><p>目前实现数据双向绑定的方式大约有以下几种：</p>
<ol>
<li><p>订阅者-发布者模式（backbone.js）<br>更新数据方式通常做法是 vm.set(‘property’, value)，该方式有点 low，看起来没那么友好</p>
</li>
<li><p>脏值检查（angular.js）</p>
</li>
<li><p>数据劫持（vue.js）<br>Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调（vue3.x 改为proxy实现）</p>
</li>
</ol>
<h2 id="defineProperty-与-proxy-实现数据劫持对比"><a href="#defineProperty-与-proxy-实现数据劫持对比" class="headerlink" title="defineProperty 与 proxy 实现数据劫持对比"></a>defineProperty 与 proxy 实现数据劫持对比</h2><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h3><p>Vue2.x的数据劫持就是利用Object.defineProperty来实现的（vue中可以直接改变data，vue内部的watcher机制会监听到这些数据的变化从而刷新页面，而react则是手动驱使setState去改变内部的state，从而使得页面刷新）  </p>
<p>下面我们简单模拟下数据劫持的过程：</p>
<pre><code>function observe(obj) &#123;
    if (!obj || typeof obj !== &quot;object&quot;) &#123;
      return;
    &#125;
    Object.keys(obj).forEach(function (key) &#123;
      defineReactive(obj, key, obj[key])
    &#125;)
  &#125;

function defineReactive(obj, key, value) &#123;

  observe(value); //监听属性内部对象的变化
  Object.defineProperty(obj, key, &#123;
    enumerable: true,
    configurable: false, //不能删除
    get: function () &#123;
      return value
    &#125;,
    set: function (newVal) &#123;
      console.log(&quot;监听到属性&quot; + key + &quot;变化了&quot;, value + &quot;--&gt;&quot; + newVal);
      value = newVal
    &#125;
  &#125;)
&#125;
const obj = &#123;
  name: &quot;jack&quot;,
  age: &quot;14&quot;,
  desc: &#123;
    job: &quot;coder&quot;,
    worker: &quot;bj&quot;
  &#125;
&#125;
observe(obj)
</code></pre>
<p>我们接下来修改对象的属性</p>
<pre><code>obj.name=&quot;mike&quot;
//监听到属性name变化了 jack--&gt;mike

obj.desc.job=&quot;teacher&quot;
//监听到属性job变化了 coder--&gt;teacher
</code></pre>
<p>这样，便实现了数据的劫持。</p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Vue3.0将放弃Object.defineProperty，改用性能更好的Proxy, 为什么说Proxy的性能比Object.defineProperty更好?原因有如下几点：</p>
<ul>
<li>Object.defineProperty只能监听属性，而Proxy能监听整个对象，省去对非对象或数组类型的劫持，也能做到监听。</li>
<li>Object.defineProperty不能监测到数组变化</li>
</ul>
<p>下面我们用Proxy于Reflect再来简单模拟下数据劫持的过程：</p>
<pre><code>  class Observables&#123;
      constructor(target, handler = &#123;
          set(target, key, value, receiver)&#123;
            console.log(&quot;监听到属性&quot; + key + &quot;变化了&quot;,  &quot;--&gt;&quot; + value);
            return Reflect.set(target, key, value, receiver);
          &#125;
        &#125;)&#123;
        if( this.isObject(target) &amp;&amp; this.isArray(target) )&#123;
          throw new TypeError(&#39;target 不是数组或对象&#39;)
        &#125;

        this._target = JSON.parse( JSON.stringify(target) );  // 避免引用修改  数组不考虑
        this._handler = handler;

        return new Proxy(this._observables(this._target), this._handler);
      &#125;
      isArray(o)&#123;
        return Object.prototype.toString.call(o) === `[object Array]`
      &#125;
      isObject(o)&#123;
        return Object.prototype.toString.call(o) === `[object Object]`
      &#125;
      // 为每一项为Array或者Object类型数据变为代理
      _observables(target)&#123;
          // 遍历对象中的每一项
          for( const key in target )&#123;
            // 如果对象为Object或者Array
            if( this.isObject(target[key]) || this.isArray(target[key]) )&#123;
              // 递归遍历
              this._observables(target[key]);
              // 转为Proxy
              target[key] = new Proxy(target[key], this._handler);
            &#125;
          &#125;
          // 将转换好的target返回出去
          return target;
      &#125;
    &#125;
    const obj = &#123;
        name: &quot;jack&quot;,
        age: &quot;14&quot;,
        desc: &#123;
          job: &quot;coder&quot;,
          worker: &quot;bj&quot;
        &#125;,
        arr:[1,2,4]
  &#125;
  const ob = new Observables(obj);
</code></pre>
<p>我们接下来修改对象的属性：</p>
<pre><code>  ob.name=&quot;Jam&quot;
  // 监听到属性name变化了 --&gt;Jam
  ob.name=&quot;Tom&quot;
  // 监听到属性name变化了 --&gt;Tom
  ob.arr.push(8)
  //监听到属性3变化了 --&gt;8
  //监听到属性length变化了 --&gt;4
</code></pre>
<p>下面简单介绍下vue实现双向绑定的思路：（利用Object.defineProperty 方法和订阅发布模式）</p>
<h2 id="双向绑定模式简易demo"><a href="#双向绑定模式简易demo" class="headerlink" title="双向绑定模式简易demo"></a>双向绑定模式简易demo</h2><p><img src="3.png"></p>
<p>黑色的线代表初始化观察者列表等等，红色的线是活动过程中，Model层的状态改变向View层更新的过程</p>
<h3 id="model层向view层的映射"><a href="#model层向view层的映射" class="headerlink" title="model层向view层的映射"></a>model层向view层的映射</h3><pre><code> //将dom对象转化为文档碎片，同时进行占位符合指令解析

  function domToFragment(node,vm)&#123;
      var fragment=document.createDocumentFragment();
      var children;
      // 注意这里是赋值操作，返回的值为node.firstChild的值，当node.firstChild为null或者undefined时候，循环就会结束
        //对子节点进行编译，并添加到fragment中
      while(children=node.firstChild)&#123;
        //第一步：解析模板
        compile(children,vm)
        // parentNode.append()可以同时传入多个节点或字符串，没有返回值；(有兼容性问题)
        // 而parentNode.appendChild()只能传一个节点，且不直接支持传字符串(需要parentNode.appendChild(document.createTextElement(&#39;字符串&#39;))代替)，返回追加的Node节点
        //第二步：占位符和指令解析
        fragment.append(children);
      &#125;
      return fragment;
  &#125;
  //解析模板-占位符和指令解析
  function compile(node,vm)&#123;
    var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/;
  // 1    Element    一个元素    
  // 2    Attr    一个属性    
  // 3    Text    一个元素的文本内容 或属性    
    if(node.nodeType === 1)&#123;
         var attrs=node.attributes;
         for(var i=0,lens=attrs.length;i&lt;lens;i++)&#123;
           if(attrs[i].nodeName==&quot;f-model&quot;)&#123;
              var bindName=attrs[i].nodeValue;
              node.value=vm.data[bindName]
           &#125;
           node.removeAttribute(&#39;f-model&#39;);
         &#125;
    &#125; else if(node.nodeType === 3)&#123;
          if(reg.test(node.nodeValue))&#123;
                var bindName=RegExp.$1.trim();
                node.nodeValue=vm.data[bindName]
          &#125;
    &#125; 
  &#125;
   function MVVM(option)&#123;
         this.data=option.data;
         var id=option.el;
         var dom=domToFragment(document.getElementById(id),this);
         document.getElementById(id).appendChild(dom);
   &#125;
   new MVVM(&#123;
     el:&quot;app&quot;,
     data:&#123;
       text:&quot;Hello World&quot;
     &#125;
   &#125;)
</code></pre>
<p>上面的代码就简单实现了将输入框内容及文本节点内容与数据绑定。下一步要做的就是数据对象的响应式</p>
<h3 id="model层向view层的动态绑定"><a href="#model层向view层的动态绑定" class="headerlink" title="model层向view层的动态绑定"></a>model层向view层的动态绑定</h3><h4 id="第一步，增加observe，实现view层的数据变化向model层的绑定"><a href="#第一步，增加observe，实现view层的数据变化向model层的绑定" class="headerlink" title="第一步，增加observe，实现view层的数据变化向model层的绑定"></a>第一步，增加observe，实现view层的数据变化向model层的绑定</h4><pre><code>   //观察者对象
  //将所有属性通过Object.defineProperty进行监听
  function observe(obj) &#123;
      if (!obj || typeof obj !== &quot;object&quot;) &#123;
        return;
      &#125;
      Object.keys(obj).forEach(function (key) &#123;
        defineReactive(obj, key, obj[key])
      &#125;)
    &#125;

    function defineReactive(obj, key, value) &#123;

      observe(value); //监听属性内部对象的变化
      Object.defineProperty(obj, key, &#123;
        enumerable: true,
        configurable: false, //不能再定义
        get: function () &#123;
          return value
        &#125;,
        set: function (newVal) &#123;
          console.log(&quot;监听到属性&quot; + key + &quot;变化了&quot;, value + &quot;--&gt;&quot; + newVal);
          value = newVal
        &#125;
      &#125;)
    &#125;
    ....//省略，同上
    function compile(node,vm)&#123;
    ...//省略，同上
    if(node.nodeType === 1)&#123;

          node.addEventListener(&#39;input&#39;,function(e)&#123;
              vm.data[bindName] = e.target.value;
            &#125;);
       &#125;
     ...//省略，同上
     &#125;
    function MVVM(option)&#123;
         ...
         observe(this.data,this)//增加行，应用观察者
         ...
   &#125;
</code></pre>
<h4 id="第二步，增加watcher和pubsub，实现双向绑定（完整代码）"><a href="#第二步，增加watcher和pubsub，实现双向绑定（完整代码）" class="headerlink" title="第二步，增加watcher和pubsub，实现双向绑定（完整代码）"></a>第二步，增加watcher和pubsub，实现双向绑定（完整代码）</h4><pre><code>//订阅发布模式
  function PubSub()&#123;
    this.handlers=[];
  &#125;
  PubSub.prototype=&#123;
    on:function(sub)&#123;
       this.handlers.push(sub)
    &#125;,
    emit:function()&#123;
      //触发所有的订阅者更新
      this.handlers.forEach(function(item)&#123;
        item.update();
      &#125;);
    &#125;
  &#125;

  function Watcher(vm, node, bindname)&#123;
      PubSub.target=this;
      //完成watcher的初始化
      this.name = bindname;
      this.node = node;
      this.vm = vm;
      this.update(); //初次绑定时进行更新
      PubSub.target = null; //保证Dep.target唯一
  &#125;
  Watcher.prototype=&#123;
    get:function()&#123;
        this.value=this.vm.data[this.name]
    &#125;,
    update:function()&#123;
      this.get();
      this.node.nodeValue = this.value;  
    &#125;
  &#125;


   //观察者对象
  //将所有属性通过Object.defineProperty进行监听
  function observe(obj) &#123;
      if (!obj || typeof obj !== &quot;object&quot;) &#123;
        return;
      &#125;
      Object.keys(obj).forEach(function (key) &#123;
        defineReactive(obj, key, obj[key])
      &#125;)
    &#125;

    function defineReactive(obj, key, value) &#123;

      observe(value); //监听属性内部对象的变化
      var _sub = new PubSub();
      Object.defineProperty(obj, key, &#123;
        enumerable: true,
        configurable: false, //不能再定义
        get: function () &#123;
          //PubSub.target存在，将目标元素添加到当前data属性的观察者列表中, 
          // PubSub.target 就是Watcher构造函数本身，订阅函数会将其作为参数添加到订阅列表中，执行时会调用update方法
          if(PubSub.target)&#123;
            _sub.on(PubSub.target)
          &#125;
          return value
        &#125;,
        set: function (newVal) &#123;
          value = newVal;
          //数据更新则触发订阅函数的订阅功能
          _sub.emit()
        &#125;
      &#125;)
    &#125;

  //将dom对象转化为文档碎片，同时进行占位符合指令解析

  function domToFragment(node,vm)&#123;
      var fragment=document.createDocumentFragment();
      var children;
      // 注意这里是赋值操作，返回的值为node.firstChild的值，当node.firstChild为null或者undefined时候，循环就会结束
        //对子节点进行编译，并添加到fragment中
      while(children=node.firstChild)&#123;
        //第一步：解析模板
        compile(children,vm)
        // parentNode.append()可以同时传入多个节点或字符串，没有返回值；(有兼容性问题)
        // 而parentNode.appendChild()只能传一个节点，且不直接支持传字符串(需要parentNode.appendChild(document.createTextElement(&#39;字符串&#39;))代替)，返回追加的Node节点
        //第二步：占位符和指令解析
        fragment.append(children);
      &#125;
      return fragment;
  &#125;
  //解析模板-占位符和指令解析
  function compile(node,vm)&#123;
    var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/;
  // 1    Element    一个元素    
  // 2    Attr    一个属性    
  // 3    Text    一个元素的文本内容 或属性    
    if(node.nodeType === 1)&#123;
         var attrs=node.attributes;
         for(var i=0,lens=attrs.length;i&lt;lens;i++)&#123;
           if(attrs[i].nodeName==&quot;f-model&quot;)&#123;
              var bindName=attrs[i].nodeValue;
              node.value=vm.data[bindName];
              node.addEventListener(&#39;input&#39;,function(e)&#123;
                  vm.data[bindName] = e.target.value;
                &#125;);
              node.removeAttribute(&#39;f-model&#39;);
           &#125;
         &#125;
    &#125; else if(node.nodeType === 3)&#123;
          if(reg.test(node.nodeValue))&#123;
                var bindName=RegExp.$1.trim();
                // node.nodeValue=vm.data[bindName]
                new Watcher(vm, node, bindName); //为该页面元素node生产watcher
          &#125;
    &#125; 
  &#125;
   function MVVM(option)&#123;
         this.data=option.data;
         observe(this.data,this)
         var id=option.el;
         var dom=domToFragment(document.getElementById(id),this);
         document.getElementById(id).appendChild(dom);
   &#125;
   var mv=new MVVM(&#123;
     el:&quot;app&quot;,
     data:&#123;
       text:&quot;Hello World&quot;,
       text2:&quot;yyy&quot;
     &#125;
   &#125;)
</code></pre>
<p>整个双向绑定的流程大致如下： </p>
<ol>
<li>compile解析模板-占位符和指令解析，compile函数创建时对绑定变量进行监听（通过watcher函数）  </li>
<li>watcher函数定义一个update方法，该方法会将数据变化反应在view层。  </li>
<li>observe劫持属性，执行时做了以下几件事：a）通过observe将data内的数据进行劫持；b)监听input事件，change的同时改变data的值；  </li>
<li>observe劫持时，通过订阅发布模式绑定数据，在get时订阅，在set时发布，触发watcher函数的update方法更新。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/itkingone/article/details/79152951">Vue 数据绑定详细原理剖析</a></li>
<li><a href="https://segmentfault.com/a/1190000009397476">Vue.js入门（一）–MVVM框架理解</a></li>
</ul>
]]></content>
      <categories>
        <category>Vue 系列</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>web server开发之nginx</title>
    <url>/web-server%E5%BC%80%E5%8F%91%E4%B9%8Bnginx/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本篇开始，我们详细了解下Web Server（通常也代表http server），以及我们经常看到的，入nginx, tomcat, apache都是什么，都在什么场景下使用。</p>
<span id="more"></span>
<h2 id="HTTP-服务的本质"><a href="#HTTP-服务的本质" class="headerlink" title="HTTP 服务的本质"></a>HTTP 服务的本质</h2><p>HTTP服务器本质上也是一种应用程序——它通常运行在服务器之上，绑定服务器的IP地址并监听某一个tcp端口来接收并处理HTTP请求，这样客户端（一般来说是IE, Firefox，Chrome这样的浏览器）就能够通过HTTP协议来获取服务器上的网页（HTML格式）、文档（PDF格式）、音频（MP4格式）、视频（MOV格式）等等资源。下图描述的就是这一过程</p>
<p><img src="./1.jpg"></p>
<p>不同的语言都有相关类库可以实现简单的HTTP 服务，如 <a href="/web%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B9%8Bkoa2/#%E5%8E%9F%E7%94%9Fnodejs">NodeJs</a> , Python, Java等，它们都能够通过绑定IP地址并监听tcp端口来提供HTTP服务。</p>
<h2 id="Ngixn"><a href="#Ngixn" class="headerlink" title="Ngixn"></a>Ngixn</h2><p>Nginx是一款免费开源的高性能 HTTP 代理服务器及反向代理服务器（Reverse Proxy）产品，同时它还可以提供 IMAP/POP3 邮件代理服务等功能。他是由俄罗斯人Igor Sysoev设计开发的，开发工作从2002年开始，第一次公开发布在2004年10月4日。</p>
<p>特点：</p>
<ul>
<li>使用基于事件驱动架构，性能优秀，支持数以百万级别的 TCP 连接</li>
<li>完全开源，第三方模块层出不穷（这是个开源的时代啊）</li>
<li>跨平台，支持几乎所有常见操作系统</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用yum进行安装（也可以使用源码编译安装，方法自行百度）</p>
<pre><code>yum install nginx
</code></pre>
<p>常用操作：</p>
<pre><code>service nginx start   # 启动Nginx服务

service nginx stop    # 停止Nginx服务

service nginx restart # 重启Nginx服务

service nginx status  # 查看Nginx运行状态

nginx -s reload       # 服务运行中重新加载配置

nginx -s reopen       #重启Nginx

nginx -s reload       #重新加载Nginx配置文件，然后以优雅的方式重启Nginx

nginx -s stop         #强制停止Nginx服务

nginx -s quit         #优雅地停止Nginx服务（即处理完所有请求后再停止服务）

nginx -?,-h           #打开帮助信息

nginx -v              #显示版本信息并退出

nginx -V              #显示版本和配置选项信息，然后退出

nginx -t              #检测配置文件是否有语法错误，然后退出

nginx -T              #检测配置文件是否有语法错误，转储并退出

nginx -q              #在检测配置文件期间屏蔽非错误信息

nginx -p prefix       #设置前缀路径(默认是:/usr/share/nginx/)nginx -c filename #设置配置文件(默认是:/etc/nginx/nginx.conf)

nginx -g directives   #设置配置文件外的全局指令

killall nginx         #杀死所有nginx进程
</code></pre>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>平常使用FQ软件访问Google，Facebook时的过程就是正常代理：客户端请求代理服务器（节点）去访问目标站点，代理服务器将请求到的内容返给客户端。</p>
<p>正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息</p>
<p><img src="./2.jpg"></p>
<p>Webpack-dev-server的proxy用法就属于正向代理模式。</p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>多个客户端给服务器发送的请求，nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，nginx扮演的就是一个反向代理角色</p>
<p><img src="./3.jpg"></p>
<p>一个更通俗的例子就是拨打10086客服，客服总台会将闲置的客服转接给你，客服总台扮演的就是一个反向代理角色。</p>
<p>下面要讲到的负载均衡也是一个反向代理模式。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>将一个应用部署在多台服务器上时，就需要将用户请求进行合理分配，分配到不同的机器进行运行，同时也能保证万一有服务器宕机，其他服务器还可以正常运行，就不会影响用户使用。</p>
<p>Nginx可以通过反向代理来实现负载均衡：</p>
<pre><code>upstream myweb &#123;
  server 192.168.0.111:8080; # 应用服务器1
  server 192.168.0.112:8080; # 应用服务器2
&#125;
server &#123;
  listen 80;
  location / &#123;
    proxy_pass http://myweb;
  &#125;
&#125;
</code></pre>
<h3 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h3><p>对于多个服务部署在一台机器上的时候，我们也可以使用nginx配置虚拟主机，用户通过不同的域名打开不同的服务，就像在访问不同的服务器，</p>
<p>譬如，将<a href="http://www.a.com/">www.a.com</a> 代理到本地3000端口，将admin.a.com 代理到本地4000端口（需要确保两个域名都能解析到同一台机器上）</p>
<pre><code>  server &#123;
      listen       80;
      server_name  www.a.com;
      location / &#123;
        proxy_pass http://localhost:4001; # 对应端口号4001
      &#125;
  &#125;
  server &#123;
      listen       80;
      server_name  admin.a.com;
      location / &#123;
        proxy_pass http://localhost:4002; # 对应端口号4002
      &#125;
  &#125;
</code></pre>
<p>本人的主站就是通过这种方式进行部署(ps:如果该端口已经被其他服务占用，启动nginx会报错)</p>
<h2 id="Apache-amp-Tomcat"><a href="#Apache-amp-Tomcat" class="headerlink" title="Apache &amp; Tomcat"></a>Apache &amp; Tomcat</h2><p>Apache，全称为：Apache HTTP Server Project，是Apache软件基金会下的一个项目；由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件。上世纪就已经开始作为HTTP服务开始大规模运行了。</p>
<p>Tomcat是应用（Java）服务器，它只是一个Servlet(JSP也翻译成Servlet)容器，可以认为是Apache的扩展，但是可以独立于Apache运行。</p>
<h3 id="Nginx-VS-Apache"><a href="#Nginx-VS-Apache" class="headerlink" title="Nginx VS Apache"></a>Nginx VS Apache</h3><ul>
<li>Nginx 配置简洁, Apache 复杂；</li>
<li>Nginx 静态处理性能比 Apache 高 3倍以上；</li>
<li>Apache 对 PHP 支持比较简单，Nginx 需要配合其他后端用；</li>
<li>Apache 的组件比 Nginx 多；</li>
<li>Apache是同步多进程模型，一个连接对应一个进程；nginx是异步的，多个连接（万级别）可以对应一个进程；</li>
<li>Nginx处理静态文件好,耗费内存少；动态请求由apache去做，nginx只适合静态和反向；</li>
<li>Nginx适合做前端服务器，负载性能很好；</li>
<li>Nginx本身就是一个反向代理服务器 ，且支持负载均衡</li>
</ul>
<h2 id="补充：开源许可证"><a href="#补充：开源许可证" class="headerlink" title="补充：开源许可证"></a>补充：开源许可证</h2><p><img src="./1.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://nginx.org/">nginx官网</a></li>
<li><a href="https://www.zhihu.com/question/32212996/answer/87524617">tomcat 与 nginx，apache的区别是什么？David的回答</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/226160943">网络模型底层原理-Nginx</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">如何选择开源许可证-阮一峰</a></li>
</ul>
]]></content>
      <categories>
        <category>Web Server</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>server</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>web开发框架之Egg</title>
    <url>/web%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B9%8BEgg/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前我们介绍过koa了，文本了解下Egg。如官网文档所说：Egg是继承于Koa, 对于企业级应用koa还略显单薄，Egg将koa作为基础框架，在它的模型基础上做了一些增强。</p>
<span id="more"></span>

<h2 id="项目脚手架"><a href="#项目脚手架" class="headerlink" title="项目脚手架"></a>项目脚手架</h2><p>Egg官网有配套的脚手架，用于快速初始化egg项目</p>
<pre><code>npm init egg --type=simple
</code></pre>
<p>关于此脚手架的执行原理，可参照：<a href="/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84npm%20init/">你不知道的npm init</a></p>
<h2 id="Egg-VS-Koa"><a href="#Egg-VS-Koa" class="headerlink" title="Egg VS Koa"></a>Egg VS Koa</h2><p>如官网介绍Egg是以Koa作为基础进行增加开发的，相比Koa,它作了很多约定与限制，使用的时候只需在对应目录撰写对应逻辑即可。</p>
<p>由框架约定的目录：</p>
<pre><code>app/router.js 用于配置 URL 路由规则，具体参见 Router。
app/controller/** 用于解析用户的输入，处理后返回相应的结果，具体参见 Controller。
app/service/** 用于编写业务逻辑层，可选，建议使用，具体参见 Service。
app/middleware/** 用于编写中间件，可选，具体参见 Middleware。
app/public/** 用于放置静态资源，可选，具体参见内置插件 egg-static。
app/extend/** 用于框架的扩展，可选，具体参见框架扩展。
config/config.&#123;env&#125;.js 用于编写配置文件，具体参见配置。
config/plugin.js 用于配置需要加载的插件，具体参见插件。
test/** 用于单元测试，具体参见单元测试。
app.js 和 agent.js 用于自定义启动时的初始化工作，可选，具体参见启动自定义。关于agent.js的作用参见Agent机制。
</code></pre>
<p>由内置插件约定的目录：</p>
<pre><code>app/public/** 用于放置静态资源，可选，具体参见内置插件 egg-static。
app/schedule/** 用于定时任务，可选，具体参见定时任务。
</code></pre>
<p>引用插件时，安装完毕后，在<code>config/plugin.js</code> 中声明即可：</p>
<pre><code>  mongoose: &#123;
    enable: true,
    package: &#39;egg-mongoose&#39;,
  &#125;
</code></pre>
<p>对应配置项在<code>config/config.default.js</code>中编写：</p>
<pre><code> mongoose: &#123;
  clients: &#123;
    mallDB: &#123;
      url: &#39;mongodb://localhost:27017/mall&#39;,
      options: &#123;&#125;,
    &#125;,
    mangeDB: &#123;
      url: &#39;mongodb://localhost:27017/manage&#39;,
      options: &#123;&#125;,
    &#125;,
  &#125;,
&#125;
</code></pre>
<p>按照官网建议，<code>app/controller</code>下的控制器只对输入输出做处理，业务相关逻辑放到<code>app/service</code>下：</p>
<pre><code>  ├─service
  |  ├─address.js 
  |  ├─goods.js 
  |  ├─order.js
  |  └user.js  
</code></pre>
<p>service继承<code>require(&#39;egg&#39;).Service</code>, 函数接受到参数后，进行相关数据库操作，最终返回执行结果，在控制器中只需要调用即可。</p>
<pre><code>ctx.body = await ctx.service.address.detail(u_name, a_id)
</code></pre>
<p>这样做的优点是条理更加清晰，对大型项目来说，是非常有利的。</p>
<p>下面介绍几个自己在使用中发现的几处不同于koa的地方</p>
<h2 id="egg-mongoose"><a href="#egg-mongoose" class="headerlink" title="egg-mongoose"></a>egg-mongoose</h2><p>该模块用来实现egg连接mongodb，model定义在<code>app/model</code>文件夹下</p>
<pre><code>  // app/model

  ├─model
  |  ├─address.js 
  |  ├─banner.js 
  |  ├─goods.js 
  |  ├─order.js
  |  └user.js        
</code></pre>
<p>在 <code>app/controller</code>（控制器）下使用方式为：</p>
<pre><code>  ctx.model.address.xxx
</code></pre>
<p>打印下ctx.model看运行结果：</p>
<pre><code>&#123; 
  Address: Model &#123; Address &#125;,
  Banner: Model &#123; Banner &#125;,
  Goods: Model &#123; Good &#125;,
  Order: Model &#123; Order &#125;,
  User: Model &#123; User &#125; 
&#125;
</code></pre>
<p>可以得知：<code>Address</code>是<code>model/address.js</code>文件名（首字母大写），Model模型名称对应的是mongodb集合名称（会自动添加复数s）</p>
<h2 id="egg-jwt"><a href="#egg-jwt" class="headerlink" title="egg-jwt"></a>egg-jwt</h2><p>jsonwebtoken使用该模块，需要校验的路由地址，需要在<code>app/router.js</code>中指定，不指定则不校验</p>
<pre><code>  router.get(/^\/index\//, controller.index.index)   // index开头的路由全部指向到同一个模板文件
      .post(&#39;/api/user/register&#39;, controller.user.register)
      .post(&#39;/api/user/login&#39;, controller.user.login)
      .post(&#39;/api/user/info&#39;, jwt, controller.user.info)  //校验token
</code></pre>
<p>也可以在中间件中指定哪些接口需要校验token（指定返回内容）</p>
<pre><code>// app/middleware/auth.js 下

module.exports = (options, app) =&gt; &#123;
  return async function(ctx, next) &#123;
    const url = ctx.url;
    // 校验所有api下接口
    if (ctx.url.match(/^\/api\//) &amp;&amp; !app.config.URL_PASS_LOGIN.includes(url)) &#123;
      const token = (ctx.get(&#39;Authorization&#39;) || &#39;&#39;).replace(/^Bearer /, &#39;&#39;);
      if (!token) &#123;
        ctx.response.body = &#123;
          code: 2001,
          message: &#39;未登录，请登录！&#39;,
        &#125;;
        return;
      &#125;
    &#125;
    // 校验token
    const u_name = await app.jwt.verify(token, app.config.jwt.secret);
    // do something 
    await next();
  &#125;
&#125;
</code></pre>
<p>前端发送xmlhttprequest请求时需要指定header</p>
<pre><code>  config.headers[&#39;Authorization&#39;] =`Bearer $&#123;token&#125;`
</code></pre>
<p>默认token无效时会返回状态码401，需要在拦截器的error中做对应跳转处理</p>
<pre><code>  error =&gt; &#123;
    if(error.response.status === 401)&#123;
      window.location.replace(`/index/login?from=$&#123;encodeURIComponent(window.location.pathname+window.location.search)&#125;`)
      return Promise.reject();
    &#125;
  &#125;
  
</code></pre>
<p>也可以在中间件中自定义返回参数。</p>
<h2 id="security"><a href="#security" class="headerlink" title="security"></a>security</h2><p>对于post请求，Egg内置了安全插件<a href="https://github.com/eggjs/egg-security">egg-security</a>,可以临时进行关闭，但是不推荐这么做：</p>
<pre><code>  security: &#123;
    csrf: false,
  &#125;
</code></pre>
<p>按照egg-security插件的要求，每次访问时候，会在cookie中写入一个安全校验值csrfToken，前端在请求时带上即可：</p>
<p>首先修改config/default.config.js文件：</p>
<pre><code>security: &#123;
  csrf: &#123;
    headerName: &#39;x-csrf-token&#39;, // 自定义请求头
  &#125;,
&#125;
</code></pre>
<p>前端修改对应拦截器，加入：</p>
<pre><code>config.headers[&#39;x-csrf-token&#39;]=getCookie(&#39;csrfToken&#39;); // getCookie方法自行定义
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Egg扩展性与封装性都比较高，本身设计的初衷就是便于大型项目开发，所以约定与规范相比koa也没那么自由，毕竟二者应用场景不一样，各位按需选用即可。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://eggjs.org/zh-cn/intro/index.html">Egg.js官网文档</a></li>
<li><a href="https://github.com/eggjs/egg-mongoose">egg-mongoose</a></li>
<li><a href="https://github.com/eggjs/egg-static">egg-static</a></li>
<li><a href="https://github.com/eggjs/egg-jwt">egg-jwt</a></li>
<li><a href="https://github.com/eggjs/egg-view-nunjucks">egg-view-nunjucks</a></li>
<li><a href="https://blog.csdn.net/weixin_44934525/article/details/109163957">Egg.js使用egg-jwt实现鉴权登录(适合新手)</a></li>
<li><a href="https://github.com/Ouchuxuan/egg-xiaomi-shop">Egg仿小米商城</a></li>
</ul>
]]></content>
      <categories>
        <category>Web框架</category>
      </categories>
      <tags>
        <tag>koa</tag>
        <tag>egg</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>web开发框架之koa2</title>
    <url>/web%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B9%8Bkoa2/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Nodejs天生就是异步操作，非阻塞I/O操作，使得它在服务端有着一些其他语言没有的天生优势。那么如何创建Web Server？koa2也用了两年，主要用来在服务端搭建web服务（编写spa主模板路由，api反向代理等简单功能），也未系统学习过。它跟Egg.js又各自有什么优缺点，最近正好有时间，从头细致捋一遍koa，并与egg做下对比。</p>
<span id="more"></span>

<h2 id="原生nodejs"><a href="#原生nodejs" class="headerlink" title="原生nodejs"></a>原生nodejs</h2><p>框架只是nodejs底层api的再封装，我们使用nodejs的api可以很简单的实现一个web server:</p>
<pre><code>const http=require(&quot;http&quot;)
var url = require(&#39;url&#39;);
http.createServer((req,res)=&gt;&#123;
  res.writeHead(200, &#123;&#39;Content-Type&#39;: &#39;text/plain&#39;&#125;);
  var pathname = url.parse(req.url, true).pathname;
  if(pathname==&quot;/list&quot;)&#123;
    res.write(&#39;I am list&#39;)
  &#125;else&#123;
    res.write(&#39;I am home&#39;)
  &#125;
  res.end()
&#125;).listen(8008,()=&gt;&#123;
  console.log(&#39;web server started at port 8008&#39;)
&#125;)
</code></pre>
<p>运行一下，访问<a href="http://localhost:8008/">http://localhost:8008/</a> 与 <a href="http://localhost:8008/list">http://localhost:8008/list</a> 分别返回不用的内容。</p>
<p>但实际应用中不会这么简单，如何处理本地静态文件，如何解析get/post请求参数与返回内容，如何管理路由，如何管理cookie等等，都是需要考虑的。于是就出现了web server 框架, 其中最著名的当属express</p>
<h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p>Express 是一个最小且灵活的 Node.js Web 应用框架，它为 Web 和移动应用程序提供一组强大的功能。但由于初期nodejs对异步的解决方案基本都是通过callback实现的，async/await还未纳入官方方案，于是就有了最臭名昭著的<a href="http://callbackhell.com/">callback hell</a>。</p>
<p>于是，Express 幕后原班人马重新打造了新的web 框架–Koa</p>
<h2 id="koa基本组成"><a href="#koa基本组成" class="headerlink" title="koa基本组成"></a>koa基本组成</h2><p>Koa源码非常精简，只有四个文件：</p>
<ul>
<li>application.js：Application(或Koa)负责管理中间件，以及处理请求</li>
<li>context.js：Context维护了一个请求的上下文环境</li>
<li>request.js：Request对<code>req</code>做了抽象和封装</li>
<li>response.js：Response对<code>res</code>做了抽象和封装 </li>
</ul>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>Koa2本身只能算一个极简的HTTP服务器，自身不内置中间件，但是提供中间件内核。我们可以把一个HTTP请求理解为水流，而各种各样的中间件类似各种管道，它会对水流进行处理。每个中间件在HTTP请求过程中会改写请求，响应等数据。koa的中间件模型就是经常被提起的“洋葱模型”</p>
<p><img src="2.jpg"></p>
<h3 id="理解中间件"><a href="#理解中间件" class="headerlink" title="理解中间件"></a>理解中间件</h3><p>中间件是按顺序执行, 从第一个中间件开始执行，遇到<code>next</code>进入下一个中间件，一直执行到最后一个中间件，在逆序，执行上一个中间件<code>next</code>之后的代码，一直到第一个中间件执行结束才发出响应。以下面代码为例，会更容易理解：</p>
<pre><code>// app.js
const Koa = require(&#39;koa&#39;)
const app = new Koa()
app.use(async (ctx, next) =&gt; &#123;
  console.log(1);
  await next();
  console.log(1.1);
&#125;);

app.use(async (ctx, next) =&gt; &#123;
  console.log(2);
  await next();
  console.log(2.2);
&#125;);

app.use(async (ctx, next) =&gt; &#123;
  console.log(3);
  await next();
  console.log(3.3);
&#125;);

module.exports = app
</code></pre>
<p>启动后，通过浏览器访问 <code>http://localhost:3000/</code>, 控制台会出现如下结果（其实会发出2个请求，因为加载首页html时，也会加载一次favicon.ico文件）</p>
<pre><code>1
2
3
3.3
2.2
1.1
</code></pre>
<p>中间件包含两个参数 ctx, next。</p>
<h3 id="Koa-router"><a href="#Koa-router" class="headerlink" title="Koa-router"></a>Koa-router</h3><p>Koa-router 是 koa 的一个路由中间件，它可以将请求的URL和方法（如：GET 、 POST 、 PUT 、 DELETE 等） 匹配到对应的响应程序或页面。</p>
<pre><code>// routes/index.js

const router = require(&#39;koa-router&#39;)()

router.get(&#39;/&#39;, async (ctx, next) =&gt; &#123;
  await ctx.render(&#39;index&#39;, &#123;
    title: &#39;Hello Koa 2!&#39;
  &#125;)
&#125;)
module.exports = router
</code></pre>
<p>接着还需要分别调用 router.routes() 和 router.allowedMethods() 来得到两个中间件，并且调用 app.use() 使用这两个中间件：</p>
<pre><code>const index = require(&#39;./routes/index&#39;) 
app.use(index.routes()).use(index.allowedMethods())
</code></pre>
<p>注意，此处关于路由的调用，<a href="https://github.com/i5ting/koa-generator">koa-generator</a> 中的代码如下:</p>
<pre><code>// routes
app.use(index.routes(), index.allowedMethods())
</code></pre>
<p>但通过查阅koa源码，app.use只接收一个参数，第二个参数是无效的：</p>
<p><img src="4.png"></p>
<p>也有人在<a href="https://github.com/i5ting/koa-generator/issues/57">issue区</a>提了同样的问题，然而无人回答。所以本人做了修改。同时根据自己常用的一些中间件，做了一个项目模板：<a href="https://github.com/wangminghuan/koa2-template">koa2-template</a></p>
<h3 id="上下文对象"><a href="#上下文对象" class="headerlink" title="上下文对象"></a>上下文对象</h3><p>Koa Context 将 node 的 request 和 response 对象封装到单个对象中，ctx是一次完整的HTTP请求的上下文，会贯穿这个请求的生命周期。也就是说在整个请求阶段都是共享的。</p>
<p>我们打印下上面例子中的第一个中间件：</p>
<pre><code>app.use(async (ctx, next) =&gt; &#123;
  console.log(1);
  console.log([ctx.request.url,ctx.response])
  await next();
  console.log([ctx.request.url,ctx.response])
  console.log(1.1);
&#125;);
</code></pre>
<p>启动后，通过浏览器访问 <code>http://localhost:3000/</code>, 控制台会出现如下结果:</p>
<pre><code>1
[ &#39;/json&#39;,
  &#123; status: 404,
    message: &#39;Not Found&#39;,
    header: [Object: null prototype] &#123;&#125;,
    body: undefined &#125; ]
2
3
3.3
2.2
[ &#39;/json&#39;,
  &#123; status: 200,
    message: &#39;OK&#39;,
    header:
    [Object: null prototype] &#123; &#39;content-type&#39;: &#39;application/json; charset=utf-8&#39; &#125;,
    body: &#123; code: 0, data: &#123;&#125; &#125; &#125; ]
1.1
</code></pre>
<p>结合“洋葱图”可以看到，在中间件中都是可以访问到ctx对象的，在创建 context 的时候，还会同时创建 request 和 response 。只不过进入“洋葱”时只有request数据内容；在穿出“洋葱”时，ctx对象的response才有了相关数据。</p>
<h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>koa官方并没有相关脚手架可以快速初始化项目，此处推荐狼叔的 koa-generator, 我在此基础上做了一些修改，提交到了该仓库：<a href="https://github.com/wangminghuan/koa2-template">koa-template</a></p>
<h2 id="用户认证方案"><a href="#用户认证方案" class="headerlink" title="用户认证方案"></a>用户认证方案</h2><p>服务端服务离不开用户认证，早期常用的方法是：</p>
<ul>
<li>用户输入用户名+密码提交登录</li>
<li>服务端认证通过后下发session_id,将cookie写入用户端</li>
<li>用户端每次请求都会携带这个cookie,服务端通过cookie(session_id)查找用户信息从而判断用户身份</li>
</ul>
<p>这个流程在单台机器上没有什么问题，一旦遇到服务器集群就有问题了，这就要求不同机器之间的session共享，做session数据持久化，工程量比较巨大，除此之外还有另外一种方案就是jwt</p>
<h3 id="jwt"><a href="#jwt" class="headerlink" title="jwt"></a>jwt</h3><p>jwt 全称为<code>JSON web token</code>,目前最流行的跨域认证解决方案。</p>
<p>jwt的大体流程如下：</p>
<ul>
<li>用户输入用户名+密码提交登录</li>
<li>服务端认证通过后，下发用户信息（json）返给用户</li>
<li>用户每次请求都带上这个json数据，服务端完全靠这个对象认证用户身份</li>
<li>为了防止篡改，这个json对象一般都需要签名加密（具体签名规格参考下面阮一峰博客）</li>
</ul>
<p>这样做的好处是服务端完全不需要存储session数据，服务端变成无状态的了。但也有一个比较大的弊端：由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p>
<h3 id="jsonwebtoken"><a href="#jsonwebtoken" class="headerlink" title="jsonwebtoken"></a>jsonwebtoken</h3><p>koa中我们使用<code>jsonwebtoken</code>模块, 并将其作为中间件来运行,先定义一个check_token方法：</p>
<pre><code>// config/token.js

const check_token=async (ctx,next)=&gt;&#123;
  const url = ctx.url;
  if(ctx.method != &#39;GET&#39;  &amp;&amp; !URL_PASS_LOGIN.includes(url))&#123;
  let token= ctx.get(&quot;Authorization&quot;);
  if(!token)&#123;
    return ctx.response.body=&#123;
      code:2001,
      message:&quot;未登录，请登录！&quot;
    &#125;
  &#125;
  let &#123;name = &#39;&#39;&#125; = await jwt.verify(token,TOKEN_ENCODE_STR);
  // do something...
&#125;
  await next();
&#125;
</code></pre>
<p>在app.js中进行调用，注意执行顺序(router注册之前)</p>
<pre><code>  // checkToken
  app.use(check_token);

  // routes
  app.use(index.routes(), index.allowedMethods())
</code></pre>
<h2 id="Mongoose"><a href="#Mongoose" class="headerlink" title="Mongoose"></a>Mongoose</h2><p>koa中我们使用Mongoose来连接数据库</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><pre><code>const mongoose = require(&#39;mongoose&#39;);
// 此处链接的是数据库，如果不存在会自动创建,有则直接连接
mongoose.connect(&#39;mongodb://localhost:27017/mall&#39;,&#123; useNewUrlParser: true &#125;).then(
  () =&gt; &#123; 
    console.log(&quot;Connection success~&quot;)
  &#125;,
  err =&gt; &#123; 
    console.log(err)
  &#125;
);
</code></pre>
<p>如果需要用户名密码登陆，则连接地址为：</p>
<pre><code>mongodb://username:password@localhost:27017/mall
</code></pre>
<p>如果mall数据库没有设置管理员，需要使用admin数据库的管理员进行间接操作，则连接地址为</p>
<pre><code>mongodb://username:password@localhost:27017/mall?authSource=admin
</code></pre>
<h3 id="Shema"><a href="#Shema" class="headerlink" title="Shema"></a>Shema</h3><p>Shema即XML Schema，XSD (XML Schema Definition)是W3C于2001年5月发布的推荐标准，指出如何形式描述XML文档的元素。</p>
<p>Mongoose 的一切始于 Schema。每个 schema 都会映射到一个 MongoDB collection，创建集合之前，需要先实例化一个Shema</p>
<pre><code>// db/index.js
const Schema = mongoose.Schema; 
let userSchema = new Schema(&#123;
  u_name: String,
  u_pwd: String,
  u_code: String,
  token: &#123;
    type: String,
    default: &quot;&quot;
  &#125;
&#125;)
</code></pre>
<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>将上一步的schema，通过<code>mongoose.model(modelName, schema)</code> 函数转换为一个 Model</p>
<pre><code> // db/index.js
// 第一个参数是跟 model 对应的集合（ collection ）名字的 单数 形式，
mongoose.model(&#39;User&#39;, userSchema); // 会自动创建一张users集合（表）
</code></pre>
<h3 id="Documents"><a href="#Documents" class="headerlink" title="Documents"></a>Documents</h3><p>Documents是Model的实例，如果需要新建集合，只需要实例化Model, 并调用save即可：</p>
<pre><code>// service/user.js

const User = require(&#39;../db&#39;).User;

let user = new User(&#123;u_name,u_pwd,u_code,token&#125;);
let resp = await user.save();
</code></pre>
<h3 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h3><p>常用的增删改查方法有些是挂载在<code>Model.prototype</code>下，有些是挂载在<code>Model</code>下的，类似这样（代码仅为示意图，不代表Model的具体实现）</p>
<pre><code>class Model&#123;
  constructor() &#123;
  &#125;
  save() &#123;
    return &#39;save&#39;;
  &#125;
&#125;
Model.update=function()&#123;
  return &#39;update&#39;
&#125;
const m=new Model();
console.log(m.save()); //&#39;save&#39;
console.log(Model.prototype.save());//&#39;save&#39;
console.log(Model.update()); //&#39;update&#39;
</code></pre>
<p>具体如截图所示（来源mongoose官网V5.10.16）</p>
<p>   <img src="./5.png"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="koa-views"><a href="#koa-views" class="headerlink" title="koa-views"></a>koa-views</h3><p>在koa2中使用模板机制必须依靠中间件，最常用的便是koa-views</p>
<pre><code>// 加载模板引擎
const views = require(&#39;koa-views&#39;)
app.use(views(path.join(__dirname, &#39;./views&#39;), &#123;
    extension: &#39;ejs&#39;
&#125;))
</code></pre>
<p>如果需要模板引擎则需要额外安装ejs,或pug,在extension声明即可</p>
<h3 id="koa-static"><a href="#koa-static" class="headerlink" title="koa-static"></a>koa-static</h3><p>koa-static是静态资源请求中间件，不涉及其他的处理过程，只是单纯的读取文件</p>
<pre><code>app.use(require(&#39;koa-static&#39;)(__dirname + &#39;/source/dist&#39;))
</code></pre>
<h3 id="koa-body"><a href="#koa-body" class="headerlink" title="koa-body"></a>koa-body</h3><p>服务端收到请求时，需要对参数做对应解析（query，form, multipart）等，koa-body就是出来处理这些的：</p>
<p>  const koaBody = require(‘koa-body’)<br>  app.use(koaBody({<br>    multipart:true<br>  }))</p>
<p>koa-generator 中推荐的是 koa-bodyparser 但其不支持文件上传，koa-body用法与koa-bodyparser基本一致，且支持文件类型解析</p>
<h3 id="koa-router"><a href="#koa-router" class="headerlink" title="koa-router"></a>koa-router</h3><p>顾名思义，这是koa的路由中间件，也是非常重要的一部分，有兴趣的可以详细去了解，此处我们只简单介绍下使用方式：</p>
<pre><code>// routes/index.js

const router = require(&#39;koa-router&#39;)()
const controller = require(&#39;../controller&#39;)
router.get(&#39;/&#39;, async (ctx, next) =&gt; &#123;
  await ctx.render(&#39;index&#39;)
&#125;)
.post(&quot;/api/user/login&quot;,controller.user.login)
.post(&quot;/api/common/upload&quot;,controller.common.upload)
</code></pre>
<p>在app.js中注册，注意执行顺序（一般在最后）</p>
<pre><code>const index = require(&#39;./routes/index&#39;)
app.use(index.routes(), index.allowedMethods())
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jianshu.com/p/6f7930687835">NodeJS框架Expres与Koa</a></li>
<li><a href="https://www.jianshu.com/p/b4335b482fc6">Expres与Koa对比</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/150700836">知乎专栏-Koa2第二篇：中间件</a></li>
<li><a href="https://www.jianshu.com/p/c76d9ffd7899">简书-koa洋葱模型</a></li>
<li><a href="https://www.jianshu.com/p/fef91266a44c">koa-router allowedMethods</a></li>
<li><a href="https://koa.bootcss.com/">koa-官网文档</a></li>
<li><a href="https://github.com/koajs/koa">koa-github</a></li>
<li><a href="https://github.com/koajs/koa/wiki">koa-middleware官网列表</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">json-web-token 入门教程</a></li>
<li><a href="http://mongoosejs.net/docs/guide.html">mongoose官网文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Web框架</category>
      </categories>
      <tags>
        <tag>koa</tag>
        <tag>express</tag>
        <tag>koa2</tag>
      </tags>
  </entry>
  <entry>
    <title>web抓包中的那些事</title>
    <url>/web%E6%8A%93%E5%8C%85%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<p>作为web开发人员，相信大家都知道利用Fiddler/Charles等工具进行抓包，那这些抓包工具的原理是什么，对于某些APP为何抓不到请求，本文会记录一些在抓包工程中遇到的一些问题与解决方法</p>
<span id="more"></span>
<h2 id="配置抓包工具"><a href="#配置抓包工具" class="headerlink" title="配置抓包工具"></a>配置抓包工具</h2><p>以常用的抓包工具:Fiddler(只支持windows)以及Charles(支持Windows,Macos,Linux)为例（ps: charles为收费软件，破解可访问<a href="https://www.zzzmode.com/mytools/charles/">Charles 激活码计算器</a>）, 只需要简单配置即可抓取http/https，具体可参考：<a href="https://www.jianshu.com/p/9e05a2522758">Fiddler抓包简易教程</a> 和 <a href="https://www.jianshu.com/p/5539599c7a25">十分钟学会Charles抓包(iOS的http/https请求)</a>。这里不再赘述。</p>
<h2 id="代理抓包原理"><a href="#代理抓包原理" class="headerlink" title="代理抓包原理"></a>代理抓包原理</h2><p>启动Fiddler 或 Charles就是启动了一个HTTP代理服务器, 这个时候运行在系统上的http客户端再去发送请求的时候，它就不会再去进行DNS解析，而是直接连接系统告诉他代理所在的地址，这样代理服务器会与客户端建立连接，再然后代理服务器根据请求信息再去连接真正的服务器：</p>
<p><img src="./1.png"></p>
<p>Fiddler 或 Charles充当的就是中间人（MITM）。但随着爬虫在手机端的日益盛行，越来越多的APP无法通过中间人模式进行抓包了，这又是为何？</p>
<h2 id="无法抓包的原因"><a href="#无法抓包的原因" class="headerlink" title="无法抓包的原因"></a>无法抓包的原因</h2><p>总所周知，http协议作为应用层协议，在各端都有自己的实现，也就是说开发人员可以自己实现自己的http客户端，如android上最有名的okhttp 就是一个http客户端的实现。所以app中的http协议也可以不使用系统代理，在okhttp中我们可以这样设置：</p>
<pre><code>builder.proxy(Proxy.NO_PROXY);
</code></pre>
<p>Flutter中也默认不会主动使用系统代理，需要单独设置，这样就绕开了系统代理，如何破局？</p>
<h2 id="其他抓包方式"><a href="#其他抓包方式" class="headerlink" title="其他抓包方式"></a>其他抓包方式</h2><p>除了Fiddler 、Charles，Wireshark也是经常被人提到的，它可以捕获机器上的某一块网卡的网络包，不止HTTP请求，其他网络请求也会被捕获到，所以为了捕获特定请求需要自定义一个很长的过滤列表，对新手不是很友好。</p>
<p>另外，也可以使用VPN。VPN是构造了一个虚拟专用网络，实际上也是一种特殊的代理服务器，不过是在操作系统级别设置。VPN连接捕获其配置的设备的整个网络连接，也可以看作虚拟网卡，它会监控虚拟网卡上的所有请求（不只是HTTP请求），如安卓上的Packet Capture（无需root）：</p>
<p><img src="./3.png"><br><img src="./2.png"></p>
<p>不过这样抓到包不太好分析，于是有了另外一种方案：Drony+ Fiddler/Charles, Drony也是一款VPN软件，不过他可以将手机上的所有流量都重定向到drony自身，然后再将流量转发到Fiddler/Charles等代理服务器上去实现抓包（自己测试了很久一直没成功，最终只好放弃了）</p>
<h2 id="HTTPS加密基本原理"><a href="#HTTPS加密基本原理" class="headerlink" title="HTTPS加密基本原理"></a>HTTPS加密基本原理</h2><p>广义上你可以简单理解HTTPS = HTTP + TLS/SSL，但实际原理复杂很多。</p>
<p>http是明文传输，很容易被第三方“窃听”与“篡改”，所以要进行加密传输。最常见的算法就是对称加密，同一个密钥用来加密与解密，但这样密钥在传输过程很容易被“窃取”，所以加入了非对称加密算法：公钥与私钥（公钥加密的数据只有私钥才能解开，反义亦然），非对称加密虽然加密度高，但算法相对复杂，加密解密过程比较耗时，所以建立真正的连接之前会先进行三次握手，握手成功后就开始利用对称加密进行数据传输，流程如下：（服务端保存着唯一的私钥）：</p>
<p><img src="./4.png"></p>
<p>等等，这样就完美了吗？中间人模式可以完美避开（Fiddler/Charles的代理模式），中间人也有着自己的公钥与私钥，在客户端与服务端交换过程中做手脚：</p>
<p><img src="./5.png"></p>
<p>为了解决此问题，引入了数字证书的概念。服务器首先生成公私钥，将公钥提供给相关机构（CA），CA将公钥放入数字证书并将数字证书颁布给服务器。当客户端发起 HTTPS 请求时，服务器会返回站点的 SSL 证书，浏览器会对证书做：颁发机构信息、公钥、公司信息、域名、有效期、指纹等等一系列验证通过后，才会进行下一步获取非对称公钥操作。  </p>
<p>所以，HTTPS相当于：非对称加密算法（公钥和私钥）+ 数字证书验证身份 + 称密钥加解密后续传输的数据。</p>
<p>这也就是为什么要实现Fiddler/Charles的HTTPS抓包功能，就需要先将证书手动导入到受信任的CA机构下，否则无法实现抓包的原因。</p>
<h2 id="Chrome禁用代理模式"><a href="#Chrome禁用代理模式" class="headerlink" title="Chrome禁用代理模式"></a>Chrome禁用代理模式</h2><p>没事翻了下文档，发现chrome也支持禁用代理模式，启动时添加运行参数：<code>--no-proxy-server</code>，那么对于electron桌面应用可以再app实例ready之前设置：</p>
<pre><code>app.commandLine.appendSwitch(&#39;no-proxy-server&#39;)
</code></pre>
<p>即可禁用代理模式</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/139645460">知乎-抓包那点事</a></li>
<li><a href="https://juejin.cn/post/6860818685763223565">还在为大厂app抓不到包而犯愁吗？</a></li>
<li><a href="https://www.cnblogs.com/lulianqi/p/11380794.html">部分APP无法代理抓包的原因及解决方法（flutter 抓包）</a></li>
<li><a href="https://www.electronjs.org/docs/api/command-line-switches#supported-command-line-switches">Electron 支持的命令行开关</a></li>
</ul>
]]></content>
      <categories>
        <category>Web调试</category>
      </categories>
      <tags>
        <tag>抓包</tag>
        <tag>Fiddler</tag>
        <tag>charles</tag>
      </tags>
  </entry>
  <entry>
    <title>从浏览器API看WEB标准</title>
    <url>/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8API%E7%9C%8BWEB%E6%A0%87%E5%87%86/</url>
    <content><![CDATA[<h2 id="客户端JavaScript中的API"><a href="#客户端JavaScript中的API" class="headerlink" title="客户端JavaScript中的API"></a>客户端JavaScript中的API</h2><p>客户端JavaScript中有很多可用的API — 他们本身并不是JavaScript语言的一部分，却建立在JavaScript语言核心的顶部（window），为使用JavaScript代码提供额外的超强能力。他们通常分为两类：</p>
<ul>
<li>浏览器API：内置于Web浏览器中，能从浏览器和电脑周边环境中提取数据，并用来做有用的复杂的事情 。如:Geolocation API</li>
<li>第三方API: 缺省情况下不会内置于浏览器中，是在某些情况下执行后挂载在全局window下</li>
</ul>
<p>那么，我们每天使用的浏览器，里面到底有多少“API”?</p>
<span id="more"></span>

<h2 id="常见的浏览器API"><a href="#常见的浏览器API" class="headerlink" title="常见的浏览器API"></a>常见的浏览器API</h2><ul>
<li>操作文档的API内置于浏览器中。最明显的例子是DOM</li>
<li>从服务器获取数据的API: 如：XMLHttpRequest和Fetch API。</li>
<li>用于绘制和操作图形的API:如：Canvas和WebGL</li>
<li>音频和视频API，如：HTMLMediaElement</li>
<li>设备API：Geolocation API</li>
<li>客户端存储API： Web Storage API 和 IndexedDB API</li>
</ul>
<h2 id="浏览器下所有API整理"><a href="#浏览器下所有API整理" class="headerlink" title="浏览器下所有API整理"></a>浏览器下所有API整理</h2><p>大部分的浏览器 API 属于 Window 对象（或者说全局对象）,以windows下chrome 为例(Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36”), 运行 <code>Object.getOwnPropertyNames(window)</code>, 得到909个API。</p>
<p>对这些api进一步梳理得到：  </p>
<p>W3C 标准下的 API：</p>
<ul>
<li>Web Audio API</li>
<li>Web Cryptography API</li>
<li>Media Source Extensions</li>
<li>The Screen Orientation API</li>
<li>Network Information API</li>
<li>Web MIDI (Musical Instrument Digital Interface ) API</li>
<li>IndexedDB API</li>
<li>Gamepad API</li>
<li>DeviceOrientation Event</li>
<li>Web App Manifest</li>
<li>WebVTT: The Web Video Text Tracks Format</li>
<li>Touch Events</li>
<li>Scalable Vector Graphics (SVG)</li>
<li>Resize Observer API</li>
<li>Intersection Observer</li>
<li>Mutation Observer</li>
<li>Cooperative Scheduling of Background Tasks</li>
<li>Service Worker API</li>
<li>Payment Request API</li>
<li>Presentation API</li>
<li>Web Authentication API</li>
</ul>
<p>WICG 标准下的 API：</p>
<ul>
<li>Input Device Capabilitie</li>
<li>Web Bluetooth API</li>
<li>WebUSB API</li>
</ul>
<p>ECMA 标准下的 API：</p>
<ul>
<li>JavaScript 全局变量</li>
<li>ECMAScript 2018 Internationalization API</li>
</ul>
<p>WHATWG 标准下的 API：</p>
<ul>
<li>Streams</li>
<li>Encoding</li>
<li>URL</li>
</ul>
<p>Khronos 标准下的 API：</p>
<ul>
<li>WebGL</li>
</ul>
<p>未标准化的 API：</p>
<ul>
<li>Web Background Synchronization</li>
<li>WebRTC API</li>
<li>Document Object Model XPath</li>
<li>Visual Viewport API</li>
<li>Performance Timeline API</li>
</ul>
<p>浏览器环境的 API，正是这样复杂的环境。我们平时编程面对的环境也是这样一个环境。</p>
<h2 id="目前web领域相关标准制定组织"><a href="#目前web领域相关标准制定组织" class="headerlink" title="目前web领域相关标准制定组织"></a>目前web领域相关标准制定组织</h2><ul>
<li>W3C：万维网联盟，创建于1994年。</li>
<li>ECMA:欧洲计算机制造联合会, 制定JavaScript标准的ECMA 的39号技术委员会（ECMA TC39）</li>
<li>WICG：Web Platform Incubator Community Group Web平台孵化器社区组，浏览器厂商也有参与，研究实验一些前沿功能。</li>
<li>Khronos：多个国家和行业领导者创立，致力于发展开放标准的应用程序接口 API ，以实现在多种平台和终端设备上的富媒体创作、加速和回放。</li>
<li>WHATWG： Web Hypertext Application Technology Working Group web超文本技术工作小组(2004年，数个浏览器厂商在无法忍受W3C罔顾现实情况意图抛弃HTML的时候，脱离W3C建立了该小组)。在2019年5月8日，<a href="https://www.w3.org/blog/news/archives/7753">W3C 和 WHATWG 达成协议</a>：W3C 将不再独立发布与 DOM 和 HTML 直接相关的规范，而是与 WHATWG 合作，将 WHATWG 的审核草稿转为 W3C 推荐规范；同时 WHATWG 将负责维护 HTML 和 DOM 的现行标准。</li>
</ul>
<h2 id="关于JS的小知识"><a href="#关于JS的小知识" class="headerlink" title="关于JS的小知识"></a>关于JS的小知识</h2><ol>
<li>1995年5月，Brendan Eich 只用了10天，就设计完成了这种语言的第一版。它是一个大杂烩，语法有多个来源： </li>
</ol>
<ul>
<li>基本语法：借鉴 C 语言和 Java 语言。  </li>
<li>数据结构：借鉴 Java 语言，包括将值分成原始值和对象两大类。  </li>
<li>函数的用法：借鉴 Scheme 语言和 Awk 语言，将函数当作第一等公民，并引入闭包。  </li>
<li>原型继承模型：借鉴 Self 语言（Smalltalk 的一种变种）。  </li>
<li>正则表达式：借鉴 Perl 语言。  </li>
<li>字符串和数组处理：借鉴 Python 语言。 </li>
</ul>
<ol start="2">
<li>1996年11月，Netscape 公司决定将 JavaScript 提交给国际标准化组织 ECMA希望 JavaScript 能够成为国际标准，以此抵抗微软。ECMA 的39号技术委员会（Technical Committee 39）负责制定和审核这个标准（也是就github上ECMA TC39 的名称来源），1997年7月，ECMA 组织发布262号标准文件（ECMA-262）的第一版，之后<a href="https://github.com/tc39/ecma262">ECMA-262</a>，一直就是JavaScript的标准文件名称了。</li>
<li>ECMAScript 只用来标准化 JavaScript 这种语言的基本语法结构，与部署环境相关的标准都由其他标准规定，比如 DOM 的标准就是由 W3C组织（World Wide Web Consortium）制定的。</li>
<li>2015 年 6 月，发布了ES6 的第一个版本（正式名称就是《ECMAScript 2015 标准》），并规定标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。2016 年 6 月发布了ES2016标准，2017 年 6 月发布 ES2017 标准。</li>
<li>ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等.</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://kangax.github.io/compat-table/es6/">ES6 的支持进度</a></li>
<li><a href="https://wangdoc.com/javascript/basic/history.html">JavaScript 语言的历史</a></li>
<li><a href="http://yanhaijing.com/es5/ECMAScript%E8%A7%84%E8%8C%83-%E7%AC%AC%E4%B8%89%E7%89%88_%E4%B8%AD%E6%96%87%E7%89%88.pdf">ECMAScript 3 中文版 pdf</a></li>
<li><a href="http://www.ecma-international.org/ecma-262/5.1/index.html">ecma-international ecma 262 5.1（英）</a></li>
<li><a href="https://whatwg-cn.github.io/html/">html标准-中文翻译</a></li>
<li><a href="https://www.w3.org/Style/CSS/">css标准</a></li>
<li><a href="https://github.com/whatwg/">whatwg github</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Introduction">MSDN - webAPI</a></li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的JS系列-1</title>
    <url>/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E7%B3%BB%E5%88%97-1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇主要为阅读《你不知道的JavaScript-上卷》中遇到自己遗漏的知识点，加上一些自己的理解进行了梳理整理，阅读章节为第一部分：作用域和闭包</p>
<span id="more"></span>

<h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><p>通常会将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言，但它并非同C++等语言是进行提前编译的（词法分析:拆词-&gt;语法分析:AST抽象语法树-&gt;代码生成：AST转为可执行代码），它的编译过程是在JS引擎中完成的（代码执行前进行编译）：</p>
<ul>
<li>引擎从头到尾参与js的编译与执行过程</li>
<li>编译器（js中也可以称为解释器）则是引擎的好朋友，负责语法解析与代码生成等工作</li>
<li>作用域也是引擎的好朋友，通过一套严格规则来确定当前执行代码对这些标识符的访问权限</li>
</ul>
<p>PS: 解释器将代码编译为中间码，中间码最终由引擎编译为机器码执行</p>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>同多数编程语言一样，JS的作用域为词法作用域（也成为静态作用域），也就是作用域是根据你编写代码时变量与块作用域写在哪里决定的，而非运行时决定。</p>
<p>请看下面例子：</p>
<pre><code>    var val=1;
    function foo()&#123;
      console.log(val)
    &#125;
    function bar()&#123;
     var val=2;
      foo()
    &#125;
    bar() ;//运行结果为：1
</code></pre>
<p>这是因为函数foo在函数bar中调用，但其作用域在定义时已经确定，即只能访问到foo函数内部跟全局作用域。</p>
<p>JavaScript 中有两种机制可以“欺骗词法作用域”：</p>
<h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>看下面的例子:</p>
<pre><code>    var a=1;
    function foo(str,b)&#123;
    eval(str);
    console.log(a,b)
    &#125;
    var str=&quot;var a=2&quot;;
    foo(str,4) // 运行结果为：2,4  
</code></pre>
<p>在执行eval之后，引擎并不知道eval是以动态的方式进入的，并对词法环境进行修改。所以这个时候词法作用域就会被破坏。</p>
<p>严格模式的程序中，eval 在运行时有其自己的词法作用域</p>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>with通常被当作重复引用一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。<br>with将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（运行阶段）。</p>
<pre><code>function foo(obj)&#123;  
    with(obj)&#123;  
        a = 2;  
    &#125;  
&#125;  
var o1 = &#123; a : 3 &#125;;  
var o2 = &#123; b : 3 &#125;;  
  
foo(o1);  
console.log( o1.a );    // 2
  
foo(o2);  
console.log( o2.b );    // 3
console.log( a );       // 2，表明a泄漏到全局作用域上了！
</code></pre>
<p>with在严格模式下已经无法使用。最重要的时，由于eval 和 with 会绕开js引擎在编译阶段进行的性能优化，导致运行变慢；这些在js语言精粹中也有提及，都是js设计中的“糟粕”，不要再使用了。</p>
<h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><ul>
<li>ReferenceError：作用域中遍寻不到所需的变量，引擎就会抛出该异常；</li>
<li>TypeError：作用域判别成功了，但是对结果的操作是非法或不合理的；</li>
</ul>
<h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>JS的词法作用域是基于函数的，在ES6语法中的块级作用域出现之前，我们创建作用域通常都是基于函数的，也经常看到如下代码：</p>
<pre><code>(function()&#123;
  var a=1;
  console.log(a)
&#125;)();
console.log(a); //ReferenceError 引用报错
</code></pre>
<h3 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h3><p>上述函数被称为立即执行函数表达式，也称为IIFE（Immediately Invoked Function Expression），它还有其他写法：</p>
<pre><code>(function()&#123;
  var a=1;
  console.log(a)
&#125;());
</code></pre>
<p>两种写法是一致的，不过第一种经常出现在一些第三方库中，将全局对象的引用作为函数参数传递进去：</p>
<pre><code>  var a=2;
  (function ( global ) &#123;
  var a = 3;
  console.log( a ); // 3
  console.log( global.a ); // 2
  &#125;)( window );
</code></pre>
<p>这种写法使得函数对全局对象的引用更清晰直观。</p>
<p>IIFE 还有一种变化的用途是倒置代码的运行顺序， 将需要运行的函数放在第二位， 在 IIFE执行之后当作参数传递进去。 这种模式在<a href="/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%BF%9B%E5%8C%96%E5%8F%B2/#UMD">UMD项目</a>中被广泛使用。 </p>
<h3 id="补充：立即执行函数的原理"><a href="#补充：立即执行函数的原理" class="headerlink" title="补充：立即执行函数的原理"></a>补充：立即执行函数的原理</h3><blockquote>
<p>更多可参考《Javascript高级程序设计》第七章：函数表达式</p>
</blockquote>
<p>对于函数表达式：</p>
<pre><code>  var foo = function()&#123;
    console.log(&quot;foo&quot;)
  &#125;
</code></pre>
<p>进行调用：</p>
<pre><code>  foo(); 
</code></pre>
<p>也可以合并为：</p>
<pre><code>  var foo = function()&#123;
    console.log(&quot;foo&quot;)
  &#125;();
</code></pre>
<p>我们来进一步简化：</p>
<pre><code>function foo()&#123;
    console.log(&quot;foo&quot;)
  &#125;();
</code></pre>
<p>上面代码会直接报错，因为解析器遇到 <code>function</code> 关键字时会把后面的内容解析为函数声明，函数声明语句后面加上一对圆括号，只是函数声明语句与分组操作符的组合而已。由于分组操作符不能为空，所以报错；括号内传入一个表达式则不会再报错，但等同于：</p>
<pre><code>  function foo()&#123;
    console.log(&quot;foo&quot;)
  &#125;;
 (1); // 只是一个函数声明 + 一个表达式
</code></pre>
<p>所以，如何让解析器将代码直接解析成表达式，而非函数声明才是关键，因为javascript中的圆括号不能包含语句，都会被解析为表达式，所以：</p>
<pre><code> (function foo()&#123;
    console.log(&quot;foo&quot;)
  &#125;())
</code></pre>
<p>函数名称多数情况下基本无用，可以省略，这样就变成了我们经常看到的形式：<br>     (function(){<br>        console.log(“foo”)<br>      }())<br>当然，我们可以直接左侧部分强制解析为函数表达式，然后加上括号直接调用，就变成了另外一种常见方式：</p>
<pre><code> (function()&#123;
    console.log(&quot;foo&quot;)
  &#125;)()
</code></pre>
<p>当然，除了圆括号，其他运算符也能达到目的（强制引擎解析为函数表达式）：</p>
<pre><code>!function()&#123; /* code */ &#125;();
~function()&#123; /* code */ &#125;();
-function()&#123; /* code */ &#125;();
+function()&#123; /* code */ &#125;();
true &amp;&amp; function()&#123; /* code */ &#125;();
</code></pre>
<p>但以上写法多多少少都存在一些副作用(如：修改函数返回值)，更推荐的写法依旧是圆括号。</p>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>块作用域是一个用来对之前的最小授权原则进行扩展的工具， 将代码从在函数中隐藏信息扩展为在块中隐藏信息。<br>在ES6之前，JS是不不支持块级作用域的，但深入研究后，其实是有其他替代方案的。</p>
<h3 id="with-1"><a href="#with-1" class="headerlink" title="with"></a>with</h3><p>with会创建一个块级作用域，但他会引发其他问题，因为不再推荐使用</p>
<h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h3><p>没错，try/catch的catch分句会创建一个块级作用域：</p>
<pre><code>try &#123;
  throw 1;
&#125; catch (a) &#123;
  a = 2;
  console.log( a );
&#125;
console.log(a) ; //ReferenceError: a is not defined
</code></pre>
<p>但是try/catch在chrome中有性能问题（虽然从语法上看不应该运行缓慢）</p>
<h3 id="let-amp-amp-const"><a href="#let-amp-amp-const" class="headerlink" title="let &amp;&amp; const"></a>let &amp;&amp; const</h3><p>let 关键字可以将变量绑定到所在的任意作用域中。 换句话说， let为其声明的变量隐式地了所在的块作用域。</p>
<pre><code>var foo = true;
if (foo) &#123;
  let bar = foo * 2;
  console.log( bar );
&#125;
console.log( bar ); // ReferenceError
</code></pre>
<p>const 与 let基本等同，只是其定义的值无法修改。</p>
<p>函数作用域和块作用域的行为是一样的，可以总结为：任何声明在某个作用域内的变量，都将附属于这个作用域</p>
<h2 id="声明提升"><a href="#声明提升" class="headerlink" title="声明提升"></a>声明提升</h2><p>先看两个例子：</p>
<pre><code>console.log(a)
var a=1;
</code></pre>
<p>对，没有报错，运行结果是 undefined</p>
<pre><code>a = 2;
var a;
console.log(a);
</code></pre>
<p>大多数会认为a又被赋值了，所以输出应该是undefined, 但输出结果是2。</p>
<p>所以，到底发生了什么，先有鸡（赋值）还是先有蛋（声明）？</p>
<p>上面讲到过引擎会对代码先进行编译，编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。</p>
<p>譬如：var a=1; 引擎会将它分成两个部分，var a 和 a=1; 第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段，也就是说，所有的声明（变量与函数）都会在编译阶段先被处理。</p>
<pre><code>foo();
function foo() &#123; 
  console.log( a ); // undefined
  var a = 2;
&#125;
</code></pre>
<p>上面的代码中函数foo 会被提升到当前作用域中，foo中的变量a也被提升到了函数作用域内的顶部，值得注意的是，函数表达式(包括具名函数)的作用域并不会提升。</p>
<pre><code>  foo(); // TypeError 
  bar(); // ReferenceError
  var foo = function bar() &#123; 
    // ... 
  &#125;
</code></pre>
<p>如果多处“重复声明”，函数声明的优先级最高，其次才是变量。</p>
<pre><code>  foo(); // 1
  var foo;
  function foo() &#123; 
    console.log( 1 ); 
  &#125;
  foo = function() &#123; 
    console.log( 2 );
  &#125;;
  foo();//2  
</code></pre>
<p>后面出现的函数声明可以覆盖前面的，也可以这样理解，foo执行时，引擎其实已经把<code>function foo&#123;...&#125;</code> 提升到最顶部，后面再次调用foo时，后面的函数表达式覆盖了函数声明，此时变输出2</p>
<p>不过我们要尽量避免重复声明，会引发意想不到的问题！</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包，总是笼罩着一层神秘色彩，关于这块内容其实理解的一直不够透彻。其实自己在日常书写中有意无意都会创建闭包，只是，我们不知道”它”叫闭包而已。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包；通俗理解的闭包就是：能够读取其他函数内部变量的函数。对，闭包的直观判断就是函数。</p>
<pre><code>  function foo() &#123;
    var a = 2;
    function bar() &#123; 
      console.log( a ); 
    &#125;
    return bar; 
  &#125;
  var baz = foo(); 
  baz(); // 2 在函数外部访问到了其他函数内部的变量
</code></pre>
<p>当然，也可以使用其他方式对函数的值进行传递:</p>
<pre><code>var fn;
function foo()&#123;
  var a=1;
  fn=function()&#123;
    console.log(a)
  &#125;
&#125;
function bar()&#123;
  fn(); // 快看，这就是闭包
&#125;
foo();  // 必须先执行，才能形成之传递
bar(); // 1
</code></pre>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>上述都是人为刻意的创建闭包，回归到我们日常开发中，只要使用了回调函数，其实就是在使用闭包！！！</p>
<p>譬如经常看到的多个li标签点击展示索引值的问题：</p>
<pre><code>const list=document.querySelectorAll(&quot;li&quot;);
for(var i=0;i&lt;list.length;i++)&#123;
    list[i].addEventListener(&quot;click&quot;,function()&#123;
      alert(i)
    &#125;)
&#125;
</code></pre>
<p>但是，如果按上述代码执行，无论怎么点击，alert的结果永远是一样的（list.length-1）</p>
<p>这是因为每次循环执行的代码都被封闭在一个共享的作用域中，此时，我们需要创建一个闭包作用域，使得每次循环都是独立的作用域，将上述代码进行改写：</p>
<pre><code>const list=document.querySelectorAll(&quot;li&quot;);
for(var i=0;i&lt;list.length;i++)&#123;
  (function(j)&#123;
    list[j].addEventListener(&quot;click&quot;,function()&#123;
      alert(j)
    &#125;)
  &#125;)(i);
&#125;
</code></pre>
<p>当然，如果使用ES6语法，利用let创建的块级作用域可以更简单的实现：</p>
<pre><code>const list=document.querySelectorAll(&quot;li&quot;);
for(let i=0;i&lt;list.length;i++)&#123;
    list[i].addEventListener(&quot;click&quot;,function()&#123;
      alert(i)
    &#125;)
&#125;
</code></pre>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>考虑下面代码，创建一个coolMod模块</p>
<pre><code>function coolMod()&#123;
  var something=&quot;cool&quot;;
  var another=[1,2,3];
  function doSomething()&#123;
    console.log(something)
  &#125;
  function doAnother()&#123;
    console.log(another)
  &#125;
  return &#123;
    doSomething:doSomething,
    doAnother:doAnother
  &#125;
&#125;
var foo = coolMod(); // 也可以将coolMod改为立即调用函数，变为单例模式
foo.doSomething(); 
foo.doAnother(); 
</code></pre>
<p>doSomething() 和 doAnother() 函数具有涵盖模块实例内部作用域的闭包</p>
<p>从coolMod模块也可以看出，模块模式需要具备两个必要条件：</p>
<ul>
<li>为创建内部作用域而调用了一个包装函数</li>
<li>包装函数的返回 值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</li>
</ul>
<p>模块模式另一个简单但强大的变化用法是，命名将要作为公共 API 返回的对象：通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修改。</p>
<pre><code>  var foo = (function coolMod(id) &#123;
  function change() &#123;
    // 修改公共 API 
    publicAPI.identify = identify2;
  &#125;
  function identify1() &#123;
    console.log(id);
  &#125;
  function identify2() &#123;
    console.log(id.toUpperCase());
  &#125;
  var publicAPI = &#123;
    change: change,
    identify: identify1
  &#125;;
  return publicAPI;
  &#125;)(&#39;foo mod&#39;);
  foo.identify(); //foo mod
  foo.change();
  foo.identify(); // FOO MOD
</code></pre>
<h4 id="创建一个模块依赖加载器"><a href="#创建一个模块依赖加载器" class="headerlink" title="创建一个模块依赖加载器"></a>创建一个模块依赖加载器</h4><p>创建一个模块依赖加载器，这里只是介绍下核心逻辑：</p>
<pre><code>var MyModules = (function Manager() &#123;
  var modules = &#123;&#125;;
  function define(name, deps, impl) &#123;
    for (var i = 0; i &lt; deps.length; i++) &#123; 
      deps[i] = modules[deps[i]]; 
    &#125; 
    modules[name] = impl.apply(impl, deps); 
    // 核心逻辑，将定义的模块函数挂载到内部modules对象下，并对外暴露API
    // apply 用法回忆：function fn(a,b)&#123;return a+b&#125;; fn.apply(fn,[1,2]);
  &#125;
  function get(name) &#123;
    return modules[name];
  &#125;
  return &#123;
    define: define,
    get: get
  &#125;
&#125;)();
</code></pre>
<p>可以看到闭包的写法，下面开始定义一个模块<code>bar</code></p>
<pre><code>MyModules.define( &quot;bar&quot;, [], function() &#123;
  function hello(who) &#123;
    return &quot;Let me introduce: &quot; + who;
  &#125;
  return &#123; hello: hello &#125;; 
&#125;);
</code></pre>
<p><code>bar</code>模块不依赖任何内容，同时对外暴露<code>hello</code>方法；<br>再定义一个<code>foo</code>模块，他依赖bar模块：</p>
<pre><code> MyModules.define( &quot;foo&quot;, [&quot;bar&quot;], function(bar) &#123; 
    function awesome(name) &#123; 
      console.log(bar.hello( name ).toUpperCase()); 
    &#125;
  return &#123; awesome: awesome &#125;; 
  &#125;);
</code></pre>
<p>可以看到<code>foo</code>模块的<code>awesome</code>方法依赖<code>bar</code>的<code>hello</code>方法，我们执行下两个模块，并调用下foo模块对外暴露的<code>awesome</code>方法</p>
<pre><code>var bar = MyModules.get( &quot;bar&quot; );
var foo = MyModules.get( &quot;foo&quot; );
foo.awesome(&#39;jack&#39;); // LET ME INTRODUCE: JACK
</code></pre>
<p>requireJS等模块加载库逻辑会比这个复杂许多，但基本核心思想大致相同，可以看到里面存在大量闭包的用法。</p>
<p>ES6语法开始支持的原生的模块语法，import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量上，而上面的例子是将整个模块的 API 导入并绑定到一个变量上；export 会将当前模块的变量/函数导出为公共API, 而上面例子是通过函数return出去；</p>
<p>ES6 的模块文件是一个独立的作用域，不需要再创建函数作用域闭包来处理了</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ul>
<li><a href="https://www.zhihu.com/question/20127472">知乎-JavaScript中圆括号() 和 方括号[] 的特殊用法疑问？</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>你不知道的js</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的JS系列-2</title>
    <url>/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E7%B3%BB%E5%88%97-2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇主要为阅读《你不知道的JavaScript-上卷》中遇到自己遗漏的知识点，加上一些自己的理解进行了梳理整理，阅读章节为第一部分：this和对象</p>
<span id="more"></span>

<h2 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h2><p><code>this</code>关键字是 JavaScript 中最复杂的机制之一, 在面向对象编程中，他是不可或缺的一份子。this到底是什么呢？不同于js中的词法作用域，this是一个很特别的存在:  </p>
<pre><code>this 在任何情况下都不指向函数的词法作用域
</code></pre>
<p>this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用!!!!</p>
<h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p>利用chrome的调试工具，我们可以很清晰的看到函数的调用栈：</p>
<pre><code>function baz() &#123; 
  // 当前调用栈是：baz // 因此，当前调用位置是全局作用域 
  console.log( &quot;baz&quot; ); 
  bar(); // &lt;-- bar 的调用位置 
&#125;
function bar() &#123;
  // 当前调用栈是 baz -&gt; bar // 因此，当前调用位置在 baz 中 
  console.log( &quot;bar&quot; ); 
  foo(); // &lt;-- foo 的调用位置 
&#125;
function foo() &#123; 
  // 当前调用栈是 baz -&gt; bar -&gt; foo // 因此，当前调用位置在 bar 中 
  console.log( &quot;foo&quot; ); 
&#125;
baz(); // &lt;-- baz 的调用位置
</code></pre>
<p>栈中第二个元素，这就是真正的调用位置：</p>
<p><img src="./1.png"><br><img src="./2.png"><br><img src="./3.png"></p>
<h2 id="this-绑定规则"><a href="#this-绑定规则" class="headerlink" title="this 绑定规则"></a>this 绑定规则</h2><p>在函数的执行过程中如何确定 this 的绑定对象，有以下四条规则：</p>
<h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>最常见的函数调用方式就是：独立调用；此时函数内的this指向全局对象（非严格模式下）</p>
<pre><code>function foo()&#123;
  console.log(this.a)
&#125;
var a=1
foo();// 1
</code></pre>
<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>我们先看如下代码：</p>
<pre><code>function foo() &#123; 
  console.log( this.a ); 
&#125;
var obj = &#123; 
  a: 2, 
  foo: foo 
&#125;;
obj.foo(); // 2
</code></pre>
<p>通过obj对象来调用函数，被调用函数被obj对象“拥有”了，这就是一种隐式绑定，并且对象属性引用链的最后一层才会影响this，在上面例子上，继续添加：</p>
<pre><code>var obj2 = &#123;
  a:1,
  obj:obj
&#125;
obj2.obj.foo(); // 2
</code></pre>
<p>但隐式绑定经常出现this丢失的问题：</p>
<pre><code>function foo() &#123; 
  console.log( this.a ); 
&#125;
var obj = &#123; 
  a: 2, 
  foo: foo 
&#125;;
var a=&quot;global&quot;;
var bar=obj.foo;
bar(); // global

setTimeout(obj.foo,1000) // global
</code></pre>
<p>this隐式丢失是非常常见的（在回调函数更是常见），此时需要我们进行显示绑定</p>
<h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><p>此时，我们请出<code>call</code>函数与<code>apply</code>函数以及<code>bind</code>函数, call 与 apply 功能基本相同以call为例，先说下这两个函数，依旧沿用上面的例子</p>
<pre><code>function foo() &#123; 
  console.log( this.a ); 
&#125;
var obj = &#123; 
  a: 2, 
  foo: foo 
&#125;;
var a=&quot;global&quot;;
var bar=obj.foo;
bar.call(obj); // 2
</code></pre>
<p>通过call可以强制将this指向obj对象，但对于回调函数，call/apply依旧无能为例，因为执行call/apply就相当于执行了函数，并没有返回新的函数，此时，就需要ES5中的bind函数登场了：</p>
<pre><code>setTimeout(obj.foo.bind(obj),1000); // 2
</code></pre>
<p>JavaScript 语言和宿主环境中许多新的内置函数，都提供了一 个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样：</p>
<pre><code>function foo() &#123; 
  console.log( this.a ); 
&#125;
var obj = &#123; 
  a: 2, 
  foo: foo 
&#125;;
var a=&quot;global&quot;;

[1].forEach(foo,obj);// 2
</code></pre>
<p>它们内部也是通过call/apply来进行了显示绑定</p>
<h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p>首先要跳出一个误区：JS中没有构造函数，所谓的构造函数，其实只是对函数的“构造调用”。</p>
<p>用new调用过会自动执行以下操作：</p>
<ul>
<li>创建（或者说构造）一个全新的对象。</li>
<li>这个新对象会被执行 [[ 原型 ]] 连接。</li>
<li>这个新对象会绑定到函数调用的 this。</li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</li>
</ul>
<p>我们接着看代码：</p>
<pre><code>function foo(a)&#123;
  this.a=a;
&#125;
var bar=new foo(2);
console.log(bar.a) //2
</code></pre>
<h2 id="this-绑定优先级"><a href="#this-绑定优先级" class="headerlink" title="this 绑定优先级"></a>this 绑定优先级</h2><p>对于正常函数调用来说，函数绑定this的优先级如下：</p>
<pre><code>  new绑定 &gt;  显式绑定 &gt;  隐式绑定 &gt; 用默认绑定
  
</code></pre>
<p>但，凡事总有例外:</p>
<p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind时，此时会执行默认规则，如对参数进行柯里化（关于柯里化会单独开篇再讲）：</p>
<pre><code> function add(a,b)&#123;
   console.log(&quot;a:&quot; + a + &quot;, b:&quot; + b);
 &#125;
 add.apply(null,[2,3]);// a:2, b:3
</code></pre>
<p>但这样用null来忽略this的指向还是不够”安全”，我们可以通过创建空对象来实现：</p>
<pre><code>function add(a,b)&#123;
   console.log(&quot;a:&quot; + a + &quot;, b:&quot; + b);
 &#125;
 add.apply(Object.create( null ),[2,3]);// a:2, b:3
 
</code></pre>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6中的箭头函数不适用四种标准规则，而是根据外层（函数或者全局）作用域来决定 this，箭头函数回归了词法作用域来替代this的机制</p>
<pre><code>function foo() &#123;
  setTimeout(() =&gt; &#123;
    // 这里的 this 在此法上继承自 foo()
    console.log(this.a); // 2
  &#125;,100);
  setTimeout(function()&#123;
  console.log(this.a);// global
  &#125;,200);
&#125;
var obj = &#123;
  a:2
&#125;;
var a = &quot;global&quot;;
foo.call(obj);
</code></pre>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p> JavaScript 中一共有七种主要类型（术语是“语言类型”）: <code>null/undefined/boolean/string/number/symbol/object</code>,具体可参见<a href="/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-JavaScript%E9%83%A8%E5%88%86-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">重学前端系列-数据类型</a></p>
<p>前面六种称之为基本类型，剩下的都可以归到复杂类型下。同时JavaScript 中还有一些对象子类型，通常被称为内置对象：<code>String/Number/Boolean/Object/Function/Array/Date/RegExp/Error/Set/Map/Promise</code>, 更多关于对象部分可参见<a href="/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-JavaScript%E9%83%A8%E5%88%86-%E5%AF%B9%E8%B1%A1/">重学前端系列-对象</a></p>
<p>这些内置函数可以当作构造函数 （可以通过new调用）来使用，从而可以构造一个对应子类型的新对象。对于这些对象子类型，Object、Array、Function 和 RegExp（正则表达式）来说，无论使用文字形式还是构造形式，它们都是对象(不是字面量)，所以首选更简单的文字形式。建议只在需要那些额外选项时使用构造形式。</p>
<p>在对象中，属性名永远都是字符串（会被强制转化），数组中则是下标数字。</p>
<h3 id="属性名"><a href="#属性名" class="headerlink" title="属性名"></a>属性名</h3><p>ES6之前属性名写法不支持变量，现在也开始支持了，主要场景是针对<code>Symbol</code>类型</p>
<pre><code>var prefix = &quot;foo&quot;;
var mySymbol=Symbol();
var myObject = &#123; 
  [prefix + &quot;bar&quot;]:&quot;hello&quot;, 
  [prefix + &quot;baz&quot;]: &quot;world&quot;,
  [mySymbol]:&quot;Hello World&quot;
&#125;;
console.log(myObject[mySymbol]) // Hello World
</code></pre>
<h3 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h3><p>对于对象来说，如果改属性值指向的是一个函数，我们经常会称之为“方法”，但这其实是个误解，函数不管在什么情况下都不会属于某个对象，只是属性引用值指向一个函数而已，这在JS中经常混用，知道即可。“函数”和“方法”在 JavaScript 中是可以互换的。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组也是对象，所以也可以把数组当“普通”对象使用：</p>
<pre><code>var arr=[1,2,3];
arr.type=&quot;array&quot;
console.log(arr);// [1, 2, 3, type: &quot;array&quot;]
console.log(arr.length); //3
</code></pre>
<p>我们可以给数组添加属性，但数组的长度并不会改变</p>
<h3 id="对象的复制"><a href="#对象的复制" class="headerlink" title="对象的复制"></a>对象的复制</h3><p>对于 JSON 安全的对象来说，有一种巧妙的复制方法(可以实现深度复制)：</p>
<pre><code> var newObj = JSON.parse( JSON.stringify( someObj ) );
</code></pre>
<p>ES6 新增了 <code>Object.assign</code>方法来实现浅复制(内部也是通过遍历使用 <code>= </code>操作符来赋值):</p>
<pre><code> var newObj = Object.assign( &#123;&#125;, someObj )
</code></pre>
<h3 id="对象的“其他”方法"><a href="#对象的“其他”方法" class="headerlink" title="对象的“其他”方法"></a>对象的“其他”方法</h3><ul>
<li><p><code>Object.preventExtensions</code>：禁止一个对象添加新属性并且保留已有属性</p>
<pre><code>var myObject = &#123;
  a:2
&#125;;
Object.preventExtensions( myObject );
myObject.b = 3;
myObject.b; // undefined
</code></pre>
</li>
<li><p><code>Object.seal</code>：会创建一个“密封” 的对象（对对象所有属性调用preventExtensions方法，并把所有现有属性标记为 <code>configurable:false</code>）</p>
</li>
<li><p><code>Object.freeze</code>：会创建一个冻结对象（对象上调用seal方法，并把所有“数据访问” 属性标记为 <code>writable:false</code>）</p>
</li>
</ul>
<h3 id="Getter-amp-amp-Setter"><a href="#Getter-amp-amp-Setter" class="headerlink" title="Getter &amp;&amp; Setter"></a>Getter &amp;&amp; Setter</h3><p>此部分可参见<a href="/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-JavaScript%E9%83%A8%E5%88%86-%E5%AF%B9%E8%B1%A1/#%E8%AE%BF%E9%97%AE%E5%99%A8%EF%BC%88getter-setter%EF%BC%89%E5%B1%9E%E6%80%A7">重学前端系列-对象</a></p>
<h3 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h3><ul>
<li><p><code>for in</code> 操作符会检查属性是否在对象及其 <code>[[Prototype]]</code> 原型链中</p>
<pre><code>1. for in 其实只是检测属性名是否存在
2. 不要在数组中调用for in 因为会得到除了数值索引外其他的属性值：
   var arr=[1,2,3];
   arr.type=&#39;8&#39;
   for( var k in arr)&#123;
    console.log(k);// 0,1,2,type
   &#125;
</code></pre>
</li>
<li><p><code>hasOwnProperty</code> 只会检查属性是否在当前对象中。</p>
<pre><code>1. 如果担心myObejct.hasOwnProperty失败可以调用：Object.prototype.myObejct.call(hasOwnProperty)
</code></pre>
</li>
<li><p><code>propertyIsEnumerable</code>:会检查给定的属性名是否直接存在于对象中（不包含原型链）并满足 <code>enumerable:true</code></p>
</li>
<li><p><code>Object.keys</code>:会返回一个数组，包含所有可枚举属性;</p>
</li>
<li><p><code>Object.getOwnPropertyNames</code>:会返回一个数组，包含所有属性，无论它们是否可枚举</p>
</li>
</ul>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>说起遍历首先想到的就是for循环，但for循环其实并不是在遍历值， 而是遍历下标来指向值， 如 <code>myArray[i]</code></p>
<ul>
<li><p>map：【不改变原数组】对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组</p>
<pre><code>// 调用map时大多情况下是为了他的返回值的, 除了抛出异常以外，没有办法中止或跳出

const arr=[1,2,3];
const newArr=arr.map(v=&gt;v*10); 
 // 箭头函数只有一个返回值时可以省略return，其他情况不能省略，不然得到是[undefined,undefined,undefined]
console.log(arr,newArr)
 // 结果：[1,2,3]  [10,20,30]
</code></pre>
</li>
<li><p>forEach：【不改变原数组】对数组中的每一项运行给定函数。这个方法没有返回值</p>
<pre><code> // 调用map时大多情况下是只是为了遍历, 除了抛出异常以外，没有办法中止或跳出
const arr=[1,2,3];
const newArr=arr.map(v=&gt;v*10);
console.log(arr,newArr) // [1,2,3] undefined
</code></pre>
</li>
<li><p>filter：【不改变原数组】对数组中的每一项运行给定函数，返回该函数会返回true 的项组成的数</p>
<pre><code>const arr=[1,2,3];
const newArr=arr.filter(v=&gt;v&gt;2);
console.log(arr,newArr) // [1,2,3] [3]
</code></pre>
</li>
<li><p>every：【不改变原数组】对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true</p>
<pre><code>// 只要给定函数返回false立即跳出，并得到false;
const arr=[1,2,3];
const newArr=arr.every(v=&gt;&#123;
  console.log(v);//1
  return v&gt;1
&#125;);
console.log(arr,newArr) ;//[1,2,3] false
</code></pre>
</li>
<li><p>some：【不改变原数组】对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true，跳出不再遍历</p>
<pre><code>// 只要给定函数返回true立即跳出，并得到true;
const arr=[1,2,3];
const newArr=arr.some(v=&gt;&#123;
  console.log(v);//1,2
  return v&gt;1
&#125;);
console.log(arr,newArr) ;//[1,2,3] true
</code></pre>
</li>
</ul>
<p>如何直接遍历值而不是数组下标（或者对象属性）？ ES6 增加了一种用来遍历数组的<code>for of</code>循环语法, 具体可参见<a href="/ES6%E7%B3%BB%E5%88%97-3-Iterator/">ES6系列:Iterator</a></p>
<p>几种遍历的执行效率：</p>
<pre><code>  for &gt; for-of &gt; forEach &gt; filter &gt; map &gt; for-in
</code></pre>
<p>ES6扩展了数组的方法，新增了entries/keys/values方法，返回的<code>iterator</code>对象用于<code>for of</code>循环，参见：<a href="/ES6%E7%B3%BB%E5%88%97-2-%E6%96%B0%E5%A2%9E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-entries-%EF%BC%8Ckeys-%E5%92%8C-values">ES6系列-新增类型与扩展方法</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>你不知道的js</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的JS系列-3</title>
    <url>/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E7%B3%BB%E5%88%97-3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本篇接着《你不知道的JavaScript-上卷》，介绍本书的最后一部分：原型与类。</p>
<p>从接触JavaScript这门语言开始，相信都绕不开原型，原型链，面向对象，类等概念，我们可以先抛开这些东西，跳出来看下JavaScript的诞生过程。这个可以参考<a href="https://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html">阮一峰-Javascript继承机制的设计思想</a> 和 Javascript设计者– <a href="https://baike.baidu.com/item/Brendan%20Eich">Brendan Eich的百科</a>，会渐渐明白Javascript为何存在这么多的争议，为什么叫Javascript却跟Java没有一毛钱的关系，更像是C语言和Self语言一夜情的产物~~</p>
<p>Javascript的基本设计思路如下：</p>
<pre><code>  (1)借鉴C语言的基本语法;
  (2)借鉴Java语言的数据类型和内存管理;
  (3)借鉴Scheme语言，将函数提升到&quot;第一等公民&quot;(first class)的地位;
  (4)借鉴Self语言，使用基于原型(prototype)的继承机制
</code></pre>
<p>说好听点就是集各家所长，难听点就是四不像了~；设计者也未曾料到Javascript会发展壮大到如今的地步，所谓时势造英雄。在深入了解Javascript后，应当取其精华，弃其糟泊；在《你不知道的JavaScript》中，本书作者其实是极其不推荐使用“模拟类”来设计代码。更推崇使用“行为委托”的方式设计代码。</p>
<p>下面，我们进入正题，再次学习下Javascript的原型与类</p>
<span id="more"></span>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>与其它的语言相比，JavaScript 中的“对象”总是显得不那么合群。Javascript是面向对象的一门语言（也是一门函数式编程语言，后续再开文介绍），关于对象可以参考之前的博文<a href="/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-JavaScript%E9%83%A8%E5%88%86-%E5%AF%B9%E8%B1%A1/">重学前端系列-对象</a></p>
<p>而面向对象的编程语言中，有两种不同的流派来“抽象”对象，一种是基于类的编写（Java，C++等），一种是基于原型的编写（Self，kevo）；</p>
<p>因为一些政治原因，JavaScript 推出之时受管理层之命被要求模仿 Java，所以，Brendan Eich 在“原型运行时”的基础上引入了 new、this 等语言特性，使之“看起来更像 Java”，不过也导致JavaScript的原型链更难理解。</p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>在 JavaScript 之前，原型系统就更多与高动态性语言配合，Brendan Eich最终选择了原型系统来进行设计，而原型系统的“复制操作”有两种实现思路：</p>
<ul>
<li>一个是并不真的去复制一个原型对象，而是使得新对象持有一个原型的引用；</li>
<li>另一个是切实地复制对象，从此两个对象再无关联。</li>
</ul>
<p>显然，Brendan Eich选择的是第一种，上面已经多次提到了<code>[[Prototype]]</code>，就是关联对象的特殊属性：</p>
<pre><code>var anotherObject = &#123; foo:2 &#125;; 
var myObject = Object.create( anotherObject );// 创建一个关联到 anotherObject 的对象
console.log(myObject.foo);// 2
</code></pre>
<p>熟悉JS中原型链的很容易理解上面的运行结果，当我们获取一个对象属性时就会触发<code>[[Get]]</code>操作，该操作的第一步就是检查获取的属性是否存在当前对象中，如果有就使用，如果没有则会顺着对象的<code>[[Prototype]]</code>属性继续查找，使用 <code>for..in</code> 遍历对象时原理和查找 <code>[[Prototype]]</code> 链类似，所有普通的 <code>[[Prototype]]</code> 链最终都会指向内置的 <code>Object.prototype</code></p>
<p><img src="./1.png"></p>
<p>JavaScript 中的对象具有高度的动态性：允许运行时向对象添加属性，这点与其他语言是完全不同的。我们为<code>myObject</code>添加属性</p>
<pre><code> myObject.foo=&#39;bar&#39;
 console.log(myObject.foo, anotherObject.foo) ;// bar, 2
</code></pre>
<p>这个过程发生了“属性屏蔽”，也就是说，myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性。<br>我们都习以为常，但是这个过程 其实存在三种情况，“属性屏蔽”不是一定发生的：</p>
<ol>
<li>如果在 <code>[[Prototype]]</code> 链上层存在名为 foo 的普通数据访问属性并且没 有被标记为只读（writable:false），那就会直接在 myObject 中添加一个名为 foo 的新 属性，它是屏蔽属性。 </li>
<li>如果在 <code>[[Prototype]]</code> 链上层存在 foo，但是它被标记为只读（writable:false），那么 无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会 抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。 </li>
<li>如果在 <code>[[Prototype]]</code> 链上层存在 foo 并且它是一个 setter（参见第 3 章），那就一定会 调用这个 setter。foo 不会被添加到（或者说屏蔽于）myObject，也不会重新定义 foo 这 个 setter。</li>
</ol>
<p>与我们常规认知不同，属性屏蔽只有在第一种情况下才发生。如果想要第二、三种也发生属性屏蔽，就需要使用<code>Object.defineProperty</code>方法来添加属性</p>
<h3 id="proto-与-prototype"><a href="#proto-与-prototype" class="headerlink" title="__proto__ 与 prototype"></a>__proto__ 与 prototype</h3><ul>
<li><p>__proto__  属性是一个访问器属性（一个getter函数和一个setter函数）, 暴露了通过它访问的对象的内部<code>[[Prototype]]</code> (一个对象或 null)，这个属性并不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6，但官网仍旧<strong>不推荐使用</strong>，而是使用<code>Object.setPrototypeOf</code>（写操作）、<code>Object.getPrototypeOf</code>（读操作）、<code>Object.create</code>（生成操作）来代替。</p>
<pre><code>  注意：同constructor属性一样（后面会讲到），它存在于内置的 Object.prototype 中。
</code></pre>
</li>
<li><p>prototype是函数才有的属性!!! 所有的函数默认都会拥有一个名为<code>prototype </code>的公有并且不可枚举的属性，它会指向另一个对象（通常被称为该函数的原型）。      </p>
<pre><code>  注意：prototype属性所有函数都会拥有，无论是否通过new来调用。
</code></pre>
</li>
</ul>
<h3 id="“构造”函数"><a href="#“构造”函数" class="headerlink" title="“构造”函数"></a>“构造”函数</h3><p>先看一下如下的代码：</p>
<pre><code>function Foo(name)&#123;
  this.name=name
&#125;
Foo.prototype.sayHi=function()&#123;
  console.log(&quot;Hi,&quot;+this.name)
&#125;
var f=new Foo(&quot;Tom&quot;)
f.sayHi()                                             // Hi,Tom
console.log(f.__proto__===Foo.prototype)              // true  并非所有浏览器都支持
console.log(Object.getPrototypeOf(f)===Foo.prototype) // true
console.log(Foo.prototype.constructor===Foo)           // true
console.log(f.constructor===Foo)                       // true
</code></pre>
<p>通过 new 关键字 “实例”一个对象，<code>Foo</code>也通常被称作“构造函数”，但我们都知道，js的世界里面是没有类的，new 关键字也是Brendan Eich 模仿Java语法而设计出来的。实例<code>f</code>并没有方法<code>sayHi</code>，但看起来却向“继承”了Foo的方法，那么，这个过程究竟发生了什么？</p>
<p>通过new调用函数时，会将实例内部的<code>[[Prototype]]</code>属性(<code>__proto__</code>)关联到“类”函数的<code>prototype</code>属性下，也就是：<code>f.__proto__===Foo.prototype</code>，这样两个对象产生了关联，执行<code>f.sayHi</code>时会根据原型链查找到<code>Foo.prototype.sayHi</code>，此时看起来就像产生了所谓的“继承”，但是，JavaScript在这个过程并没有复制对象，只是通过委托的方式进行了属性(方法)的共享。</p>
<p>上述代码中<code>f.constructor===Foo</code>很容易让人误解 <code>Foo</code> 就是 <code>f</code>的构造函数（再加上new操作符更加深了这种误解），但实际并非如此：</p>
<p><code>Object.prototype</code>对象下有一个公有并且不可枚举的属性<code>constructor</code>，这个属性引用的是对象关联的函数(本例为Foo)，而调用<code>f.constructor</code>跟过程其实也只是通过委托访问到了<code>Foo.prototype.constructor</code>，这点一定要明白：这个属性并不是表示<code>f</code>由<code>Foo</code>“构造”而成的：</p>
<pre><code>function Foo(name)&#123;
  this.name=name
&#125;
Foo.prototype=&#123;&#125;;
var f=new Foo(&quot;Tom&quot;)
console.log(f.constructor===Foo)     // false
console.log(f.constructor===Object)  // true
</code></pre>
<p>从上面可以看到：执行<code>f.constructor</code>时f下并没有这个属性，此时会依据原型链进行查找，因为<code>Foo.prototype</code>被进行了重写操作，所以<code>Foo.prototype</code>下也没有这个属性，接着往上找到了<code>Object.prototype</code>，发现<code>constructor</code>属性下有值且为Object，这表明<code>f</code>并不是通过<code>Foo</code>“构造”而来，一切都是<code>new</code>调用时将产生的对象<code>[[prototype]]</code>关联到了调用函数的<code>.prototype</code>下。并且<code>.constructor</code> 是一个不可枚举但是可写的属性，所以，这个属性很多情况下是靠不住的。</p>
<p>Foo 和其他函数没有任何区别。函数本身并不是构造函数，当我们在普通的函数调用前面加上 <code>new</code> 关键字之后，<code>new</code> 就会劫持所有普通函数并用构造对象的形式来调用它。</p>
<p><img src="./2.png"></p>
<p>对于真正的类语言来说，构造函数是属于类的。然而，在 JavaScript 中恰好相反——**实际上“类”是属于构造函数的!!!**（Foo.prototype 这样的类型引用，注意理解此处）</p>
<h3 id="“原型”继承"><a href="#“原型”继承" class="headerlink" title="“原型”继承"></a>“原型”继承</h3><p>在Javascript中虽然不存在“类”但是它存在“继承”机制，这也是导致那么多“模拟类”行为的存在，因为如果没有“继承”的话，“模拟类”根本就没有存在的意义了。<br>首先上代码，一个经典的继承（借用构造函数继承模式）设计：</p>
<pre><code>  function Foo(name)&#123;
    this.name=name
  &#125;
  Foo.prototype.sayHi=function()&#123;
    console.log(&quot;Hi,&quot;+this.name)
  &#125;
  function Bar(name,job)&#123;
    Foo.apply(this,arguments)
    this.job=job
  &#125;
  Bar.prototype=Object.create(Foo.prototype)
  Bar.prototype.doJob=function()&#123;
    console.log(this.name+&quot; job is &quot;+this.job)
  &#125;
  var b1=new Bar(&quot;Jack&quot;,&quot;teacher&quot;)
  b1.sayHi();                       // Hi,Jack
  b1.doJob();                       // Jack job is teacher
</code></pre>
<p>里面关键的一行代码：<code>Bar.prototype=Object.create(Foo.prototype)</code>，功能就是创建一个新的 <code>Bar.prototype</code> 对象并把它关联到 <code>Foo. prototype</code>,原型链关联起来后，就可以通过委托的方式使用Foo对象的<code>.sayHi</code>方法。</p>
<p>除了<code>Object.create</code>(关于这个函数可访问<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">MDN</a>)外，还可以使用其他方法，但均存在其他的副作用：</p>
<ul>
<li><p><code>Bar.prototype=Foo.prototype</code></p>
<pre><code>    二者直接引用，这就导致Bar.prototype.doJob = xxx 的赋值语句时会直接修改 Foo.prototype 对象本身
</code></pre>
</li>
<li><p><code>Bar.prototype=new Foo()</code></p>
<pre><code>    通过“构造函数”调用，如果函数Foo有一些副作用（如写日志、修改状态、注册到其他对象、给this 添加数据属性）的话，就会影响到Bar()的“后代”
</code></pre>
<p>考虑到<code>Object.create</code>有一些兼容性问题（ES5新增），可以使用一些其他polyfill方法进行替代，此处不再展开，可以参考书本160页。  </p>
</li>
</ul>
<p>同时，ES6新增了方法可以直接修改对象的<code>[[prototype]]</code>属性：</p>
<pre><code>  Object.setPrototypeOf(Bar.prototype,Foo.prototype)
</code></pre>
<h3 id="检查“类”关系"><a href="#检查“类”关系" class="headerlink" title="检查“类”关系"></a>检查“类”关系</h3><ul>
<li><p>instanceof：<code>object instanceof constructor</code><br>在 f 的整条 <code>[[Prototype]]</code> 链中是否有指向 <code>Foo.prototype</code> 的对象</p>
<pre><code>f instanceof Foo // 通常用于检测一个“实例”是否通过指定“构造”函数“构造”而来
</code></pre>
</li>
<li><p>isPrototypeOf：<code>prototypeObj.isPrototypeOf(object)</code><br>由于<code>instanceof</code>只能处理理对象和函数之间的关系，而两个对象之间是否通过<code>[[Prototype]]</code>进行关联，则需要使用<code>isPrototypeOf</code>。它表示：在x的整条<code>[[Prototype]]</code>链中是否出现过y</p>
<pre><code>function Foo()&#123;&#125;;
var f=new Foo(&quot;Tom&quot;)
console.log(Foo.prototype.isPrototypeOf(f))      // true  在f的原型链中是否出现过Foo.prototype
console.log(Object.prototype.isPrototypeOf(f))   // true  在f的原型链中是否出现过Object.prototype
console.log(Foo.prototype.isPrototypeOf(Bar.prototype)) // true  在Bar.prototype的原型链中是否出现过Foo.prototype
</code></pre>
<p>因为Object.create()方法可以创建一个新对象，且第一个参数为新创建对象的原型对象：</p>
<pre><code>var a=&#123;&#125;;
var b= Object.create(a)
console.log(a.isPrototypeOf(b)) // true  a是否出现在b的原型链中
</code></pre>
</li>
<li><p>getPrototypeOf：<code>Object.getPrototypeOf(object)</code><br>直接获取一个对象的<code>[[Prototype]]</code>链（ES5新增）</p>
<pre><code>Object.getPrototypeOf(f)===Foo.prototype // true  3.2的例子中已展示过
</code></pre>
</li>
</ul>
<h2 id="面向类的设计"><a href="#面向类的设计" class="headerlink" title="面向类的设计"></a>面向类的设计</h2><p>上面已经反复提及到一点：在Javascript的世界中，“模拟类”不是必须的（这点不同于Java，Java没有给你选择的机会，因为Java中万物都是类），因为Javascript无需通过类就可以直接创建对象。</p>
<p>在早期版本的 JavaScript 中，“类”的定义是一个私有属性 <code>[[class]]</code>，并且只能通过<code>Object.prototype.toString</code>来访问（这个方法是js中最准确判断数据类型的方法）。纵然ES6中提供了class等关键字，但Javascript依旧是面向对象的编程语言，而非面向类。</p>
<p>虽然，JavaScript 中没有类，但由于许多开发者都非常喜欢面向类的软件设计，再加上ES6中增加的class等语法，所以很多优秀的开源框架依旧采用的面向类的设计方案，现在我们开始学习下在JS中如何模拟类。</p>
<h3 id="理解类与实例"><a href="#理解类与实例" class="headerlink" title="理解类与实例"></a>理解类与实例</h3><p>在面向类的设计中，我们需要先明白下类与示例的关系：<strong>如果拿建筑蓝图与建筑实体来做类比：建筑蓝图就是一个类，它只是建造计划，并不是真正的建筑；而依据设计蓝图建造出来的实体建筑就是一个实例：它是一个真正存在的对象</strong>。</p>
<p>类意味着复制，传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。 但在JavaScript 并不会自动创建对象的副本，而是通过原型链进行了委托。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在面向类的语言中，我们可以先定义一个类，然后定义一个继承前者的类。 后者通常被称为“子类”，前者通常被称为“父类”，这点非常类似现实中的“父亲与孩子”。<br>子类会继承父类的一些属性与方法，但是也可以重写所有继承的行为甚至定义新行为，所以子类定义好后，其实是一个完全独立的不同于父类的类。子类只是父类行为复制后的一个副本。</p>
<p>ES6之前继承常用的几种模式及其存在的缺陷（更多内容可参考<a href="https://github.com/wangminghuan/MyNotes/blob/master/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%882%EF%BC%89.md#13-%E7%BB%A7%E6%89%BF">JavaScript高级程序设计知识点-继承</a>）：</p>
<ul>
<li><p>原型链继承：子类的实例改写可能（修改引用类型数据）会影响父类</p>
</li>
<li><p>原型式继承：通过Object.create直接创建，缺陷同上</p>
</li>
<li><p>借用构造函数继承：上面3.3的例子就属于此模式；所有的属性和方法都在父类构造函数中定义，函数复用率低</p>
</li>
<li><p>寄生继承”：这是ES6之前普遍认为最理想的继承范式：</p>
<pre><code>function inheritPrototype(son, father)&#123;
  var prototype = Object.create(father.prototype); //创建对象
  prototype.constructor = son; //增强对象 将子类原型的构造函数指向自身
  son.prototype = prototype; //指定对象  将子类原型指向通过父类原型创造出来的新的原型对象
&#125;
function Animal()&#123;
  this.species = &quot;mammals&quot;;
  this.color = [&quot;white&quot;,&quot;grey&quot;];        
&#125;
Animal.prototype.sayHi=function()&#123;
  console.log(&quot;Hi!&quot;);
&#125;          
function Cat(name)&#123;
  Animal.apply(this);
  this.name = name;
&#125; 
inheritPrototype(Cat, Animal);//通过寄生函数来为父类创建出一个子类（唯一区别）
var cat1 = new Cat(&quot;Tom&quot;);
var cat2 = new Cat(&quot;Jack&quot;);
cat1.color.push(&quot;black&quot;);
console.log(cat1.color);//[&quot;white&quot;, &quot;grey&quot;, &quot;black&quot;]
console.log(cat2.color);//[&quot;white&quot;, &quot;grey&quot;]
cat1.sayHi();//&quot;Hi!&quot;
</code></pre>
</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>简单明确下多态的概念：同一个操作，作用于不同的对象，会产生不同的结果。</p>
<p>多态其实是强类型语言中的概念，本质上是为了<strong>弱化具体类型</strong>，因为强类型语言中不能给变量赋予不同类型的值，譬如<a href="https://www.jianshu.com/p/004c974a2f53">设计模式-多态</a>中对于Java来说，先创建Animal抽象类，再分别让Duck和Chicken都继承自Animal抽象类（向上转型），然后调用<code>animalSound.makeSound</code>时，传入不同的对象时，就产生了不同的结果，此时便实现了多态；</p>
<p>对于JavaScript来说，变量类型在运行期是可变的。一个JavaScript对象，既可以表示Duck类型又可以表示 Chicken 类型，这意味着 JavaScript 对象的多态性是与生俱来的。</p>
<pre><code>// 不同于强类型语言，animal可以是任意对象
var makeSound=function(animal) &#123;
  animal.sound();
&#125;;
var Duck=function()&#123;&#125;
Duck.prototype.sound=function()&#123;
  console.log(&quot;嘎嘎嘎&quot;)；
&#125;
var Chicken=function()&#123;&#125;
Chicken.prototype.sound=function()&#123;
  console.log(&quot;咯咯咯&quot;);
&#125;

makeSound(new Duck());            //嘎嘎嘎
makeSound(new Chicken());        //咯咯咯
</code></pre>
<blockquote>
<p>以上参考《JavaScript设计模式与开发实践》第一章1.2部分</p>
</blockquote>
<p>多态的概念比较复杂，在 <a href="https://zh.wikipedia.org/zh-hans/%E5%A4%9A%E6%80%81_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%29">维基百科-多态</a> 与《你不知道的JavaScript-上卷》中都有提到在<strong>面向对象程序设计中</strong>的多态：同一父类的子类对同一个讯息有不同的响应称之为多态型，也就是在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，而实现多态的两种主要表现形式为：覆盖和重载（如java/c++），JavaScript没有重载的概念，而子类覆盖父类的接口是很容易就可以实现的。在你不知道的js系列中，作者称JS的这种多态方式为相对多态或虚拟多态：任何方法都可以引用继承层次中高层的方法。</p>
<p>PS: 面向对象的语言的三大特性：封装，继承和多态，上面已经介绍了继承与多态，关于封装可参考：<a href="https://github.com/wangminghuan/MyNotes/blob/master/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%882%EF%BC%89.md#12-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">JavaScript高级程序设计知识点-封装</a></p>
<h3 id="ES6中的class"><a href="#ES6中的class" class="headerlink" title="ES6中的class"></a>ES6中的class</h3><p>在ES6中，终于提供了更接近传统语言的写法，引入了 Class（类）这个概念，更多详细介绍可参考：<a href="/ES6%E7%B3%BB%E5%88%97-5-Class%E4%B8%8EModule/">ES6系列-5-Class与Module</a>，但是无论怎么修改，class只是现有 [[Prototype]]（委托）机制的一种语法糖。</p>
<p>传统语言中的类定义之后就不会进行修改，所以类的设计模式就不支持修改，但是 JavaScript 最强大的特性之一就是它的动态性，任何对象的定义都可以修改（除非你 把它设置成不可变）</p>
<p>Class在解决了部分问题的同时又引入了其他问题：</p>
<ul>
<li><p>super执行的进行的静态绑定，，默认指向父类。这会导致部分情况下绑定到意料之外的对象上</p>
</li>
<li><p>字面语法不能声明属性(只能声明方法)，constructor方法是类的默认方法，通过new命令生成对象实例时，自动会调用该方法。如果需要所有实例之前进行属性共享时，只能通过丑陋<code>.prototype</code>来进行定义。我们通过Python语法进行一个对比：<br>Python实现一个类：</p>
<pre><code>class People:
    #定义基本属性
    sex = &#39;man&#39;
    name = &#39;&#39;
    def __init__(self,n):
        self.name = n
    def toSayHi(self):
        print(&quot;Hello %s&quot; %(self.name))

# 实例化类
p1 = People(&#39;Tom&#39;)
p2 = People(&#39;Jack&#39;)
p1.toSayHi()            # Hello Tom
p2.toSayHi()            # Hello Jack
People.sex=&#39;woman&#39;
print(p1.sex)           # woman
print(p2.sex)           # woman
print(People.sex)       # woman
</code></pre>
<p>ES6实现一个类：</p>
<pre><code>class People&#123;
  sex=&quot;man&quot;
  constructor(x) &#123;
    this.name = x;
  &#125;
  toSayHi() &#123;
    console.log(&#39;Hello &#39;+this.name)
  &#125;
&#125;
// 实例化类
var p1=new People(&quot;Tom&quot;)
var p2=new People(&quot;Jack&quot;)
p1.toSayHi();               // Hello Tom
p2.toSayHi();               // Hello Jack
console.log(People.sex)     // undefined People类下没有属性sex
p1.sex=&quot;woman&quot;
console.log(p1.sex)         // woman
console.log(p2.sex)         // man
</code></pre>
</li>
</ul>
<h2 id="面向委托的设计"><a href="#面向委托的设计" class="headerlink" title="面向委托的设计"></a>面向委托的设计</h2><p>本书最后介绍了一种“对象关联”（OLOO:objects linked to other objects）的代码风格。这种设计模式下，对象并不是按照父类到子类的关系垂直组织的，而是通过任意方向的委托关联并排组织的。</p>
<p>通过委托的方式对3.3中的例子进行改写（注意对比）：</p>
<pre><code> var Foo=&#123;
     init(name)&#123;
       this.name=name
     &#125;,
     sayHi()&#123;
      console.log(&quot;Hi,&quot;+this.name)
     &#125;
  &#125;
  var Bar=Object.create(Foo)
  Bar.inits=function(name,job)&#123;  // 必须定义不同名称的函数，以防循环调用
    this.init(name)
    this.job=job;
  &#125;
  Bar.doJob=function()&#123;
    console.log(this.name+&quot; job is &quot;+this.job)
  &#125;
  var b1=Object.create(Bar)
  b1.inits(&quot;Jack&quot;,&quot;teacher&quot;);
  b1.sayHi();                       // Hi,Jack
  b1.doJob();                       // Jack job is teacher
</code></pre>
<p>这种模式下没有出现任何构造函数、<code>.prototype</code> 或 <code>new</code>，相比“模拟类”的写法：</p>
<ul>
<li>对象的构造和初始化分开了（也没有什么不好）</li>
<li>尽量避免在 <code>[[Prototype]]</code> 链的不同级别中使用相同的命名</li>
<li>状态保存在委托者（Bar）而不是委托目标 （Foo）上</li>
</ul>
<p>没有了剪不断理还乱的<code>.prototype</code> 和<code>.constructor</code>，条理更加清晰了，更多例子可以查阅本书的176页。</p>
<p>好了，到这里《你不知道的JavaScript-上卷》已经结束了，牛年继续《你不知道的JavaScript-中卷》！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto">MDN–Object.prototype.__proto__</a></li>
<li><a href="https://www.jianshu.com/p/3d756c5bba16">简书–__proto__ 和 prototype</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">MDN–Object.create</a></li>
<li><a href="https://www.jianshu.com/p/004c974a2f53">设计模式-多态</a></li>
<li><a href="https://www.zhihu.com/question/33596850">知乎-JavaScript有多态吗？有的话怎么实现？</a></li>
<li><a href="https://www.cnblogs.com/Roylh/p/8135777.html">面向对象的JavaScript–多态</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>你不知道的js</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的JS系列-4</title>
    <url>/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E7%B3%BB%E5%88%97-4/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇开始，记录在阅读《你不知道的JavaScript-中卷》中遇到的自己遗漏的知识点，阅读章节为第一部分：类型和语法</p>
<span id="more"></span>

<h2 id="类型与值"><a href="#类型与值" class="headerlink" title="类型与值"></a>类型与值</h2><blockquote>
<p>更多内容可参考<a href="/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF3-JavaScript%E9%83%A8%E5%88%86-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">重学前端 - JavaScript部分-数据类型</a></p>
</blockquote>
<p>JavaScript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。所以在对变量执行 typeof 操作时，得到的结果并不是该变量的类型，而是该变量持有的值的类型。</p>
<p>JS的七种类型已经提及无数遍了：null、 undefined 、boolean 、string 、number 、object 和 symbol; 除了object外，其他都被称为基本类型。</p>
<p>基本类型的值只能通过复制来赋值，而Object只能通过引用进行复制，与指针不同，无论多少个引用，最终指向的都是同一个值（函数的参数传递也遵循该规则）。</p>
<p>下面补充几种常见类型中的知识点：</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>使用 delete 运算符可以将单元从数组中删除，但是单元删除后，数组的 length 属性并不会发生变化</li>
<li>类数组转换（如NodeList, arguments）常用方法：<pre><code>Array.prototype.slice.call( document.querySelectorAll(&quot;.goods-info&quot;) )
Array.from( arguments )
</code></pre>
</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li>字符串经常被当作”字符数组”，因为字符串的很多方法都与字符串数组类似，但二者不一样：字符串不可修改，数组值可修改</li>
<li>字符串可以调用数组的多数方法，除了<code>reverse</code>（字符串值不可变）<pre><code>Array.prototype.map.call(&quot;abc&quot;, function(v)&#123;
  return v.toUpperCase() + &quot;.&quot;;
  &#125;).join(&quot;&quot;); //A.B.C
</code></pre>
</li>
</ul>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><ul>
<li><p>JavaScript 没有真正意义上的整数: <code>42.0 === 42</code></p>
</li>
<li><p><code>toPrecision</code> 方法用来指定有效数位的显示位数：</p>
<pre><code>  (42.59).toPrecision(5) //&quot;42.590&quot;
  (42.59).toPrecision(3) //&quot;42.6&quot;
</code></pre>
</li>
<li><p><code>42..tofixed(3)</code> 与 <code>42 .tofixed(3)</code> 可以被引擎正常解析，但不推荐使用</p>
</li>
<li><p>数字类型有几个特殊值：<code>NaN</code>、<code>+Infinity</code>、<code>-Infinity</code> 和 <code>-0</code>。NaN 是一个特殊值，它和自身也不相等, 表示值是“不是数字的数字”，是数字类型运算过程中产生的错误值。<code>window.isNaN</code> 的检测有bug: <code>window.isNaN(&#39;foo&#39;)===true</code>, 推荐使用ES6的 <code>Number.isNaN</code></p>
</li>
<li><p>JavaScript存在 <code>0</code> 与 <code>-0</code>, 且 <code>-0===0</code>，判断方法见下方isNegZero方法；符号用来表示其他信息（如移动方向），所以存在是有必要的</p>
</li>
<li><p><a href="/ES6%E7%B3%BB%E5%88%97-2-%E6%96%B0%E5%A2%9E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/">ES6 提供了二进制和八进制数值的新的写法</a></p>
</li>
<li><p>几个polyfill写法：</p>
<pre><code>/*
 @desc 判断两个小数是否相等
*/

if (!Number.EPSILON) &#123;  // Number.EPSILON为指定误差，ES6 下无需添加 
  Number.EPSILON = Math.pow(2,-52);
&#125;
function numbersCloseEnoughToEqual(n1,n2) &#123;
  return Math.abs( n1 - n2 ) &lt; Number.EPSILON;
&#125;
console.log(numbersCloseEnoughToEqual( 0.1+0.2, 0.3 )); // true
console.log(numbersCloseEnoughToEqual( 0.0000001, 0.0000002 )); // false

/*
 @desc 判断是否为-0
*/
function isNegZero(n) &#123;
  n = Number( n );
  return (n === 0) &amp;&amp; (1 / n === -Infinity);
&#125;
/*
 @desc  Number.isInteger ES6之前的polyfill
*/
if (!Number.isInteger) &#123;
  Number.isInteger = function(num) &#123;
    return typeof num == &quot;number&quot; &amp;&amp; num % 1 == 0;
  &#125;;
&#125;

/*
 @desc  Number.isSafeInteger ES6之前的polyfill
*/
if (!Number.isSafeInteger) &#123;
  Number.isSafeInteger = function(num) &#123;
    return Number.isInteger( num ) &amp;&amp;
      Math.abs( num ) &lt;= Number.MAX_SAFE_INTEGER;
  &#125;; 
&#125;

/*
 @desc  Number.isNaN ES6之前的polyfill
*/
if (!Number.isNaN) &#123;
  Number.isNaN = function(n) &#123;
    return (
      typeof n === &quot;number&quot; &amp;&amp;
      window.isNaN( n )
    ); 
 &#125;;
&#125;

/*
 @desc  Object.is ES6之前的polyfill
*/
if (!Object.is) &#123;
  Object.is = function(v1, v2) &#123;
    // 判断是否是-0
    if (v1 === 0 &amp;&amp; v2 === 0) &#123;
      return 1 / v1 === 1 / v2;
    &#125;
    // 判断是否是NaN
    if (v1 !== v1) &#123;
      return v2 !== v2;
    &#125;
    // 其他情况
    return v1 === v2;
  &#125;;
&#125;
</code></pre>
</li>
</ul>
<h2 id="原生函数"><a href="#原生函数" class="headerlink" title="原生函数"></a>原生函数</h2><p>下面介绍下与数据类型相关的十个内建函数, 之前也已经介绍过，每一种基本类型在对象中都有对应的内置函数，且在操作过程中，引擎会自动进行装箱/拆箱转换</p>
<h3 id="String-Number-Boolean"><a href="#String-Number-Boolean" class="headerlink" title="String / Number / Boolean"></a>String / Number / Boolean</h3><p>对于字符串/数字/布尔类型的数据，多数情况下都是使用字面量进行操作的（性能更优），基本很少使用对应的内置函数进行创建：</p>
<pre><code>var a = new String( &quot;abc&quot; );
var b = new Number( 42 );
var c = new Boolean( true );

// 通过new关键字创建的是字符串的封装对象，而非基本类型值
a.valueOf(); // &quot;abc&quot;
b.valueOf(); // 42
c.valueOf(); // true 
</code></pre>
<p>不推荐使用构造函数来创建基本数据类型，会产生很多副作用</p>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>构造函数 <code>Array()</code> 不要求必须带 <code>new</code> 关键字 <code>new Array(3)</code> 与 <code>Array(3)</code>是等效的, 返回的都是一个数组；不过构造函数调用时返回的稀疏数组（将包含至少一个“空单元”的数组称为“稀疏数组”）令人有些困惑：</p>
<pre><code>  Array(3)  //[empty × 3]
</code></pre>
<p>不同浏览器展示的结果有些不同，上面结果为chrome 88 版本下的结果，接下来对这个稀疏数组进行方法调用：</p>
<pre><code> Array(3).map((item)=&gt;&#123;console.log(item)&#125;) // 不执行
 Array(3).join(&quot;-&quot;)  // &quot;--&quot;
</code></pre>
<p>map方法对于只有空单元的数据不执行，而join方法却可以。我们可以通过下述方式来创建包含 undefined 单元（而非“空单元”）的数组来避免上述问题的发生：</p>
<pre><code>Array.apply(null,&#123;length:3&#125;) // [undefined, undefined, undefined]
</code></pre>
<h3 id="Object-Function-RegExp"><a href="#Object-Function-RegExp" class="headerlink" title="Object / Function / RegExp"></a>Object / Function / RegExp</h3><p>除了RegExp外，Object 与 Function这两个构造函数很少用到，不是必须也不建议使用。</p>
<p>PS: 在chrome 88下测试，<code>new</code> 关键字可以省略，且JavaScript 有一处奇特的语法，即构造函数没有参数时可以不用带<code>()</code>调用</p>
<pre><code>  Function() instanceof Function       // true
  new Function() instanceof Function   // true

  Object() instanceof Object           // true
  new Object() instanceof Object       // true

  new RegExp instanceof RegExp          // true
  RegExp() instanceof RegExp           // true
</code></pre>
<h3 id="Date-Error"><a href="#Date-Error" class="headerlink" title="Date / Error"></a>Date / Error</h3><p>Date 与 Error是经常用到的两个内置函数</p>
<pre><code>  (new Date()).getTime()     // 获取当前时间戳
  throw new Error(&quot;error&quot;)  // 抛出错误
</code></pre>
<p>在chrome 88下测试，<code>Error(&#39;error&#39;)</code> 等同于 <code>new Error(&#39;error&#39;)</code>, 但是Date 加new与不加new调用时，结果不一致：</p>
<pre><code> var d=Date();           // &quot;Mon Feb 22 2021 17:05:10 GMT+0800 (中国标准时间)&quot;
 d instanceof Date;      // false
 typeof d;               // string

 var _d=new Date();      // Mon Feb 22 2021 17:06:50 GMT+0800 (中国标准时间)
 _d instanceof Date      // true
</code></pre>
<p>所以，如果就是需要进行构造函数调用，建议加上<code>new</code>关键字，以免产生意想不到的结果，同时也便于理解。</p>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>作为ES6新进成员，此处不再赘述，Symbol函数只能直接调用，无法通过构造函数调用：</p>
<p><code>new Symbol(&#39;&#39;)</code> 会直接报错：<code>Uncaught TypeError: Symbol is not a constructor</code></p>
<p>很显然，Symbol并非构造函数~</p>
<p>PS: 此处插一个知识点：ES6 允许Symbol到String的显式强制类型转换，隐式强制转换会报错：</p>
<pre><code>  var s1 = Symbol( &quot;cool&quot; );
  String( s1 );  // &quot;Symbol(cool)&quot;
  s1 + &#39;&#39;;       // Uncaught TypeError: Cannot convert a Symbol value to a string
   
</code></pre>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>作为动态语言，JavaScript 中所有的类型转换可称之为：强制类型转换，同时分为显式与隐式；转换规则可参考<a href="/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-JavaScript%E9%83%A8%E5%88%86-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">重学前端-JavaScript部分</a>，里面介绍的比较详细，下面部分为补充部分</p>
<h3 id="类型转换规则"><a href="#类型转换规则" class="headerlink" title="类型转换规则"></a>类型转换规则</h3><h4 id="ToString-amp-amp-ToNumber"><a href="#ToString-amp-amp-ToNumber" class="headerlink" title="ToString &amp;&amp; ToNumber"></a>ToString &amp;&amp; ToNumber</h4><p>从 ES5 开始，使用 Object.create(null) 创建的对象 [[Prototype]] 属性为 null，并且没有 valueOf() 和 toString() 方法，因此无法进行强制类型转换</p>
<pre><code>  String(Object.create(null)) // Cannot convert object to primitive value
  Number(Object.create(null)) // Cannot convert object to primitive value
</code></pre>
<p>补充：<strong>JSON 字符串化</strong></p>
<p>执行<code>JSON.stringify(...)</code>即可得到JSON字符串化的结果，那内部的实现逻辑又是怎样？</p>
<p>类似其他类型转化为字符串时调用内部的<code>toString</code>方法，JSON转化为字符串时调用内部的<code>toJSON</code>方法，不同的是：得到结果后还会再进行一步字符串化操作：</p>
<pre><code>  var o=&#123;
    a:1,
    toJSON: function()&#123;
      return &#123;
        b:this.a *10
      &#125;
    &#125;
  &#125;
  JSON.stringify(o) // &quot;&#123;&quot;b&quot;:10&#125;&quot;
</code></pre>
<p><code>toJSON()</code> 需要“返回一个能够被字符串化的安全的 JSON 值”。</p>
<p><strong>JSON.stringify(value[, replacer [, space]])</strong></p>
<ul>
<li>replacer: 可选参数，它可以是数组或者函数<pre><code>  var a=&#123;
    b: 42,
    c: &quot;42&quot;,
    d: [1,2,3]
  &#125;
  /*replacer为数组时，只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中*/
  JSON.stringify(a, [&quot;b&quot;,&quot;c&quot;]) // &quot;&#123;&quot;b&quot;:42,&quot;c&quot;:&quot;42&quot;&#125;&quot;
  
  /* replacer为函数时，在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理
  在开始时, replacer 函数会被传入一个空字符串作为 key 值，代表着要被 stringify 的这个对象。随后每个对象或数组上的属性会被依次传入
  */
  JSON.stringify(a, function(k,v)&#123;
    if(k!==&#39;d&#39;) return v
  &#125;)
  // &quot;&#123;&quot;b&quot;:42,&quot;c&quot;:&quot;42&quot;&#125;&quot;
</code></pre>
</li>
<li>space:可选参数，指定缩进用的空白字符串，用于美化输出</li>
</ul>
<p>总结：整个转换过程遵循如下原则：</p>
<ul>
<li>字符串、数字、布尔值和 null 的 JSON.stringify(..) 规则与 ToString 基本相同。</li>
<li>如果传递给 JSON.stringify(..) 的对象中定义了 toJSON() 方法，那么该方法会在字符<br>串化前调用，以便将对象转换为安全的 JSON 值。</li>
</ul>
<h4 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h4><p>以下为可以显式转换为false的值：</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>false</li>
<li>+0、-0 和 NaN</li>
<li>“”</li>
</ul>
<p>JavaScript 代码中会出现假值对象，如document.all：它是一个类数组对象，包含了页面上的所有元素。但现在在多数浏览器上强制转换结果却是false:</p>
<pre><code>  Boolean(document.all)  // false
</code></pre>
<p>这个是浏览器厂商因为一些其他因素强制改写的结果，注意避免掉坑。</p>
<h3 id="显式强制类型转换"><a href="#显式强制类型转换" class="headerlink" title="显式强制类型转换"></a>显式强制类型转换</h3><p>String(..) , Number(..) , Boolean(..), .toString(..)方法都可以实现类型强制转换。除此以外还有一些其他情况：</p>
<h4 id="日期转换为数字"><a href="#日期转换为数字" class="headerlink" title="日期转换为数字"></a>日期转换为数字</h4><pre><code>      +new Date() === +new Date;
      +new Date() === Date.now();
      +new Date() === new Date().getTime();
</code></pre>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符(~)"></a>位运算符(~)</h4><p>按位非（NOT）运算符~经常出现，它可以用在以下两种情况下：<strong>判断x的值是否大于-1</strong> 和 <strong>截除掉数字值的小数部分</strong></p>
<p>可以记住以下等式：<code>~x = -(x+1)</code>，多数情况下都是适用的。在查找索引过程中可以这样改写：</p>
<pre><code>  var msg=&quot;Hello World&quot;
  if(!~msg.indexOf(&quot;success&quot;))&#123;
    // 只有msg.indexOf(&quot;success&quot;)==-1的情况下才执行
    console.log(&quot;error&quot;)
  &#125;
</code></pre>
<p>PS: 由 -(x+1) 推断 ~-1 的结果应该是 -0，然而实际上结果是 0，因为它是字位操作而非数学运算。</p>
<p>两个波浪线时可用作截除数字值的小数部分：</p>
<pre><code>  ~~-49.6; // -49
  
</code></pre>
<h4 id="数字字符串的解析"><a href="#数字字符串的解析" class="headerlink" title="数字字符串的解析"></a>数字字符串的解析</h4><ul>
<li><p>解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止</p>
</li>
<li><p>转换不允许出现非数字字符，否则会失败并返回 NaN</p>
<pre><code>parseInt( &quot;40px&quot; ); // 42 直解析数字字符串，其他类型会先强制转换成字符串
Number( &quot;40px&quot; ); // NaN
</code></pre>
</li>
</ul>
<p>PS: parseInt在ES5之前存在bug，会根据字符串的第一个字符来决定转换基数，避免这个问题需要强制：<code>parseInt(xxx,10)</code></p>
<h3 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h3><p>觉得不够明显的强制类型转换都可以归到隐式强制类型转换下，隐式转换虽然被人诟病，但它可以减少冗余，让代码更简洁</p>
<h4 id="字符串-lt-gt-数字-（-）"><a href="#字符串-lt-gt-数字-（-）" class="headerlink" title="字符串 &lt;=&gt; 数字 （+/-）"></a>字符串 &lt;=&gt; 数字 （+/-）</h4><p>我们都知道 <code>+</code> 运算符即能用于数字加法，也能用于字符串拼接，依照的规则可以概括为：</p>
<p><strong>如果 + 的其中一个操作数是字符串（或通过ToPrimitive操作能转换成字符串），则执行字符串拼接；否则执行数字加法</strong></p>
<p>看个例子：</p>
<pre><code> [1,3] + [5]  // &quot;1,35&quot;
</code></pre>
<p>数组valueOf操作无法得到基本数据类型，使用toString方法两个数据就转换成对应了字符串</p>
<p>同时需要注意的是：<code>a + &quot;&quot;</code> 会对 a 调用 valueOf 方法，而<code>String(a)</code> 则是直接调用 ToString操作</p>
<p><code>- </code>运算符是数字减法，因此 a - 0 会将 a 强制类型转换为数字，再看一个例子：</p>
<pre><code>  [3] - [1]; // 2
</code></pre>
<p>数组先转换成字符串，然后再转换成Number进行运算</p>
<h4 id="其他类型-gt-布尔值"><a href="#其他类型-gt-布尔值" class="headerlink" title="其他类型 =&gt; 布尔值"></a>其他类型 =&gt; 布尔值</h4><p>以下情况数据会被强制转换为布尔值：</p>
<ul>
<li>if (..) 语句中的条件判断表达式。</li>
<li>for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。</li>
<li>while (..) 和 do..while(..) 循环中的条件判断表达式。</li>
<li>? : 中的条件判断表达式。</li>
<li>逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</li>
</ul>
<p>逻辑运算符 <code>||</code> 和 <code>&amp;&amp;</code>, 返回值是两个操作数中的一个（且仅一个）；这与Java,php等语言返回布尔值不同，在 JavaScript（以及 Python 和 Ruby）返回的是某个操作数的值，所以更准确的称呼应该是“选择器运算符”或者“操作数选择器运算符”</p>
<h3 id="与"><a href="#与" class="headerlink" title="== 与 ==="></a>== 与 ===</h3><p>宽松相等（==）与严格相等（===）里面的坑是最多的，也是让人吐槽最多的地方，主要集中在宽松相等的判定规则有时候让人琢磨不透。二者的区别可以这么理解：**== 允许在相等比较中进行强制类型转换，而 === 不允许**</p>
<h4 id="字符串与数字之间的相等比较"><a href="#字符串与数字之间的相等比较" class="headerlink" title="字符串与数字之间的相等比较"></a>字符串与数字之间的相等比较</h4><ul>
<li>如果 Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y) 的结果。</li>
<li>如果 Type(x) 是字符串，Type(y) 是数字，则返回 ToNumber(x) == y 的结果。</li>
</ul>
<pre><code>  0 == &quot;&quot;  // true
  &quot;42&quot; == 42  // true
  
</code></pre>
<p>也就是说：<strong>在==中，如果两边分别为Number 与 String类型，就将String类型转化为Number类型再比较</strong></p>
<h4 id="其他类型与布尔值之间的相等比较"><a href="#其他类型与布尔值之间的相等比较" class="headerlink" title="其他类型与布尔值之间的相等比较"></a>其他类型与布尔值之间的相等比较</h4><ul>
<li>如果 Type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果；</li>
<li>如果 Type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果。</li>
</ul>
<pre><code> false == 0    // true
 &quot;42&quot; == true // false  true先转化为1，再依据上面规则“42”会转化为数字42，故不相等
</code></pre>
<p>也就是说：<strong>在==中，如果两边分别为Boolean 与其他类型，就将Boolean类型转化为Number类型再比较</strong></p>
<h4 id="null-与-undefined之间的比较"><a href="#null-与-undefined之间的比较" class="headerlink" title="null 与 undefined之间的比较"></a>null 与 undefined之间的比较</h4><ul>
<li>如果 x 为 null，y 为 undefined，则结果为 true。</li>
<li>如果 x 为 undefined，y 为 null，则结果为 true</li>
</ul>
<p>也就是说：<strong>在 == 中 null 和 undefined 相等（它们也与其自身相等），除此之外其他值都不存在这种情况</strong></p>
<h4 id="对象与非对象之间的相等比较"><a href="#对象与非对象之间的相等比较" class="headerlink" title="对象与非对象之间的相等比较"></a>对象与非对象之间的相等比较</h4><blockquote>
<p>下面转化规则只提到了字符串和数字，没有布尔值，因为布尔值会先被转化为数字</p>
</blockquote>
<ul>
<li>如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果</li>
<li>如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果</li>
</ul>
<pre><code>0==[]                           // true
Object(&#39;abc&#39;) == &quot;abc&quot;          // true
Object(undefined) == undefined  // false
Object(null) == null            // false
</code></pre>
<p>也就是说：<strong>在 == 中 对象会通过ToPromitive进行转换为基本类型，再进行后续比较</strong></p>
<h4 id="其他少见情况"><a href="#其他少见情况" class="headerlink" title="其他少见情况"></a>其他少见情况</h4><p>先看如下代码：</p>
<pre><code>  &quot;0&quot; == false;     // true
  false == 0;       // true
  false == &quot;&quot;;      // true
  false == [];      // true  []转化为&quot;&quot;  false 转化为 0 即0 == &quot;&quot;
  &quot;&quot; == 0;          // true  &quot;&quot;转化为数字0
  &quot;&quot; == [];         // true
  0 == [];          // true
  &quot;&quot; == 0;          // true
  &quot;&quot; == [];         // true
  0 == [];          // true

  [] == ![];         // true  ![]转化为false  即 [] == false
  [] == [];          // false  两个都是引用类型，直接比较引用对象

  0 == &quot;\n&quot;          // true  Number(&quot;\n&quot;)==0
</code></pre>
<p>其实，只要按上面的规则进行对照，都能迎刃而解，不过为了避免出错，可以遵循以下两个原则：</p>
<ul>
<li>如果两边的值中有 true 或者 false，千万不要使用 ==</li>
<li>如果两边的值中有 []、”” 或者 0，尽量不要使用 ==</li>
</ul>
<p>这样可以最大程度的避免强制类型转换的坑。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h3><blockquote>
<p>更多详细内容可访问：<a href="https://github.com/wangminghuan/MyNotes/blob/master/JavaScript/js%E4%B8%AD%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5.md">github笔记-js中表达式和语句</a></p>
</blockquote>
<ul>
<li><p>语句都有一个结果值, chrome下的开发控制台（JavaScript REPL——read/evaluate/print/loop）显示的就是语句的结果值。</p>
</li>
<li><p>代码块的结果值就是最后一个语句的结果值</p>
</li>
</ul>
<h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p>逗号操作符可以在一条语句中执行多个操作，常用于声明多个变量；</p>
<pre><code>var num1=1, num2=2, num3=3; 
</code></pre>
<p>除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项：</p>
<pre><code>var num = (5, 1, 4, 8, 0); // num 的值为 0 
</code></pre>
<p>可以使用逗号运算符将多个表达式串联为一个语句：</p>
<pre><code>var a = 42;
var a1 = 42;
var a2 = 42;
var b = (a++, a)  // 执行a, 再执行+1操作, 最终返回a的值
var c = a1++,a1   // 把a1赋值给c, 再执行+1操作, 然后又声明了一次a1
var d = (a2++)   // 括号无法提升+1的执行顺序，等同于 var d = a2++

a // 43
a1 // 43
a2 // 43
b // 43  
c // 42
d // 42
</code></pre>
<h3 id="上下文规则"><a href="#上下文规则" class="headerlink" title="上下文规则"></a>上下文规则</h3><p>js中同样的语法上下文不同，则会导致不同的结果：</p>
<h4 id="大括号"><a href="#大括号" class="headerlink" title="大括号{}"></a>大括号{}</h4><p>我们看一个例子：</p>
<pre><code>  var a = &#123;
    foo : bar()  //假设bar已经定义过
  &#125;
</code></pre>
<p>去掉 var声明后，代码扔不会报错：</p>
<pre><code>&#123;
  foo : bar()
&#125;
</code></pre>
<p>不过，此时上面的代码已经不是一个对象了，它是一个代码块，且foo 是语句 bar() 的标签，关于“标签语句”我们此处不再展开。那如果我们尝试这样改写，那么就会报错了：</p>
<pre><code>&#123;
  &quot;foo&quot;:bar()
&#125;
</code></pre>
<p>因为标签不允许使用双引号，所以 “foo” 并不是一个合法的标签。同样的我们需要注意：<strong>JSON 的确是 JavaScript 语法的一个子集，但是 JSON 本身并不是合法的 JavaScript 语法</strong></p>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>我们看下如下代码：</p>
<pre><code>[] + &#123;&#125;   // &quot;[object Object]&quot;
&#123;&#125; + []   // 0
</code></pre>
<p>原因如下：{} 出现在 + 运算符表达式中，会被当作一个值（空对象）来处理，而[] 强制类型转换后为 “”，因此会得到{} 执行<code>toString</code>后的结果；{} 先出现时，会被解析为空代码块，而代码块后面的分号可以省略，<code>+[]</code> 就被强制转换为0</p>
<h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><p>{ .. } 也可用于“解构赋值”</p>
<pre><code>  var obj=&#123;
    a:1,
    b:2
  &#125;
  var &#123;a,b&#125;=obj
  console.log(a,b)  // 1,2

  function add(&#123;a,b&#125;)&#123;
    return a+b
  &#125;
  console.log(add(obj)) // 3
</code></pre>
<h4 id="不存在的else-if语法"><a href="#不存在的else-if语法" class="headerlink" title="不存在的else if语法"></a>不存在的else if语法</h4><p>事实上 JavaScript 没有 else if, 只存在 if else</p>
<pre><code>if(a==1)&#123;
  console.log(&quot;if&quot;)
&#125;else if(a==2)&#123;
  console.log(&quot;else&quot;)
&#125;
</code></pre>
<p>等同于：</p>
<pre><code>if(a==1)&#123;
  console.log(&quot;if)
&#125;else &#123;
    if(a==2)&#123;
        console.log(&quot;else)
    &#125;
&#125;
</code></pre>
<h3 id="自动分号"><a href="#自动分号" class="headerlink" title="自动分号"></a>自动分号</h3><p>JavaScript 有时会自动为代码行补上缺失的分号，即自动分号插入（Automatic Semicolon Insertion，ASI），且ASI 只在换行符处起作用，而不会在代码行的中间插入分号。</p>
<p>以下情况会执行ASI:</p>
<ul>
<li> 表达式语句: <code>var a = 42, b</code></li>
<li> do..while 循环后面</li>
<li> break、continue、return 和 yield（ES6）等关键字后</li>
</ul>
<p>ASI本质上更像一种“纠错机制”，所以能加分号的地方还是建议都手动加上。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p>函数传递参数时，arguments 数组中的对应单元会和命名参数建立关联；否则不传参时不会建立关联</p>
</li>
<li><p>switch判断时，执行的判断规则等同”===”操作</p>
</li>
<li><p>try..catch..finally中，finally的返回值会“覆盖”try 和 catch 中 return 的返回值。</p>
</li>
<li><p>除了js外，HTML 页面中的内容也会产生全局变量，如：<code>&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;</code> 就会创建一个全局foo变量，其值为该dom节点</p>
</li>
<li><p>对原生对象添加扩展功能时，注意向上兼容</p>
</li>
<li><p>内联代码中不可以出现 <code>&lt;/script</code>&gt; 字符串，一旦出现即被视为代码块结束：</p>
<pre><code>  &lt;script&gt;
    var code = &quot;&lt;script&gt;alert(&#39;Hello World&#39;)&lt;/scr&quot; + &quot;ipt&gt;&quot;;  // 规避报错
  &lt;/script&gt;
</code></pre>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.w3school.com.cn/js/pro_js_operators_bitwise.asp">ECMAScript 位运算符</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>你不知道的js</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的JS系列-5</title>
    <url>/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E7%B3%BB%E5%88%97-5/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本篇开始，记录在阅读《你不知道的JavaScript-中卷》中遇到的自己遗漏的知识点，阅读章节为第二部分：异步与性能</p>
<span id="more"></span>

<h2 id="异步发展史"><a href="#异步发展史" class="headerlink" title="异步发展史"></a>异步发展史</h2><p>ES6 之前，JavaScript 中发异步编程主要就是靠回调函数来完成的。ES6 出现后，JavaScript 才算真正内建有直接的异步概念。</p>
<h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><p>以Chrome为例，启动后，只要访问任意网站，至少要启动：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。我们也经常听到进程与线程的概念，此处，做下简单说明：</p>
<ul>
<li>进程：一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。</li>
<li>线程：线程是不能单独存在的，它是由进程来启动和管理的。线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。</li>
</ul>
<h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><p>对于Chrome浏览器来说，每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是事件循环系统(Event Loop)。Event Loop中的任务在每个tick中是顺序执行的(一次只能从队列中处理一个事件)，不会存在并行的可能。</p>
<p>关于Event Loop 可参考之前的文章：<a href="/Nodejs%E7%B3%BB%E5%88%97-2-EventLoop/">Nodejs系列-2-EventLoop</a></p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流程的方式是非线性的、非顺序的，这使得正确推导这样的代码难度很大</p>
<p>回调函数这种异步模式最大的问题在于：控制反转，它会导致信任链的完全断裂。也就是将程序一部分的执行控制交给了某个异步程序去执行，执行过程可能会发生下面各种异常状况（包括但不限于）：</p>
<ul>
<li>调用回调过早（在追踪之前）；</li>
<li>调用回调过晚（或没有调用）；</li>
<li>调用回调的次数太少或太多（就像你遇到过的问题！）；</li>
<li>没有把所需的环境 / 参数成功传给你的回调函数；</li>
<li>吞掉可能出现的错误或异常；</li>
</ul>
<p>而嵌套的回调方式被称之为：回调地狱（callback hell），</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>由于回调函数本身存在的问题，ES6标准新增了另外一种异步解决方案：Promise。关于Promise的介绍可参考<a href="/ES6%E7%B3%BB%E5%88%97-6-%E5%BC%82%E6%AD%A5/">ES6系列-6-异步</a></p>
<p>这里我们只记录几点自己遗漏的知识点：</p>
<ul>
<li><p>在回调中，一些模式化的错误处理方式已经出现，最值得一提的是 error-first 回调风格（nodejs设计了大量此风格的API）</p>
</li>
<li><p>Promise常见的三个术语：决议（resolve）、完成（fulfill）和拒绝（reject）</p>
</li>
<li><p><code>Promise.resolve(obj) == obj</code> 可以用来检测是obj否为Promise对象</p>
</li>
<li><p>Promise对象的then方法会自动创建一个新的 Promise 从调用返回（相当于将then函数的返回值用Promise.resolve过滤了下），可以无限链式调用下去</p>
</li>
<li><p>Promise.prototype.finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>你不知道的js</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的JS系列-6</title>
    <url>/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E7%B3%BB%E5%88%97-6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><span id="more"></span>

<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ul>
<li>语句由一个或多个表达式组成</li>
<li>一个独立的表达式也可以称为表达式语句</li>
<li>JavaScript 引擎实际上是动态编译程序，然后立即执行编译后的代码</li>
<li>在 JavaScript 中作为常量的变量用大写表示，多个单词之间用下划线 _ 分隔</li>
<li>JavaScript 中，只有值有类型；变量只是这些值的容器</li>
<li>如果一个函数内部有一个 this 引用，那么这个 this 通常指向一个对象。但它指向的是哪个对象要根据这个函数是如何被调用来决定。this 并不指向这个函数本身</li>
<li>默认值表达式是惰性求值的，这意味着它们只在需要的时候运行</li>
</ul>
<h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p>对象的结构赋值，与常见的赋值逻辑相反：</p>
<pre><code>const &#123; a: X, b: Y &#125;=&#123;a:10,b:20&#125;
const &#123;M,N&#125;=&#123;M:1,N:2&#125;
console.log([X,Y])  // [10,20]
console.log([M,N])  // [1,2]
</code></pre>
<p>常规赋值是，<code>target:source</code> 模式，从上面例子可以看到他是反转的，将<code>:</code>左侧的值赋值给右侧，即<code>source:target</code> 模式</p>
<h3 id="简洁属性-方法"><a href="#简洁属性-方法" class="headerlink" title="简洁属性/方法"></a>简洁属性/方法</h3><p>ES6中可以将对象的属性简化:</p>
<pre><code>  const x = 2, y = 3, 
  o = &#123; 
    x, 
    y 
  &#125;
</code></pre>
<p>同样，对于方法也可以简化</p>
<pre><code>const o=&#123;
  x(n)&#123;
    return n
  &#125;,
  y(m)&#123;
    return m
  &#125;
&#125;;
</code></pre>
<p>但是这种简洁写法也存在一定弊端，譬如内部引用时：</p>
<pre><code>const run=&#123;
  some:function some(x,y)&#123;
    if(x&lt;y) return some(y,x)
    return x-y
  &#125;
&#125;
console.log(run.some(1,4))
console.log(run.some(4,1))
</code></pre>
<p>此时我们无法用简洁模式表达(或者说会产生其他隐患问题)，但需来取即可</p>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><h3 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h3><p>模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）</p>
<pre><code>const a=10;
const b=2;
function foo(...arg)&#123;
  console.log([...arg])
&#125;
foo`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`; //  [[ &#39;Hello &#39;, &#39; world &#39;, &#39;&#39; ], 12, 20 ]
</code></pre>
<p>从上面例子也可以看出等同于<code>foo([ &#39;Hello &#39;, &#39; world &#39;, &#39;&#39; ], 12, 20)</code></p>
<p>标签模板调用函数时，函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分；被替换的部分作为后续参数依次传入。</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>在箭头函数内部，this 绑定不是动态的，而是词法的</p>
<h3 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for of 循环"></a>for of 循环</h3><p>JavaScript 中默认为（或提供）iterable 的标准内建值包括：</p>
<ul>
<li>Arrays </li>
<li>Strings</li>
<li>Generators（迭代器）</li>
<li>Collections / TypedArrays ( 类数组）</li>
</ul>
<p>普通对象并不适用for of循环</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>你不知道的js</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的npm init</title>
    <url>/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84npm%20init/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在捣鼓egg 跟 koa，看到egg官网文档快速初始化是这么写的：</p>
<pre><code>  $ mkdir egg-example &amp;&amp; cd egg-example
  $ npm init egg --type=simple
  $ npm i
</code></pre>
<p>手动黑人问号脸…，看来<code>npm init</code>还有我不知道的用法, 我们来进行”刨根问底”</p>
<span id="more"></span>
<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>一个标准nodejs项目，package.json就是项目的入口与说明描述。其中常用字段含义如下：</p>
<pre><code>name: 项目的名称
version: 项目的版本
description: 项目的描述信息，在NPM中描述包的重要搜索内容
keywords: 一个数组，从字面意思也可知道描述项目的关键词，也有利于搜索
license: 该项目的协议，是否允许商用等权限，有MIT、ISC、GPL等
author: 项目的作者
contributors: 项目的贡献者
main: 项目的入口文件
private: 是否是私有库
bin:用来指定各个内部命令对应的可执行文件的位置
files:项目根目录的文件夹名, 如：[&quot;lib&quot;, &quot;src&quot;, &quot;package&quot;, &quot;types&quot;]
repository:记录项目代码所在的资源库
homepage:项目主页URL
bugs:提交bug的地方
style:指定样式文件所在的位置
scripts:指定了运行npm命令缩写
dependencies: 项目运行所依赖的模块
devDependencies: 项目开发所需要的模块，在生产中不需要
peerDependencies:用来供插件指定其所需要的主工具的版本
</code></pre>
<p>其中，bin的作用有点类似别名：</p>
<pre><code>&#123;
  &quot;bin&quot;: &#123;
    &quot;test&quot;: &quot;./bin/test.js&quot;
  &#125;,
  &quot;script&quot;: &#123;
    &quot;start&quot;: &quot;test build&quot;
  &#125;
&#125;
</code></pre>
<p>peerDependencies的作用举个例子：A模块是B模块的插件，然而用户安装了B模块1.0版本，但是A插件只能和2.0版本的B模块一起使用，这时需要提醒用户需要安装的是B的2.0版本</p>
<pre><code>&#123;
  &quot;peerDependencies&quot;: &#123;
    &quot;vue&quot;: &quot;^2.5.17&quot;
  &#125;
&#125;
</code></pre>
<h2 id="npm-init"><a href="#npm-init" class="headerlink" title="npm init"></a>npm init</h2><p>npm 官方提供了 npm init 命令帮助我们快速初始化 package.json 文件, 相信大家都用过，需要一步步确认。同时还支持添加参数 <code> -y</code>（yes的意思） 来快速初始化</p>
<p><img src="./1.png"></p>
<p>随着技术的快速发展，发现初始化 package.json 已经无法满足大家的需求了，越来越多的项目需要进行整个项目的初始化。很多项目也会开发针对自己项目的脚手架工具，例如 vue-cli, create-react-app。运行这些工具需要先使用 <code>npm install -g</code> 全局安装这些脚手架工具，然后利用脚手架再来初始化项目，如vue项目的初始化：</p>
<pre><code>  npm install -g @vue/cli

  vue create hello-world
</code></pre>
<p>从<a href="mailto:&#110;&#x70;&#x6d;&#64;&#53;&#46;&#x32;&#46;&#x30;">&#110;&#x70;&#x6d;&#64;&#53;&#46;&#x32;&#46;&#x30;</a> 开始，安装npm时自动提供了 npx 命令</p>
<h2 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h2><p>那npx到底有啥用？主要有两个用途：</p>
<h3 id="轻松地运行本地命令"><a href="#轻松地运行本地命令" class="headerlink" title="轻松地运行本地命令"></a>轻松地运行本地命令</h3><p>通常我们安装指定node包（以@vue/cli为例），需要运行：</p>
<pre><code>npm install @vue/cli
</code></pre>
<p>此时本地项目就会安装对应的node_modules:</p>
<p><img src="./2.png"></p>
<p>如果想使用<code>vue</code>命令的话，运行</p>
<pre><code>vue --V
</code></pre>
<p>那么毫无意外，一定会报错，因为只有全局安装的包才可以直接调用，或者直接指定路径调用</p>
<p><img src="./3.png"></p>
<p>又或者通过自定义script脚本，通过npm 来进行调用：</p>
<pre><code>&quot;scripts&quot;: &#123;
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;vue&quot;:&quot;./node_modules/.bin/vue -V&quot;
  &#125;
</code></pre>
<p><img src="./4.png"></p>
<p>但npx 出现以后，我们可以更优雅的执行本地命令</p>
<p><img src="./5.png"></p>
<p>npx 的原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在</p>
<h3 id="全局命令免安装"><a href="#全局命令免安装" class="headerlink" title="全局命令免安装"></a>全局命令免安装</h3><p>npx另一个重要的优点是，可以执行未安装的包的命令，例如：</p>
<pre><code>npx create-react-app my-app
</code></pre>
<p>发现本地或全局都没有安装<code>create-react-app</code> 会先执行安装，安装完毕后，调用<code>create-react-app</code>命令初始化项目：</p>
<p><img src="./6.png"></p>
<p>并且create-react-app会在下载使用完被删除</p>
<p><img src="./7.png"></p>
<p>此时我们再回过头来看最初的问题：<code>npm init egg --type=simple</code> 又是怎么完成初始化的？</p>
<h2 id="npm-init-lt-initializer-gt"><a href="#npm-init-lt-initializer-gt" class="headerlink" title="npm init &lt;initializer&gt;"></a>npm init &lt;initializer&gt;</h2><p><a href="https://docs.npmjs.com/cli/v6/commands/npm-init">npm官网文档</a>对<code>npm init &lt;initializer&gt;</code> 是这样描述的</p>
<pre><code>npm init &lt;initializer&gt; can be used to set up a new or existing npm package.

initializer in this case is an npm package named create-&lt;initializer&gt;, which will be installed by npx, and then have its main bin executed -- presumably creating or updating package.json and running any other initialization-related operations.
</code></pre>
<p>同时举了个例子：</p>
<pre><code>npm init react-app ./my-react-app
</code></pre>
<p>运行后，发现与上面的<code>npx create-react-app my-app</code>结果是一致的</p>
<p><img src="./8.png"></p>
<p><code>--type=simple</code>肯定是参数，所以 <code>npm init egg</code> 其实就是 <code>npx create-egg</code></p>
<h2 id="npx-create-egg"><a href="#npx-create-egg" class="headerlink" title="npx create-egg"></a>npx create-egg</h2><p>create-egg的仓库地址为：<a href="https://github.com/eggjs/create-egg">https://github.com/eggjs/create-egg</a>  </p>
<p>可以看到：package.json中bin命令为：</p>
<pre><code>&#123;
  &quot;bin&quot;: &quot;./bin/create-egg.js&quot;
&#125;
</code></pre>
<p>而<code>./bin/create-egg.js</code>内容就一句话：</p>
<pre><code>  #!/usr/bin/env node

  &#39;use strict&#39;;

  require(&#39;egg-init/bin/egg-init&#39;);
</code></pre>
<p>所以，其实最终执行的还是<a href="https://github.com/eggjs/egg-init">egg-init</a>中的代码。至于egg-init中怎么执行的，有兴趣的可以接着看下去，本文不再深究。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/45151808">你不知道的 npm init</a></li>
<li><a href="https://www.dazhuanlan.com/2020/04/03/5e868596a952c/">package.json字段含义</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2019/02/npx.html">npx 使用教程</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/160134555">npm init egg –type=sample 到底做了什么？</a></li>
</ul>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>初探electron</title>
    <url>/%E5%88%9D%E6%8E%A2electron/</url>
    <content><![CDATA[<h2 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h2><p>Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。Electron和nwjs其实是一个作者，中间的种种可以访问参考2来查看，很有意思的一件事。</p>
<span id="more"></span>
<h2 id="渲染进程和主进程"><a href="#渲染进程和主进程" class="headerlink" title="渲染进程和主进程"></a>渲染进程和主进程</h2><p>Electron 中，入口是一个 js 文件（和 NW.js 不同，入口是 html 文件），运行这个入口文件（通常会是 package.json 里的 main 脚本）的进程称作主进程，在主进程使用 BrowserWindow 模块可以创建并管理 web 页面，也就是应用的 GUI。</p>
<pre><code>const &#123;BrowserWindow&#125; = require(&#39;electron&#39;)
// 主进程创建web页面
let someWindow = new BrowserWindow(winOpts)
// 加载本地的文件
someWindow.loadURL(&#39;file://&#39; + __dirname + &#39;/index.html&#39;)
</code></pre>
<p>在主进程创建的一个个web页面也都运行着自己的进程，即渲染进程，渲染进程各自独立，各自管理自己的页面，可以想象是浏览器一个个的 tab。  </p>
<p>每个 BrowserWindow 实例都在自己的渲染进程里运行页面。 当一个 BrowserWindow 实例被销毁后，相应的渲染进程也会被终止。</p>
<h2 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h2><p>Web 页面因为安全限制，不能直接访问原生的GUI资源（比如dialog、电源监控，通知栏等），Electron 中也是一样，渲染进程如果想要进行原生的GUI操作，就必须和主进程通讯，请求相应的GUI操作。  </p>
<p>Electron 提供了几种渲染进程和主进程通信的方式：</p>
<h3 id="第一种是使用ipcMain和ipcRenderer模块"><a href="#第一种是使用ipcMain和ipcRenderer模块" class="headerlink" title="第一种是使用ipcMain和ipcRenderer模块"></a>第一种是使用ipcMain和ipcRenderer模块</h3><p>在渲染进程中使用ipcRender模块向主进程发送消息，主进程中ipcMain接收消息，进行操作，如果还需要反馈，则通知渲染进程，渲染进程根据接收的内容执行相应的操作：</p>
<pre><code>// 渲染进程中
const &#123;ipcRenderer&#125; = require(&#39;electron&#39;)
ipcRender.send(&#39;somemsg&#39;, data);
ipcRender.on(&#39;replaymsg&#39;, (evt, otherData) =&gt; &#123;
    console.log(otherData)
&#125;)
// 主进程中
const &#123;ipcMain&#125; = require(&#39;electron&#39;)
ipcMain.on(&#39;somemsg&#39;, (evt, data) =&gt; &#123;
    console.log(data)
    evt.sender.send(&#39;replymsg&#39;, otherData);
&#125;);
// 同时Electron 也提供了同步的方式
</code></pre>
<p>不过切忌用 ipc 传递大量的数据，会有很大的性能问题，严重会让你整个应用卡住。</p>
<h3 id="第二种是直接在渲染进程使用remote模块"><a href="#第二种是直接在渲染进程使用remote模块" class="headerlink" title="第二种是直接在渲染进程使用remote模块"></a>第二种是直接在渲染进程使用remote模块</h3><p>remote 模块可以直接获取主进程中的模块。这种方式其实是第一种方式的简化。</p>
<pre><code>// 在渲染进程打开提示对话框
const &#123;dialog&#125; = require(&#39;electron&#39;).remote
dialog.showMessageBox(&#123; opts &#125;);
</code></pre>
<h3 id="第三种是主进程向渲染进程发送消息"><a href="#第三种是主进程向渲染进程发送消息" class="headerlink" title="第三种是主进程向渲染进程发送消息"></a>第三种是主进程向渲染进程发送消息</h3><pre><code>this.webviewWindow.webContents.send(&#39;ping&#39;);
</code></pre>
<h3 id="第四种是渲染进程之间的通信"><a href="#第四种是渲染进程之间的通信" class="headerlink" title="第四种是渲染进程之间的通信"></a>第四种是渲染进程之间的通信</h3><p>最简单的方法是使用浏览器中已经实现的 HTML5 API。 其中比较好的方案是用 Storage API， localStorage，sessionStorage 或者 IndexedDB。</p>
<p>你还可以用 Electron 内的 IPC 机制实现。将数据存在主进程的某个全局变量中，然后在多个渲染进程中使用 remote 模块来访问它。</p>
<pre><code>// 在主进程中
global.sharedObject = &#123;
  someProperty: &#39;default value&#39;
&#125;Copy
// 在第一个页面中
require(&#39;electron&#39;).remote.getGlobal(&#39;sharedObject&#39;).someProperty = &#39;new value&#39;Copy
// 在第二个页面中
console.log(require(&#39;electron&#39;).remote.getGlobal(&#39;sharedObject&#39;).someProperty)
</code></pre>
<h2 id="Electron-Vue"><a href="#Electron-Vue" class="headerlink" title="Electron + Vue"></a>Electron + Vue</h2><p>参考<a href="https://github.com/SimulatedGREG/electron-vue">electron-vue</a>，但是项目的Electron版本默认是2.x的版本，有点老，升级成了最新版（5.0.1），修改了一些配置，使其可以在高版本正常运行：<a href="https://github.com/wangminghuan/electron-vue-demo">electron-vue-demo</a>。  </p>
<p>但发现一个点，Electron将打包后的代码压缩加密为<code>.asar</code>文件，但是，这个加密文件是可以被解密的，开发electron-vue项目的同一个哥们，同时开源了一个可视化的解密工具：<a href="https://github.com/SimulatedGREG/asar-explorer">asar-explorer</a></p>
<p>但打包出来的包依旧有点大，打包后的文件中的node_modules 暂时还未找到合适方案合并到dist/electron/render.js中。</p>
<p><img src="1.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://electronjs.org/docs/tutorial/application-architecture#main-and-renderer-processes">Electron的应用结构</a></li>
<li><a href="https://www.zhihu.com/question/36292298/answer/102418523">nwjs和Electron的创始人的知乎回答</a></li>
<li><a href="https://juejin.im/entry/58869b3f8d6d810058d46135">我眼中的Electron</a></li>
</ol>
]]></content>
      <categories>
        <category>Electron</category>
      </categories>
      <tags>
        <tag>桌面应用</tag>
      </tags>
  </entry>
  <entry>
    <title>前端模块化进化史</title>
    <url>/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%BF%9B%E5%8C%96%E5%8F%B2/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。譬如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>
<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 、AMD 和 CMD 两种。CommonJS 用于服务器，AMD 和 CMD 用于浏览器，对应的实践分别为requireJs和seaJs。</p>
<span id="more"></span>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><blockquote>
<p><a href="http://wiki.commonjs.org/wiki/Modules/1.1">CommonJS</a></p>
</blockquote>
<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>CommonJS也可以说是NodeJS的模块化规范，他是随着nodejs的出现而被制定的，<br>Modules/1.0规范包含以下内容：  </p>
<pre><code>1. 模块的标识应遵循的规则（书写规范）
2. 定义全局函数require，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴漏出来的API
3. 如果被require函数引入的模块中也包含依赖，那么依次加载这些依赖
4. 如果引入模块失败，那么require函数应该报一个异常
5. 模块通过变量exports来向往暴漏API，exports只能是一个对象，暴漏的API须作为此对象的属性。
</code></pre>
<p>符合CommonJS规范的模块应该是这样：</p>
<pre><code>var react=require(./react.js);//引入模块
react.render();//使用模块
module.exports.x = x;//对外输出
</code></pre>
<p>其中：  </p>
<ol>
<li><p>【module】CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p>
</li>
<li><p>【module.exports】module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。</p>
</li>
<li><p>【exports】为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</p>
<pre><code> var exports = module.exports;
</code></pre>
<p>我们可以在export对象下挂载属性和方法：</p>
<pre><code> exports.area = function (r) &#123;
   return Math.PI * r * r;
 &#125;;
 exports.x = &quot;hello world&quot;
</code></pre>
</li>
</ol>
<p><strong>注意</strong>，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</p>
<pre><code>    exports = function()&#123;&#125;//不要这样做！！！！
</code></pre>
<p>同样对module.exports赋值的话，挂载在exports对象下的方法也无法输出了。保险简单起见都用module.exports即可！！</p>
<h3 id="利弊"><a href="#利弊" class="headerlink" title="利弊"></a>利弊</h3><p>nodeJS主要是运行在服务端的，因此CommonJS的规范主要是针对服务器端环境，并不完全适用于浏览器环境，主要原因是：CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD和CMD 解决方案。  </p>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD(Asynchronous Module Definition)即“异步的模块定义”，它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>
<h3 id="规范-1"><a href="#规范-1" class="headerlink" title="规范"></a>规范</h3><h4 id="模块定义-defined方法"><a href="#模块定义-defined方法" class="headerlink" title="模块定义 defined方法"></a>模块定义 defined方法</h4><p>AMD就只有一个接口：define(id?,dependencies?,factory);</p>
<pre><code>define(&quot;modA&quot;, [&#39;package/lib&#39;], function(lib)&#123;
  function foo()&#123;
    lib.log(&#39;hello world!&#39;);
  &#125;
    //dependencies参数加载依赖，[&#39;package/lib&#39;]
    //factory函数的形参调用依赖，function(lib)&#123;&#125;
  return &#123;
    foo: foo //通过return对外输出
  &#125;;
&#125;);
</code></pre>
<p>AMD规范也允许输出的模块兼容CommonJS规范，这时define方法需要写成下面这样：</p>
<pre><code>define(function (require, exports, module)&#123;
   //加载依赖模块
  var someModule = require(&quot;someModule&quot;);
  var anotherModule = require(&quot;anotherModule&quot;);
   //调用模块
  someModule.doTehAwesome();
  anotherModule.doMoarAwesome();
  //对外输出
  exports.asplode = function ()&#123;
    someModule.doTehAwesome();
    anotherModule.doMoarAwesome();
  &#125;;
&#125;);
</code></pre>
<h4 id="主模块入口（require加载）"><a href="#主模块入口（require加载）" class="headerlink" title="主模块入口（require加载）"></a>主模块入口（require加载）</h4><p>require(dependencies?,callback?)</p>
<ul>
<li>dependencies:所依赖的模块（可选）：该模块名称可以是模块的路径（不要加’.js’）,也可以是require.config中配置的模块别名，但对于有主模块（就是定义了模块ID），paths中的别名必须和模块ID相同。</li>
<li>callback 回调函数：参数名可以自定义。一般和依赖模块名中写入的相同。</li>
</ul>
<p>例如：  </p>
<pre><code>     require([&#39;pkg/index/index_common_homepage&#39;], function(index_common_homepage) &#123; 
      console.log(&#39;pkg index_common_homepage called&#39;)
     &#125;); 
</code></pre>
<h4 id="利弊-1"><a href="#利弊-1" class="headerlink" title="利弊"></a>利弊</h4><p>AMD规范会将所有的依赖模块预先下载，预先下载没什么争议，由于浏览器的环境特点，被依赖的模块肯定要预先下载的。问题在于，<strong>模块也被预先解析和执行了</strong>。如果一个模块依赖了十个其他模块，那么在本模块的代码执行之前，要先把其他十个模块的代码都执行一遍，无论该模块是否用到。这个性能消耗是不容忽视的。而CMD规范就很好的避开了这个问题。</p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD（Common Module Definition）也称“通用的模块定义”，和CommonJS保持了更好的兼容性。</p>
<h3 id="规范定义"><a href="#规范定义" class="headerlink" title="规范定义"></a>规范定义</h3><h4 id="模块定义-defined方法-1"><a href="#模块定义-defined方法-1" class="headerlink" title="模块定义 defined方法"></a>模块定义 defined方法</h4><pre><code>define(function(require, exports, module)&#123;
 //code
&#125;）
</code></pre>
<p>三个形参，不可更改，与commonJS是对应的</p>
<pre><code>define(function(require, exports, module)&#123;
    //加载依赖模块
    var mod = require(&quot;./mod.js&quot;);
   //调用模块
    var nums=mod.add();

   //对外输出，两种方式
   //方式1：
   return &#123;
      nums:nums
   &#125;
   //方式2：
   module.exports.nums=nums;       
    &#125;） 
</code></pre>
<h4 id="主模块入口（sea-use加载）"><a href="#主模块入口（sea-use加载）" class="headerlink" title="主模块入口（sea.use加载）"></a>主模块入口（sea.use加载）</h4><pre><code>seajs.use(&quot;main&quot;,function(ex)&#123;
   console.log(ex.num);
  &#125;); 
</code></pre>
<h4 id="利弊-2"><a href="#利弊-2" class="headerlink" title="利弊"></a>利弊</h4><ol>
<li>CMD可以做到按需加载，定义一个模块的时候不需要立即制定依赖模块，在需要的时候require就可以了，比较方便；</li>
<li>CMD定义模块时无需罗列依赖数组，在factory函数中需传入形参require,exports,module，然后它会调用factory函数的toString方法，对函数的内容进行正则匹配，通过匹配到的require语句来分析依赖，这样就真正实现了commonJS风格的代码。</li>
</ol>
<h2 id="AMD-VS-CMD"><a href="#AMD-VS-CMD" class="headerlink" title="AMD VS CMD"></a>AMD VS CMD</h2><ol>
<li><p>AMD 推崇依赖前置, 代码在一旦运行到此处，能立即知晓依赖。而无需遍历整个函数体找到它的依赖，因此性能有所提升，缺点就是开发者必须显式得指明依赖——这会使得开发工作量变大，比如：当依赖项有n个时候 那么写起来比较烦 且容易出错。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。</p>
</li>
<li><p>执行顺序上：CMD是延迟执行的，而AMD是提前执行的。</p>
</li>
<li><p>api设计角度：AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。</p>
</li>
</ol>
<h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><p>在AMD 与CommonJs 广泛发展的同时，为了同时兼容两种模块化方式，于是出现了Universal Module Definition，虽然他的定义方式及其丑陋，但是他兼容了AMD 与CommonJs，同时还兼容原始的“全局”方式。</p>
<h3 id="规范定义-1"><a href="#规范定义-1" class="headerlink" title="规范定义"></a>规范定义</h3><h4 id="模块定义"><a href="#模块定义" class="headerlink" title="模块定义"></a>模块定义</h4><pre><code>(function (root, factory) &#123;
    if (typeof define === &#39;function&#39; &amp;&amp; define.amd) &#123;
        // AMD
        define([&#39;jquery&#39;], factory);
    &#125; else if (typeof exports === &#39;object&#39;) &#123;
        // Node, CommonJS-like
        module.exports = factory(require(&#39;jquery&#39;));
    &#125; else &#123;
        // Browser globals (root is window)
        root.returnExports = factory(root.jQuery);
    &#125;
&#125;(this, function ($) &#123;
    //    methods
    function myFunc()&#123;&#125;;

    //    exposed public method
    return myFunc;
&#125;));
</code></pre>
<p>采用的是IIFE写法，将需要运行的函数放在第二位， 在 IIFE执行之后当作参数传递进, 所以他倒置代码的运行顺序。</p>
<h2 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a>ESM</h2><p>即ECMAScript2015 Module. 也就是ES6中的模块化。</p>
<p>ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<h3 id="规范定义-2"><a href="#规范定义-2" class="headerlink" title="规范定义"></a>规范定义</h3><p>ES6 中新增了两个命令 import 和 export</p>
<ul>
<li>import 命令用于输入其他模块提供的功能</li>
<li>export 命令用于规定模块的对外接口</li>
</ul>
<p>ES6 中的模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。</p>
<pre><code>//加载依赖模块
import &#123;deviceInfo, cookie,&#125; from &quot;../lib/util.js&quot;; 
//调用模块，对外输出
export var cookie_spm = cookie.get(&#39;spm&#39;) || &quot;&quot;;
//对外输出
export function()&#123;
//code..
&#125;
</code></pre>
<h3 id="利弊-3"><a href="#利弊-3" class="headerlink" title="利弊"></a>利弊</h3><p>ES6 的模块是编译时加载，效率要比 CommonJS 模块的加载方式高。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li> <a href="http://javascript.ruanyifeng.com/nodejs/module.html#toc2">CommonJS规范</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/module">阮一峰 ES6 Module 的语法</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端脚手架开发指南</title>
    <url>/%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="何谓脚手架？"><a href="#何谓脚手架？" class="headerlink" title="何谓脚手架？"></a>何谓脚手架？</h2><p>在前端工程化高度发展的当代，各种构建工具大行其道，webpack、gulp、rollup、fis等，这些构建工具的主要作用就是将前端代码工程化，实现代码编译，文件优化，模块分割，自动刷新，代码校验，自动发布等供嫩，我们在实际开发中，要根据自己的需求定制不同的配置，但是多数情况下，项目配置在不同的项目中改动不大，有些甚至不需要做任何修改。这个时候，开发不同的项目，我们需要将这些配置重新拷贝一遍，于是，为了减少重复性工作，脚手架的概念应运而生。  </p>
<p>对于vue-cli,create-react-app,或者自己开发的工具，  </p>
<p>脚手架的定位基本是一致的：<strong>创建项目初始文件</strong>  </p>
<p>脚手架作用是：<strong>创建项目的初始文件，本质是方案的封装</strong></p>
<span id="more"></span>
<h2 id="编写一个脚手架"><a href="#编写一个脚手架" class="headerlink" title="编写一个脚手架"></a>编写一个脚手架</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>考虑到模板项目可能需要经常更新，而脚手架可能更新不及时，所以我们通常不会将模板项目放到脚手架中，而是将其放在github（gitlab）上进行维护，项目创建时，拉取最新的代码，以保证最新创建的项目源码最新。下面是基本流程：</p>
<p><img src="01.png"></p>
<h3 id="获取目录"><a href="#获取目录" class="headerlink" title="获取目录"></a>获取目录</h3><pre><code>process.cwd() 是当前执行node命令时候的文件夹地址 ——工作目录，保证了文件在不同的目录下执行时，路径始终不变
__dirname 是被执行的js 文件的地址 ——文件所在目录
</code></pre>
<h3 id="获取输入命令行参数"><a href="#获取输入命令行参数" class="headerlink" title="获取输入命令行参数"></a>获取输入命令行参数</h3><pre><code>  const program = require(&#39;commander&#39;);
  console.log(program.args[0])
</code></pre>
<h3 id="cli中交互式询问"><a href="#cli中交互式询问" class="headerlink" title="cli中交互式询问"></a>cli中交互式询问</h3><pre><code>inquirer.prompt([&#123;
    type: &#39;input&#39;,
    message: &#39;请输入项目名称：&#39;,
    name: &#39;projectName&#39;,
    default: &quot;my-template-project&quot;, // 默认值
    validate: function (val) &#123;
      if (!val) &#123; // 校验
        return &quot;请输入有效项目名称！&quot;;
      &#125; else &#123;
        return true
      &#125;
    &#125;
  &#125;,
  &#123;
    type: &quot;confirm&quot;,
    message: &quot;是否使用监听？&quot;,
    name: &quot;watch&quot;,
  &#125;,
  &#123;
    type: &#39;list&#39;,
    message: &#39;请选择一种水果:&#39;,
    name: &#39;fruit&#39;,
    choices: [
      &quot;Apple&quot;,
      &quot;Pear&quot;,
      &quot;Banana&quot;
    ],
    filter: function (val) &#123; // 使用filter将回答变为小写
      return val.toLowerCase();
    &#125;
  &#125;,
]).then(result =&gt; &#123;
  console.log(`你输入的项目名称是：$&#123;result.projectName&#125;`)
  console.log(`你是否选择监听：$&#123;result.watch&#125;`)
  console.log(`你选择的水果是：$&#123;result.fruit&#125;`)
&#125;)
</code></pre>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://mp.weixin.qq.com/s/3HaVA-qhy-TDkE7KVXjDSg">小工具，大作用——前端脚手架开发指北</a></li>
<li><a href="https://www.jianshu.com/p/095c968d406f">手把手教你写cli</a></li>
<li><a href="https://blog.csdn.net/qq_26733915/article/details/80461257">inquirer.js —— 一个用户与命令行交互的工具</a></li>
<li><a href="https://www.cnblogs.com/ihardcoder/p/6648423.html">不仅仅是复制粘贴 - 聊聊前端脚手架</a></li>
</ol>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>inquirer</tag>
      </tags>
  </entry>
  <entry>
    <title>图片水印的几种实现方案</title>
    <url>/%E5%9B%BE%E7%89%87%E6%B0%B4%E5%8D%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>图片水印相信大家都不陌生，在知乎、微博等地方可以经常看到。水印的作用可以基本就是为了给图片绑定身份信息，可以用来声明图片归属权，或发生信息泄露时便于定位到泄漏源。添加水印的方式有两种：后端水印和前端水印，二者各有优劣：后端水印的优势是安全，劣势是如果同一个文件在多个用户端都展示，那么就需要生成多份，无疑造成了资源浪费。前端水印不依赖服务端，完全依赖客户端的计算能力，减少服务端压力，同时可以做到千人千面，劣势是安全性较低。如何选择那就需要依据当前的使用场景。这里，对两端均做下介绍。</p>
<span id="more"></span>
<h2 id="nodejs的实现"><a href="#nodejs的实现" class="headerlink" title="nodejs的实现"></a>nodejs的实现</h2><p>服务端的实现不同语言有不同的处理方式，但原理是相同的，这里我们就采用nodejs来实现，相关的图片处理库选用<a href="https://www.npmjs.com/package/jimp">jimp</a>，不像gm/node-images依赖系统库，node-gyp的安装总是出各种诡异的问题。jimp是完全用nodejs实现的，缺点是不支持gif图片的处理，不过可以使用gifwrap来补充处理，本文我们不讨论gif的处理，只处理静态图片。</p>
<h3 id="简单水印"><a href="#简单水印" class="headerlink" title="简单水印"></a>简单水印</h3><p>先实现一个简单的水印，给图片右下角添加一个水印logo</p>
<pre><code>const Jimp = require(&#39;jimp&#39;);

// 需要添加的水印图片路径
const ORIGINAL_IMAGE = &#39;./img/1.png&#39;;

// 水印logo路径
const LOGO = &#39;./img/logo.png&#39;;

// 水印距离右下角百分比
const LOGO_MARGIN_PERCENTAGE = 5 / 100;

const main = async () =&gt; &#123;
  const [image, logo] = await Promise.all([
    Jimp.read(ORIGINAL_IMAGE),
    Jimp.read(LOGO)
  ]);

  // 将 logo 等比缩小 10 倍
  // logo.resize(logo.bitmap.width / 10, Jimp.AUTO);

  const xMargin = image.bitmap.width * LOGO_MARGIN_PERCENTAGE;
  const yMargin = image.bitmap.width * LOGO_MARGIN_PERCENTAGE;

  const X = image.bitmap.width - logo.bitmap.width - xMargin;
  const Y = image.bitmap.height - logo.bitmap.height - yMargin;

  return image.composite(logo, X, Y, [
    &#123;
      mode: Jimp.BLEND_SOURCE_OVER,
      opacitySource: 0.1,
      opacityDest: 1
    &#125;
  ]);
&#125;;
// 主逻辑
main().then(image =&gt; &#123;
const FILENAME = (+new Date())+&#39;.&#39; + image.getExtension();

// 压缩图片 0-100
image.quality(80);

return image.write(FILENAME, (err) =&gt; &#123;
  if (err) &#123;
    return console.error(err);
  &#125;;
  console.log(&#39;水印成功：&#39;, FILENAME);
&#125;);
</code></pre>
<p>  });</p>
<p> 运行后得到如下图片</p>
<p> <img src="0.png"> </p>
<h3 id="全屏倾斜"><a href="#全屏倾斜" class="headerlink" title="全屏倾斜"></a>全屏倾斜</h3><p>通常情况下，我们看到的更多的情况是整张图都被覆盖了倾斜的文本说明，我们再看下基于jimp如何实现</p>
<pre><code>const Jimp = require(&#39;jimp&#39;);
// 需要添加的水印图片路径
const ORIGINAL_IMAGE = &#39;./img/1.png&#39;;
const WATER_TEXT=&quot;wangminghuan&quot;;
const main = async () =&gt; &#123;
  const [image, font] = await Promise.all([
    Jimp.read(ORIGINAL_IMAGE),
    Jimp.loadFont(Jimp.FONT_SANS_16_BLACK)
  ]);
  // 图片宽+高得到一个正方形水印图尺寸
  // 这样可以保证无论水印基于中心点如何旋转，始终可以覆盖图片
  let maxWidth=image.bitmap.width+image.bitmap.height;
  // const rotateWith= Math.ceil(Math.sqrt(Math.pow(image.bitmap.width,2)/2)+Math.sqrt(Math.pow(image.bitmap.height,2)/2))
  const space=20;
  let textImage = new Jimp(maxWidth, maxWidth, 0x0);
  let textWidth = Jimp.measureText(font, WATER_TEXT);
  let textHeight = Jimp.measureTextHeight(font, WATER_TEXT);
  let colNum = Math.ceil(maxWidth / (textWidth+space));
  let rowNum = Math.ceil(maxWidth / (textHeight+space))
  // 按行列循环渲染
  for (let i = 0; i &lt; rowNum; ++i) &#123;
    for (let j = 0; j &lt; colNum; ++j) &#123;
      textImage.print(font, (space+textWidth)*j, (space+textHeight)*i, WATER_TEXT,maxWidth,maxWidth)
    &#125;
  &#125;
  // 旋转后裁剪水印图片并与原始图片合成为一张图
  return textImage.rotate(45,false).crop(image.bitmap.height/2,image.bitmap.width/2,image.bitmap.width,image.bitmap.height)
  .composite(image, 0, 0, &#123;
    mode: Jimp.BLEND_MULTIPLY,
    opacitySource: 1,
    opacityDest: 0.3
  &#125;)
&#125;;
main().then(image =&gt; &#123;
  const FILENAME = (+new Date())+&#39;.&#39; + image.getExtension();

  // 压缩图片 0-100
  image.quality(80);

  return image.write(FILENAME, (err) =&gt; &#123;
    if (err) &#123;
      return console.error(err);
    &#125;;
    console.log(&#39;水印成功：&#39;, FILENAME);
  &#125;);
&#125;);
</code></pre>
<p> 运行后得到如下图片</p>
<p> <img src="2.png"> </p>
<h2 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h2><h3 id="css方案"><a href="#css方案" class="headerlink" title="css方案"></a>css方案</h3><p>我们先看下最简单粗暴的css方案</p>
<pre><code>&lt;style&gt;
  .water-mark&#123;position: relative;&#125;
  .water-mark:before&#123;
    background-image: url(&quot;./img/water.png&quot;)!important;
    background-size: 86px 86px;
    opacity: 0.5;
    pointer-events: none;
    width: 100%;
    height: 100%;
    position: absolute;
    content: &quot;&quot;;
  &#125;
&lt;/style&gt;

&lt;div class=&quot;img-box&quot;&gt;
  &lt;img class=&quot;img&quot; src=&quot;./img/1.png&quot; &gt;
&lt;/div&gt;

&lt;script&gt;
    const img=document.querySelector(&quot;.img&quot;)
    img.addEventListener(&#39;load&#39;,(e)=&gt;&#123;
      const parent=img.parentNode
      parent.style=`width:$&#123;img.width&#125;px;height:$&#123;img.height&#125;px;position:relative`
      parent.className=parent.className+&#39; water-mark&#39;
    &#125;)
&lt;/script&gt;
</code></pre>
<p>效果：</p>
<p><img src="./1.png"></p>
<p>但这样只是”盖”了一层dom在图片上，并且禁用的鼠标事件，修改dom可以轻易删除掉这层元素，我们再做一层简单的防护：</p>
<pre><code>  let body = document.getElementsByTagName(&#39;body&#39;)[0]
  let options = &#123;
    childList: true,
    attributes: true,
    characterData: true,
    subtree: true,
    attributeOldValue: true,
    characterDataOldValue: true
  &#125;
  let observer = new MutationObserver((mutations, observer)=&gt; &#123;
  // 当attribute属性被修改
  if (mutations[0].target.id === &#39;_waterMark&#39;) &#123;
     // do something..
  &#125;
  // 当id被改变时
  if (mutations[0].attributeName === &#39;id&#39;) &#123;
    // do something..
  &#125;
  // 当节点被删除
  if (mutations[0].removedNodes[0] &amp;&amp; mutations[0].removedNodes[0].id === &#39;_waterMark&#39;) &#123;
   // do something..
  &#125;
&#125;)
observer.observe(body, options) // 监听body节点
</code></pre>
<p>配合<code>pointer-events: none</code>属性，可以为整站添加一个全局水印：</p>
<p><img src="./4.png"></p>
<h3 id="canvas-实现"><a href="#canvas-实现" class="headerlink" title="canvas 实现"></a>canvas 实现</h3><p>上述的css方案弊端较多，右键另存图片拿到的还是原始图片，可以通过canvas进行渲染：</p>
<pre><code>    /*
  @ desc 全屏倾斜生成水印
  */
    function fullRotateWatermark(canvas,text,deg)&#123;
        return new Promise((resolve, reject) =&gt; &#123;
          const ctx = canvas.getContext(&#39;2d&#39;)
          const textHeight=15;
          const space=20;
          ctx.font = textHeight+&quot;px Microsoft Yahei&quot;;
          ctx.fillStyle = &quot;rgba(255, 255, 255, 0.3)&quot;;
          const textWidth=ctx.measureText(text).width+10
          const maxWidth=canvas.width+canvas.height;
          // 扩展绘画区域，画布宽+画布高直接组成正方形画布，x轴偏移画布的高度开始填充
          let colNum = Math.ceil((maxWidth) / (textWidth+space));
          let rowNum = Math.ceil((maxWidth) / (textHeight+space))
          for (let i = 0; i &lt; rowNum; ++i) &#123;
            for (let j = 0; j &lt; colNum; ++j) &#123;
              ctx.translate(canvas.width/2, canvas.height/2) // 偏移坐标原点
              ctx.rotate((-deg * Math.PI) / 180); // 初始偏转角度
              ctx.fillText(text,-maxWidth/2+(space+textWidth)*j, -maxWidth/2+(space+textHeight)*i)
              ctx.rotate((deg * Math.PI) / 180); // 偏转角度恢复，防止在原来基础上再次旋转
              ctx.translate(-canvas.width/2, -canvas.height/2) // 坐标原点恢复
            &#125;
          &#125;
          canvas.toBlob(blob =&gt; resolve(blob))
      // 此处也可以直接通过canvas输出base64: canvas.toDataURL(&#39;image/png&#39;, &#39;0.5&#39;);
    &#125;)
    &#125;
    // 入口函数 ，选择本地图片生成水印
    function imgWatermark(text) &#123;
      return new Promise(resolve=&gt;&#123;
        let input = document.createElement(&#39;input&#39;)
        input.setAttribute(&#39;type&#39;, &#39;file&#39;)
        input.setAttribute(&#39;accept&#39;, &#39;image/*&#39;)
        input.onchange = async () =&gt; &#123;
          let img = await blobToImg(input.files[0])
          let canvas = imgToCanvas(&#123;
            obj: img,
            width: img.width,
            height: img.height
          &#125;)
          
          // let blob = await watermark(canvas, text)
          let blob = await fullRotateWatermark(canvas, text, 45)
          // 此处将Blob读取到img标签，并在dom内渲染出来；如果是上传文件，可以将blob添加到FormData中
          let newImage = await blobToImg(blob)
          resolve(newImage)
        &#125;
        input.click()
    &#125;)
    &#125;
    /*
      @ desc bolb对象转image
      */
    function blobToImg(blob) &#123;
      return new Promise((resolve, reject) =&gt; &#123;
        let reader = new FileReader()
        reader.addEventListener(&#39;load&#39;, () =&gt; &#123;
          let img = new Image()
          img.src = reader.result
          img.addEventListener(&#39;load&#39;, () =&gt; resolve(img))
        &#125;)
        reader.readAsDataURL(blob)
      &#125;)
    &#125;
</code></pre>
<p>上述方案右键图片是包含水印的，缺点也明显：图片必须支持跨域，base64处理后的图片体积也会变大。</p>
<p>当然，也可以通过canvas生成水印图片的base64地址，然后作为背景图插入到图片中, 这里不再赘述。</p>
<h3 id="svg-实现"><a href="#svg-实现" class="headerlink" title="svg 实现"></a>svg 实现</h3><p>对于一般的文本类水印，用canvas生成base64后，生成的base64比较大，其实css可以直接渲染SVG XML格式代码，代码量很小很多，对于上述的css方案：</p>
<pre><code>  &lt;style&gt;
      .water-mark:before&#123;
        background-image: url(&quot;data:image/svg+xml,%3Csvg xmlns=&#39;http://www.w3.org/2000/svg&#39;%3E%3Ctext y=&#39;15&#39; fill=&#39;red&#39; transform=&#39;rotate(-45 100 40)&#39;%3Ewangminghuan%3C/text%3E%3C/svg%3E&quot;);
      &#125;
    &lt;/style&gt;
</code></pre>
<p>效果如下：</p>
<p> <img src="./3.png"></p>
<p>因为svg需要转义才可以被浏览器识别，我们可以直接通过此<a href="https://www.zhangxinxu.com/sp/svgo/">站点</a>操作</p>
<p>对于以上的前端方案，无论如何操作, 都是一些展示上的”障眼法”，如果对安全性有要求的话，唯一靠谱的还是服务端直接合成。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jianshu.com/p/4f1f3715b22b">nodejs编程实战之图片水印生成（一）</a></li>
<li><a href="https://jishuin.proginn.com/p/763bfbd68440">谈谈水印实现的几种方式</a></li>
<li><a href="https://www.zhangxinxu.com/wordpress/2018/08/css-svg-background-image-base64-encode/">学习了，CSS中内联SVG图片有比Base64更好的形式</a></li>
<li><a href="https://github.com/wwenj/public-component/blob/master/%E9%98%B2%E5%88%A0%E9%99%A4%E7%9A%84%E9%A1%B5%E9%9D%A2%E6%B0%B4%E5%8D%B0%E7%BB%84%E4%BB%B6/waterMark.vue">github-waterMark.vue</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>水印</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系列-1-MySql</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97-1-MySql/</url>
    <content><![CDATA[<h2 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h2><p>我们先看一组数据： </p>
<p>2019 年最受欢迎的数据库分为开源数据库和商业数据库(<a href="http://highscalability.com/blog/2019/6/27/2019-open-source-database-report-top-databases-public-cloud.html">原文地址</a>)：</p>
<ul>
<li><p>在开源数据库方面，MySQL排名第一，占开源数据库使用量的 30% 以上。PostgreSQL以 13.4% 的开源数据库用户比例位居第二，紧随其后的是MongoDB，占 12.2%，位列第三。</p>
</li>
<li><p>在商业数据库方面，Oracle是世界上排名第一的数据库，它代表了超过 2/3 的商业和开源数据库组合。它与第二名的Microsoft SQL Server差距巨大，IBM DB2名列第三，占商业数据库与开源数据库组合的 11.1%。</p>
</li>
</ul>
<p>对于数据库方向，重点就是两种数据库，一种是以 SQL 为代表的关系型数据库，另一种是以非 SQL 为代表的 NoSQL 数据库。关系型数据库主要有三个：Oracle、MySQL 和 Postgres。</p>
<p>对于web服务来说：Linux+Apache+Mysql+PHP（LAMP）与Linux+Nginx+Mysql+PHP（LNMP）的组合方式对于企业来说更是首选，一来开源免费，二来非常成熟，相关技术人员也很好招聘。从这些可以看出，学习数据库，Mysql是一个绕不过去的点。</p>
<p>MySql在2010年被Oracle收购后，依旧是开源的，但是开源不代表是完全免费的，目前只有MySQL Community Server（社区版） 版本是免费的，也是我们通常使用的版本。</p>
<span id="more"></span>

<h2 id="MySql的安装与使用"><a href="#MySql的安装与使用" class="headerlink" title="MySql的安装与使用"></a>MySql的安装与使用</h2><p>待后续完善补充~</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://dev.mysql.com/doc/">mysql 官方文档</a></li>
<li><a href="https://book.douban.com/subject/23008813/">《高性能MySQL》 简介</a></li>
<li><a href="https://book.douban.com/subject/25662138/">《NoSQL精粹》简介</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Sql</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系列-2-MongoDB</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97-2-MongoDB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p>
<p>随着前端技术的不断迭代，代表MongoDB（文档数据库），Express（Web服务器），AngularJS（前端框架）和Node.js（后端JavaScript运行时）的MEAN堆栈开始流行。除其他原因外，MEAN堆栈很有吸引力，因为您需要了解的唯一语言是JavaScript。与等效的LAMP/LNMP堆栈相比，它还需要更少的RAM。</p>
<p>MongoDB无疑是NoSQL数据库中最受欢迎的数据库。它的文档数据模型为开发人员提供了极大的灵活性，而其分布式体系结构则提供了很好的可伸缩性。因此，通常选择MongoDB用于必须管理大量数据，得益于水平可伸缩性并处理不适合关系模型的数据结构的应用程序。</p>
<p>MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统,旨在为WEB应用提供可扩展的高性能数据存储解决方案。在其之上还具有一个基于图形的存储。MongoDB实际上并不存储JSON：它存储BSON（BSON 是一种类似 JSON 的二进制形式的存储格式，是 Binary JSON 的简称），该扩展了JSON表示（字符串）以包括其他类型，例如int，long，date，浮点，decimal128和地理空间坐标等。</p>
<span id="more"></span>
<h2 id="MongoDB的安装"><a href="#MongoDB的安装" class="headerlink" title="MongoDB的安装"></a>MongoDB的安装</h2><p>MongoDB在阿里云(<code>CentOS Linux release 7.6.1810</code>)的安装流程如下：</p>
<h3 id="获取压缩包"><a href="#获取压缩包" class="headerlink" title="获取压缩包"></a>获取压缩包</h3><pre><code>wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.2.2.tgz
</code></pre>
<h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><pre><code>tar -zxvf mongodb-linux-x86_64-rhel70-4.2.2
</code></pre>
<h3 id="将解压包拷贝到指定目录"><a href="#将解压包拷贝到指定目录" class="headerlink" title="将解压包拷贝到指定目录"></a>将解压包拷贝到指定目录</h3><pre><code>mv  mongodb-linux-x86_64-rhel70-4.2.2/ /usr/local/mongodb       
</code></pre>
<h3 id="创建数据存储路径"><a href="#创建数据存储路径" class="headerlink" title="创建数据存储路径"></a>创建数据存储路径</h3><pre><code>mkdir -p /data/db
</code></pre>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p><code>/etc/mongod.conf</code> 文件配置如下（不存在时，自己手动新建）</p>
<pre><code>dbpath = /data/db  #数据存储目录
logpath = /data/logs/mongodb.log # 日志目录
fork = true  # 后台进程启动
auth=true    # 开启验证
port = 3001  # 端口号  
bind_ip=0.0.0.0 # 对外访问
</code></pre>
<h3 id="通过指定配置启动"><a href="#通过指定配置启动" class="headerlink" title="通过指定配置启动"></a>通过指定配置启动</h3><p>确保<code>mongod.conf</code>中的dbpath与logpath对应目录存在，启动数据库：</p>
<pre><code>./mongod -f /etc/mongod.conf
</code></pre>
<h3 id="mongod-与-mongo-命令"><a href="#mongod-与-mongo-命令" class="headerlink" title="mongod 与 mongo 命令"></a>mongod 与 mongo 命令</h3><p> 前者是启用MongoDB进程，后者是对MongoDB进行连接操作</p>
<h3 id="win10-下的安装"><a href="#win10-下的安装" class="headerlink" title="win10 下的安装"></a>win10 下的安装</h3><p>可参照<a href="https://www.cnblogs.com/nangezi/p/11279401.html">MongoDB的安装，mongod和mongo的区别</a>进行设置，自己win10上安装时作为window service服务一直无法启动，无奈只好通过命令行手动启动 <code>mongod --dbpath &quot;D:/MongoDB/Server/4.4/data/db&quot;</code></p>
<h2 id="MongoDB中的概念"><a href="#MongoDB中的概念" class="headerlink" title="MongoDB中的概念"></a>MongoDB中的概念</h2><p>| RDBMS    | MongoDB  |<br>| —— | —— | —— |<br>| 数据库 | 数据库 |<br>| 表格 | 集合 |<br>| 行 | 文档 |<br>| 列 | 字段 |<br>| 表联合 | 嵌入文档 |<br>| 主键 | 主键 (MongoDB 提供了 key 为 _id ) |</p>
<h2 id="MongoDB的使用"><a href="#MongoDB的使用" class="headerlink" title="MongoDB的使用"></a>MongoDB的使用</h2><p>数据库安装完毕后，默认是有三个数据库的，这些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p>
<pre><code>&gt; show dbs
admin   0.000GB
config  0.000GB
local   0.000GB
</code></pre>
<ul>
<li>admin： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。  </li>
<li>local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合。 </li>
<li>config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。  </li>
</ul>
<p>如果执行 <code>show dbs</code> 返回为空，说明开启的数据库认证，但是没有正确登录访问，此时需要切换到admin数据库，执行添加操作：</p>
<pre><code>use admin

db.createUser(&#123;user:&quot;admin&quot;,pwd:&quot;admin&quot;,roles:[&quot;root&quot;]&#125;)
</code></pre>
<p>此时再通过用户名密码连接，即可正常展示，如果没有开启认证，强烈建议开启 <code>./mongod --auth</code></p>
<p><img src="1.png"></p>
<h3 id="通过可视化工具连接"><a href="#通过可视化工具连接" class="headerlink" title="通过可视化工具连接"></a>通过可视化工具连接</h3><p>本文中使用的可视化工具为<a href="https://robomongo.org/">Robo 3T</a>，</p>
<h3 id="通过shell连接"><a href="#通过shell连接" class="headerlink" title="通过shell连接"></a>通过shell连接</h3><p>进入mongodb安装目录（如：/usr/local/mongodb/bin), 执行以下命令：</p>
<pre><code> ./mongo --port 3001
</code></pre>
<p>如果添加账号管理后需通过以下方式连接：</p>
<pre><code> ./mongo  --port 3001 -u admin -p xxx
</code></pre>
<p>ps: 如果通过进程守护方式启动，依旧可以通过此方式再次进入shell</p>
<p>如果需要通过进程守护方式启动</p>
<pre><code> ./mongo --fork --port 3001 -u admin -p xxx  
</code></pre>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><pre><code>  use code
</code></pre>
<p>但此时创建的数据库 code 并不在数据库的列表中， 要显示它，我们需要向 code 数据库插入一些数据。（ps: MongoDB 中默认的数据库为 test，如果你没有创建新的数据库，将默认使用test数据库）</p>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><pre><code>  db.dropDatabase()
</code></pre>
<p>会删除当前use的数据库。</p>
<h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><p>集合的概念类似MySql中的“表”，当插入一些文档时，MongoDB 会自动创建集合：</p>
<pre><code>  db.city.insert(&#123;&quot;name&quot;:&quot;郑州&quot;&#125;)
</code></pre>
<p>自动创建了集合city</p>
<p>我们也可以显式创造集合：</p>
<pre><code>  db.createCollection(&quot;area&quot;)
</code></pre>
<p><img src="2.png"></p>
<p>查询当前数据库下，集合个数：</p>
<pre><code>   &gt; db.city.count();
   2
</code></pre>
<p>查询当前数据库下，集合列表：</p>
<pre><code>   &gt; show collections;
   city
   area
</code></pre>
<p>或：</p>
<pre><code>   &gt; show tables
   city
   area
</code></pre>
<h3 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h3><pre><code>&gt; db.area.drop() // 删除集合area
true

&gt; show tables // 查看当前集合
city
</code></pre>
<p>area集合已经被删除</p>
<h3 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h3><p>文档的数据结构和 JSON 基本一样。所有存储在集合中的数据都是 BSON 格式。</p>
<p>使用 insert() 或 save() 方法向集合中插入文档：</p>
<pre><code>db.city.insert(&#123;
    name: &#39;北京&#39;, 
    code: &quot;001&quot;,
    description: &#39;中华人民共和国首都&#39;,
    people: 2154.2*10000,
    tags: [&#39;政治中心&#39;, &#39;文化中心&#39;],
    isCenter: true
&#125;)
</code></pre>
<p><img src="3.png"></p>
<p><code>save()</code> 方法类似于 <code>insert()</code> 方法。如果指定 _id 字段，则会更新该 _id 的数据，不指定话功能同<code>insert()</code>方法:</p>
<pre><code>    db.city.save(&#123;
        _id:ObjectId(&quot;5e280f0f3a83e53738ebd7c7&quot;),
        name: &#39;北京&#39;, 
        code: &quot;100&quot;
    &#125;)
</code></pre>
<p><code>insert()</code> 方法如果指定的<code>_id</code>字段不存在则新建，如果存在就会报错，不会像<code>save()</code>方法一样更新数据</p>
<p>下表为MongoDB中常用的几种数据类型：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</td>
</tr>
<tr>
<td>Integer</td>
<td>整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔值。用于存储布尔值（真/假）。</td>
</tr>
<tr>
<td>Double</td>
<td>双精度浮点值。用于存储浮点值。</td>
</tr>
<tr>
<td>Min/Max keys</td>
<td>将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。</td>
</tr>
<tr>
<td>Array</td>
<td>用于将数组或列表或多个值存储为一个键。</td>
</tr>
<tr>
<td>Timestamp</td>
<td>时间戳。记录文档修改或添加的具体时间。</td>
</tr>
<tr>
<td>Object</td>
<td>用于内嵌文档。</td>
</tr>
<tr>
<td>Null</td>
<td>用于创建空值。</td>
</tr>
<tr>
<td>Symbol</td>
<td>符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td>
</tr>
<tr>
<td>Date</td>
<td>日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td>
</tr>
<tr>
<td>Object ID</td>
<td>对象 ID。用于创建文档的 ID。</td>
</tr>
<tr>
<td>Binary Data</td>
<td>二进制数据。用于存储二进制数据。</td>
</tr>
<tr>
<td>Code</td>
<td>代码类型。用于在文档中存储 JavaScript 代码。</td>
</tr>
<tr>
<td>Regular expression</td>
<td>正则表达式类型。用于存储正则表达式。</td>
</tr>
</tbody></table>
<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>删除文档使用remove方法，语法格式如下：</p>
<pre><code>db.collection.remove(
  &lt;query&gt;,
  &#123;
    justOne: &lt;boolean&gt;,
    writeConcern: &lt;document&gt;
  &#125;
)
参数说明：
- query :（可选）删除的文档的条件。
- justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。
- writeConcern :（可选）抛出异常的级别。
</code></pre>
<p>删除<code>name:北京</code> 的文档,且只删除一个:</p>
<pre><code> &gt; db.city.remove(&#123;name:&quot;北京&quot;&#125;,1)
 WriteResult(&#123; &quot;nRemoved&quot; : 1 &#125;) //成功删除1条
</code></pre>
<p>如果想清空所有：</p>
<pre><code>  db.city.remove(&#123;&#125;)
</code></pre>
<h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><p>MongoDB 使用 update() 和 save() 方法来更新集合中的文档。save方法上面已经介绍过，下面为update方法语法格式：</p>
<pre><code>db.collection.update(
  &lt;query&gt;,
  &lt;update&gt;,
  &#123;
    upsert: &lt;boolean&gt;,
    multi: &lt;boolean&gt;,
    writeConcern: &lt;document&gt;
  &#125;
)

参数说明：
- query : update的查询条件，类似sql update查询内where后面的。
- update : update的对象和一些更新的操作符（参照下方表格）等，也可以理解为sql update查询内set后面的
- upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。
- multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。
- writeConcern :可选，抛出异常的级别。
</code></pre>
<h4 id="字段更新操作符"><a href="#字段更新操作符" class="headerlink" title="字段更新操作符"></a>字段更新操作符</h4><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>$currentDate</td>
<td>将字段的值设置为当前日期，可以是Date或Timestamp</td>
</tr>
<tr>
<td>$inc</td>
<td>按指定的数量增加字段的值 increment</td>
</tr>
<tr>
<td>$min</td>
<td>仅当指定的值小于现有字段值时才更新字段</td>
</tr>
<tr>
<td>$max</td>
<td>仅当指定的值大于现有字段值时才更新字段</td>
</tr>
<tr>
<td>$mul</td>
<td>将字段的值乘以指定的量</td>
</tr>
<tr>
<td>$rename</td>
<td>重命名字段</td>
</tr>
<tr>
<td>$set</td>
<td>设置文档中字段的值</td>
</tr>
<tr>
<td>$setOnInsert</td>
<td>如果更新导致文档插入，则设置字段的值。对修改现有文档的更新操作没有影响</td>
</tr>
<tr>
<td>$unset</td>
<td>从文档中删除指定的字段</td>
</tr>
</tbody></table>
<p><code>$set</code>操作符的使用例子：</p>
<p>将所有包含name为北京的数据，更新nums字段：</p>
<pre><code>db.city.update(&#123;&quot;name&quot;:&quot;北京&quot; &#125;,&#123;$set:&#123;&quot;nums&quot;:&quot;200&quot;&#125;&#125;,&#123;multi:true&#125;)
</code></pre>
<p>结果为：</p>
<p><img src="4.png"></p>
<p><code>$currentDate</code>操作符的使用格式是：</p>
<pre><code>  &#123; $currentDate: &#123; &lt;field1&gt;: &lt;typeSpecification1&gt;, ... &#125; &#125;

  &lt;typeSpecification&gt;字段可以是一个boolean true类型设置当前字段是日期Date类型，或者一个文档&#123; $type: &quot;timestamp&quot; &#125;或者&#123; $type: &quot;date&quot; &#125;根据指定的类型设置日期，该操作是只支持小写的timestamp和小写的date。
</code></pre>
<p>它只能用于update方法中：</p>
<pre><code>db.city.update(&#123;&quot;name&quot;:&quot;北京&quot; &#125;,&#123;$currentDate: &#123;lastModified: true,&quot;time.timestamp&quot;: &#123; $type: &quot;timestamp&quot; &#125;,&quot;time.date&quot;: &#123; $type: &quot;date&quot; &#125;&#125;&#125;)
</code></pre>
<p>运行结果：</p>
<pre><code>&gt; db.city.find(&#123;&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;5e281760f7cb355794d2a86a&quot;), &quot;name&quot; : &quot;北京&quot;, &quot;code&quot; : &quot;004&quot;, &quot;description&quot; : &quot;中华人民共和国首都&quot;, &quot;people&quot; : 21542000, &quot;tags&quot; : [ &quot;政治中心&quot;, &quot;文化中心&quot;, &quot;交流中心&quot; ], &quot;isCenter&quot; : false, &quot;lastModified&quot; : ISODate(&quot;2020-02-03T15:46:21.172Z&quot;), &quot;time&quot; : &#123; &quot;date&quot; : ISODate(&quot;2020-02-03T15:46:21.172Z&quot;), &quot;timestamp&quot; : Timestamp(1580744781, 1) &#125; &#125;
</code></pre>
<p><code>$inc</code>操作符的使用：  </p>
<p>它可以接收正的和负的值，如果指定的字段不存在则$inc操作符创建这个字段并且设置这个字段的值为指定的在值；如果使用$inc操作符的字段的值如果值为null或非数字则将会报异常；</p>
<pre><code>db.city.update(&#123;&quot;name&quot;:&quot;北京&quot; &#125;,&#123;$inc: &#123;&quot;people&quot;:-1&#125;&#125;)
</code></pre>
<p><code>$min/$max</code>操作符的使用：</p>
<pre><code>db.city.update(&#123;&quot;name&quot;:&quot;北京&quot; &#125;,&#123;$inc: &#123;&quot;people&quot;:-1&#125;&#125;)
</code></pre>
<p>如果指定的字段不存在的话会设置该字段的值为指定的值；不同类型的数据比较的时候会使用BSON比较规则；</p>
<pre><code>  db.city.update(&#123;&quot;name&quot;:&quot;北京&quot; &#125;,&#123;$min: &#123;&quot;people&quot;:10&#125;&#125;)
</code></pre>
<p>运行结果：</p>
<pre><code>  &gt; db.city.find(&#123;&#125;)
  &#123; &quot;_id&quot; : ObjectId(&quot;5e281760f7cb355794d2a86a&quot;), &quot;name&quot; : &quot;北京&quot;, &quot;code&quot; : &quot;004&quot;, &quot;description&quot; : &quot;中华人民共和国首都&quot;, &quot;people&quot; : 10, &quot;tags&quot; : [ &quot;政治中心&quot;, &quot;文化中心&quot;, &quot;交流中心&quot; ], &quot;isCenter&quot; : false, &quot;lastModified&quot; : ISODate(&quot;2020-02-03T15:46:21.172Z&quot;), &quot;time&quot; : &#123; &quot;date&quot; : ISODate(&quot;2020-02-03T15:46:21.172Z&quot;), &quot;timestamp&quot; : Timestamp(1580744781, 1) &#125; &#125;
</code></pre>
<p><code>$mul</code>操作符的使用：</p>
<p>如果指定的字段在文档中不存在，$mul操作符创建字段并且设置值为0作为乘数；如果使用$inc操作符的字段的值如果值为null或非数字则将会报异常;</p>
<pre><code>  db.city.update(&#123;&quot;name&quot;:&quot;北京&quot; &#125;,&#123;$mul: &#123;&quot;ins&quot;:100, &quot;people&quot;:-1&#125;&#125;)
</code></pre>
<p>运行结果：</p>
<pre><code>&gt; db.city.find(&#123;&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;5e281760f7cb355794d2a86a&quot;), &quot;name&quot; : &quot;北京&quot;, &quot;code&quot; : &quot;004&quot;, &quot;description&quot; : &quot;中华人民共和国首都&quot;, &quot;people&quot; : -10, &quot;tags&quot; : [ &quot;政治中心&quot;, &quot;文化中心&quot;, &quot;交流中心&quot; ], &quot;isCenter&quot; : false, &quot;lastModified&quot; : ISODate(&quot;2020-02-03T15:46:21.172Z&quot;), &quot;time&quot; : &#123; &quot;date&quot; : ISODate(&quot;2020-02-03T15:46:21.172Z&quot;), &quot;timestamp&quot; : Timestamp(1580744781, 1) &#125;, &quot;ins&quot; : 0 &#125;
</code></pre>
<p><code>$rename</code>操作符的使用：</p>
<pre><code>db.city.update(&#123;&quot;name&quot;:&quot;北京&quot; &#125;,&#123;$rename: &#123;&quot;ins&quot;:&quot;newIns&quot;&#125;&#125;)
</code></pre>
<p><code>$setOnInsert</code>操作符的使用:</p>
<p>如果upsert设为true。当满足查询条件的记录存在，则不执行$setOnInsert中的操作，当满足条件的记录不存在则执行$setOnInsert操作：</p>
<pre><code>   db.city.update(&#123;_id:100 &#125;,&#123;$setOnInsert: &#123;&quot;people&quot;:55&#125;&#125;,&#123; upsert: false &#125;)
   // 查询条件不存在，且upsert为false，不更新
   
   db.city.update(&#123;_id:100 &#125;,&#123;$setOnInsert: &#123;&quot;people&quot;:55&#125;&#125;,&#123; upsert: true &#125;)
   // 查询条件不存在，且upsert为true，更新一条数据
</code></pre>
<p><code>$unset</code>操作符的使用：</p>
<pre><code>  db.city.update(&#123;&quot;name&quot;:&quot;北京&quot; &#125;,&#123;$unset:&#123;&quot;nums&quot;:&quot;10&quot;&#125;&#125;,&#123;multi:true&#125;)
  //无论nums值是多少，均可删除nums字段
</code></pre>
<h4 id="数组更新操作符"><a href="#数组更新操作符" class="headerlink" title="数组更新操作符"></a>数组更新操作符</h4><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td>作为占位符，用来更新与查询条件匹配的第一个元素</td>
</tr>
<tr>
<td>$[]</td>
<td>作为占位符，用来更新与查询条件匹配的所有元素</td>
</tr>
<tr>
<td>$[&lt;identifier&gt;]</td>
<td>作为占位符，用来更新与查询条件匹配的，并且与arrayFilters条件匹配的所有元素</td>
</tr>
<tr>
<td>$addToSet</td>
<td>添加值到一个数组中去，如果数组中已经存在该值那么将不会有任何的操作</td>
</tr>
<tr>
<td>$push</td>
<td>把value追加到数组field里, 数组不存在则创建，且不会去重</td>
</tr>
<tr>
<td>$pop</td>
<td>删除数组内第一个或最后一个元素</td>
</tr>
<tr>
<td>$pull</td>
<td>从数组field内删除一个等于value的值。</td>
</tr>
<tr>
<td>$pullAll</td>
<td>用法同$pull一样，可以一次删除数组内的多个值</td>
</tr>
</tbody></table>
<p><code>$</code>操作符表示要更新的数组中的元素，且无需显式指定该元素在数组中的位置。对于文档：</p>
<pre><code>&#123; &quot;_id&quot; : 200, &quot;arr&quot; : [ 1, 2, 3, 4 ], &quot;obj&quot; : [ &#123; &quot;age&quot; : 10, &quot;name&quot; : &quot;Tom&quot; &#125;, &#123; &quot;age&quot; : 20, &quot;name&quot; : &quot;Jack&quot; &#125; ] &#125;
</code></pre>
<p>执行下面操作:</p>
<pre><code>&gt; db.city.update(&#123;_id:200,arr:3&#125;,&#123;$set:&#123;&quot;arr.$&quot;:300&#125;&#125;) //arr的3替换为300 

&gt; db.city.update(&#123;_id:200,&quot;obj.age&quot;:10&#125;,&#123;$set:&#123;&quot;obj.$.name&quot;:&quot;Leo&quot;&#125;&#125;) // obj中age为10的元素name属性改为Leo
</code></pre>
<p>运行结果：</p>
<pre><code>&gt; db.city.find(&#123;_id:200&#125;)
&#123; &quot;_id&quot; : 200, &quot;arr&quot; : [ 1, 2, 300, 4 ], &quot;obj&quot; : [ &#123; &quot;age&quot; : 10, &quot;name&quot; : &quot;Leo&quot; &#125;, &#123; &quot;age&quot; : 20, &quot;name&quot; : &quot;Jack&quot; &#125; ] &#125;
</code></pre>
<p><code>$[]</code>操作符表示要表示应修改指定数组字段中的所有元素。对于文档：</p>
<pre><code>  &#123; &quot;_id&quot; : 200, &quot;arr&quot; : [ 1, 2, 300, 4 ], &quot;obj&quot; : [ &#123; &quot;age&quot; : 10, &quot;name&quot; : &quot;Leo&quot; &#125;, &#123; &quot;age&quot; : 20, &quot;name&quot; : &quot;Jack&quot; &#125; ] &#125;
</code></pre>
<p>执行下面操作:</p>
<pre><code>&gt; db.city.update(&#123;_id:200,&quot;arr&quot;:1&#125;,&#123;$inc:&#123;&quot;arr.$[]&quot;:5&#125;&#125;)

&gt; db.city.update(&#123;_id:200&#125;,&#123;$inc:&#123;&quot;obj.$[].age&quot;:-2&#125;&#125;)
</code></pre>
<p>运行结果：</p>
<pre><code>&gt; db.city.find(&#123;_id:200&#125;)
&#123; &quot;_id&quot; : 200, &quot;arr&quot; : [ 6, 7, 305, 9 ], &quot;obj&quot; : [ &#123; &quot;age&quot; : 8, &quot;name&quot; : &quot;Leo&quot; &#125;, &#123; &quot;age&quot; : 18, &quot;name&quot; : &quot;Jack&quot; &#125; ] &#125;
</code></pre>
<p><code>$[&lt;identifier&gt;]</code>操作符则在<code>$[]</code>的基础上增加了arrayFilters字段的过滤。我们继续执行下面操作：</p>
<pre><code>&gt; db.city.update(&#123;_id:200&#125;,&#123;$inc:&#123;&quot;arr.$[element]&quot;:10&#125;&#125;,&#123; arrayFilters: [ &#123; &quot;element&quot;: &#123; $lt:100 &#125; &#125; ] &#125;)

&gt; db.city.update(&#123;_id:200&#125;,&#123;$inc:&#123;&quot;obj.$[element].age&quot;:4&#125;&#125;,&#123;arrayFilters: [ &#123; &quot;element.age&quot;: &#123; $gt: 10 &#125; &#125; ]&#125;) 
</code></pre>
<p>运行结果：</p>
<pre><code>&gt; db.city.find(&#123;_id:200&#125;)
&#123; &quot;_id&quot; : 200, &quot;arr&quot; : [ 16, 17, 305, 19 ], &quot;obj&quot; : [ &#123; &quot;age&quot; : 8, &quot;name&quot; : &quot;Leo&quot; &#125;, &#123; &quot;age&quot; : 22, &quot;name&quot; : &quot;Jack&quot; &#125; ] &#125;
</code></pre>
<p><code>$push</code>操作符要求操作的字段如果存在则必须为数组，否则会报错，它的使用：</p>
<pre><code>&gt; db.city.update(&#123;&quot;_id&quot;:101 &#125;,&#123;$push:&#123;&quot;tag&quot;:1&#125;&#125;)
</code></pre>
<p>运行结果（tag字段不存在）：</p>
<pre><code>&gt; db.city.find(&#123;&quot;_id&quot;:101 &#125;)
&#123; &quot;_id&quot; : 101, &quot;code&quot; : 8, &quot;tag&quot; : [ 1 ] &#125;
</code></pre>
<p><code>$addToSet</code>操作符的使用基本与<code>$push</code>等同，区别是<code>$addToSet</code>操作符会进行去重操作，如果添加的值已经存在，则不会添加。</p>
<pre><code>&gt; db.city.update(&#123;&quot;_id&quot;:101 &#125;,&#123;$addToSet:&#123;&quot;tag&quot;:1&#125;&#125;)
&gt; db.city.find(&#123;&quot;_id&quot;:101 &#125;)
&#123; &quot;_id&quot; : 101, &quot;code&quot; : 8, &quot;tag&quot; : [ 1 ] &#125;
</code></pre>
<p><code>$pop</code>操作符的使用：</p>
<pre><code>  &#123; $pop: &#123; &lt;field&gt;: &lt;-1 | 1&gt;, ... &#125; &#125;
  -1：删除第一个，1：删除第一个
</code></pre>
<p>对于文档：</p>
<pre><code>&#123; &quot;_id&quot; : 101, &quot;code&quot; : 8, &quot;tag&quot; : [ 1, 2, 3, 3, 4, 9 ] &#125;
</code></pre>
<p>删除第一个元素</p>
<pre><code>  &gt; db.city.update(&#123;&quot;_id&quot;:101 &#125;,&#123;$pop:&#123;&quot;tag&quot;:-1&#125;&#125;) 
  &gt; db.city.find(&#123;&quot;_id&quot;:101 &#125;)
  &#123; &quot;_id&quot; : 101, &quot;code&quot; : 8, &quot;tag&quot; : [ 2, 3, 3, 4, 9 ] &#125;  
</code></pre>
<p>删除最后一个元素</p>
<pre><code>  &gt; db.city.update(&#123;&quot;_id&quot;:101 &#125;,&#123;$pop:&#123;&quot;tag&quot;:1&#125;&#125;) 
  &gt; db.city.find(&#123;&quot;_id&quot;:101 &#125;)
  &#123; &quot;_id&quot; : 101, &quot;code&quot; : 8, &quot;tag&quot; : [ 2, 3, 3, 4] &#125;  
</code></pre>
<p><code>$pull</code>操作符的使用, 对于文档：</p>
<pre><code> &#123; &quot;_id&quot; : 101, &quot;code&quot; : 8, &quot;tag&quot; : [ 1, 2, 3, 3, 4, 9 ] &#125;
 
</code></pre>
<p>进行删除操作：</p>
<pre><code> db.city.update(&#123;&quot;_id&quot;:101 &#125;,&#123;$pull:&#123;&quot;tag&quot;:1&#125;&#125;)
</code></pre>
<p>运行结果：</p>
<pre><code>  &gt; db.city.find(&#123;&quot;_id&quot;:101 &#125;)
  &#123; &quot;_id&quot; : 101, &quot;code&quot; : 8, &quot;tag&quot; : [ 2, 3, 3, 4, 9 ] &#125;
</code></pre>
<p><code>$pullAll</code>操作符的使用，要删除的value必须放在数组内，否则会报错：</p>
<p>对于文档：</p>
<pre><code>  &#123; &quot;_id&quot; : 101, &quot;code&quot; : 8, &quot;tag&quot; : [ 2, 3, 3, 4, 9 ] &#125;
  
</code></pre>
<p>进行删除操作：</p>
<pre><code>  db.city.update(&#123;&quot;_id&quot;:101 &#125;,&#123;$pullAll:&#123;&quot;tag&quot;:[3,9]&#125;&#125;)
</code></pre>
<p>运行结果，所有的3与9均被删除：</p>
<pre><code>  &gt; db.city.find(&#123;&quot;_id&quot;:101 &#125;)
  &#123; &quot;_id&quot; : 101, &quot;code&quot; : 8, &quot;tag&quot; : [ 2, 4 ] &#125;
</code></pre>
<p>除了上述操作符外，更新操作还有几个修饰符操作</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>$each</td>
<td>使用$push或$addToSet操作符添加多个元素到数组字段中</td>
</tr>
<tr>
<td>$position</td>
<td>使用$push操作符插入数组中的数据元素的位置</td>
</tr>
<tr>
<td>$slice</td>
<td>限制使用$push操作符插入数组中的数据元素的数量</td>
</tr>
<tr>
<td>$sort</td>
<td>修改 $push 操作符</td>
</tr>
</tbody></table>
<p>例子1-同时插入多个数据：</p>
<pre><code>&gt; db.city.update(&#123;_id:300&#125;,&#123;$push:&#123;level:&#123;$each:[2,3,4,5,6]&#125;&#125;&#125;)
//结果：
&gt; db.city.find(&#123;_id:300&#125;)
&#123; &quot;_id&quot; : 300, &quot;level&quot; : [ 1, 2, 3, 4, 5, 6 ] &#125;
</code></pre>
<p>例子2-同时插入多个数据，并指定位置：</p>
<pre><code>  // $position值大于现有长度，则按目前数组长度开始追加
  &gt; db.city.update(&#123;_id:300&#125;,&#123;$push:&#123;level:&#123;$each:[2,3,4],$position:5&#125;&#125;&#125;)
  &#123; &quot;_id&quot; : 300, &quot;level&quot; : [ 1, 2, 3, 4 ] &#125;

  // $position值为负数时，则从数组最前面开始追加
  &gt; db.city.update(&#123;_id:300&#125;,&#123;$push:&#123;level:&#123;$each:[-2,-3,-4],$position:-5&#125;&#125;&#125;)
  &#123; &quot;_id&quot; : 300, &quot;level&quot; : [ -2, -3, -4, 1, 2, 3, 4 ] &#125;

  // 不超过目前现有数组长度时，则按指定位置开始追加
  &gt; db.city.update(&#123;_id:300&#125;,&#123;$push:&#123;level:&#123;$each:[0],$position:0&#125;&#125;&#125;)
  &#123; &quot;_id&quot; : 300, &quot;level&quot; : [ 0, -2, -3, -4, 1, 2, 3, 4 ] &#125;
</code></pre>
<p>例子3-同时插入多个数据，并进行截取：</p>
<p>原始数据为：<code>&#123; &quot;_id&quot; : 300, &quot;level&quot; : [ 0, -2, -3, -4, 1, 2, 3, 4 ] &#125;</code>，$slice的操作可以理解为执行$push操作后的数据再执行$slice操作：</p>
<pre><code>//大于0且小于最终数组长度时，会在指定位置开始切割数组
&gt; db.city.update(&#123;_id:300&#125;,&#123;$push:&#123;level:&#123;$each:[5,6],$slice:5&#125;&#125;&#125;)
&#123; &quot;_id&quot; : 300, &quot;level&quot; : [ 0, -2, -3, -4, 1 ] &#125;

//为负数时，则会从最终数组最后一位开始往前切割
&gt; db.city.update(&#123;_id:300&#125;,&#123;$push:&#123;level:&#123;$each:[5,6],$slice:-3&#125;&#125;&#125;)
&#123; &quot;_id&quot; : 300, &quot;level&quot; : [ 1, 5, 6 ] &#125;

//为0时则会将数组置空
&gt; db.city.update(&#123;_id:300&#125;,&#123;$push:&#123;level:&#123;$each:[5,6],$slice:0&#125;&#125;&#125;)
&#123; &quot;_id&quot; : 300, &quot;level&quot; : [ ] &#125;
</code></pre>
<p>例子4-同时插入多个数据，并按指定顺序排序($sort取值只能为1或者-1)：</p>
<pre><code>//按score正序排序
&gt; db.city.update(&#123;_id:400&#125;,&#123;$push:&#123;quiz:&#123;$each:[&#123;name:2,score:46&#125;,&#123;name:9,score:-23&#125;],$sort:&#123;score:1&#125;&#125;&#125;&#125;)
&#123; &quot;_id&quot; : 400, &quot;quiz&quot; : [ &#123; &quot;name&quot; : 9, &quot;score&quot; : -23 &#125;, &#123; &quot;name&quot; : 1, &quot;score&quot; : 34 &#125;, &#123; &quot;name&quot; : 2, &quot;score&quot; : 46 &#125; ] &#125;

//按score倒序排序
&gt; db.city.update(&#123;_id:400&#125;,&#123;$push:&#123;quiz:&#123;$each:[],$sort:&#123;score:-1&#125;&#125;&#125;&#125;)
&#123; &quot;_id&quot; : 400, &quot;quiz&quot; : [ &#123; &quot;name&quot; : 2, &quot;score&quot; : 46 &#125;, &#123; &quot;name&quot; : 1, &quot;score&quot; : 34 &#125;, &#123; &quot;name&quot; : 9, &quot;score&quot; : -23 &#125; ] &#125;
</code></pre>
<h4 id="位更新操作符"><a href="#位更新操作符" class="headerlink" title="位更新操作符"></a>位更新操作符</h4><p><code>$bit</code>运算符执行字段的按位更新，操作符的使用格式是：</p>
<pre><code>  &#123; $bit: &#123; &lt;field&gt;: &#123; &lt;and|or|xor&gt;: &lt;int&gt; &#125; &#125; &#125;
</code></pre>
<p>例如原始数据为：</p>
<pre><code>  &#123; &quot;_id&quot; : 101, &quot;code&quot; : 13 &#125;
</code></pre>
<p>执行与运算：</p>
<pre><code>  db.city.update(&#123;&quot;_id&quot;:101 &#125;,&#123;$bit: &#123;&quot;code&quot;:&#123;and:NumberInt(10)&#125;&#125;&#125;)
</code></pre>
<p>执行结果：</p>
<pre><code>  &#123; &quot;_id&quot; : 101, &quot;code&quot; : 8 &#125;
</code></pre>
<p>内部执行为：</p>
<pre><code>  1101
  1010
  ----
  1000
</code></pre>
<h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><p>查询文档使用find方法，语法格式如下：</p>
<pre><code>db.collection.find(query, projection)

参数说明：
- query ：可选，使用查询操作符指定查询条件
- projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。
</code></pre>
<p>例如，查询city集合下所有数据：</p>
<pre><code>&gt; db.city.find()
&#123; &quot;_id&quot; : ObjectId(&quot;5e281760f7cb355794d2a86a&quot;), &quot;name&quot; : &quot;北京&quot;, &quot;code&quot; : &quot;004&quot;, &quot;description&quot; : &quot;中华人民共和国首都&quot;, &quot;people&quot; : 21542000, &quot;tags&quot; : [ &quot;政治中心&quot;, &quot;文化中心&quot;, &quot;交流中心&quot; ], &quot;isCenter&quot; : false &#125;
&#123; &quot;_id&quot; : ObjectId(&quot;5e2818e9f7cb355794d2a86b&quot;), &quot;name&quot; : &quot;北京&quot;, &quot;code&quot; : &quot;004&quot;, &quot;description&quot; : &quot;中华人民共和国首都&quot;, &quot;people&quot; : 21542000, &quot;tags&quot; : [ &quot;政治中心&quot;, &quot;文化中心&quot;, &quot;交流中心&quot; ], &quot;isCenter&quot; : true &#125;
</code></pre>
<p>如果你需要以易读（格式化）的方式来读取数据，可以使用 pretty() 方法：</p>
<pre><code>&gt; db.city.find().pretty()
&#123;
  &quot;_id&quot; : ObjectId(&quot;5e281760f7cb355794d2a86a&quot;),
  &quot;name&quot; : &quot;北京&quot;,
  &quot;code&quot; : &quot;004&quot;,
  &quot;description&quot; : &quot;中华人民共和国首都&quot;,
  &quot;people&quot; : 21542000,
  &quot;tags&quot; : [
    &quot;政治中心&quot;,
    &quot;文化中心&quot;,
    &quot;交流中心&quot;
  ],
  &quot;isCenter&quot; : false
&#125;
&#123;
  &quot;_id&quot; : ObjectId(&quot;5e2818e9f7cb355794d2a86b&quot;),
  &quot;name&quot; : &quot;北京&quot;,
  &quot;code&quot; : &quot;004&quot;,
  &quot;description&quot; : &quot;中华人民共和国首都&quot;,
  &quot;people&quot; : 21542000,
  &quot;tags&quot; : [
    &quot;政治中心&quot;,
    &quot;文化中心&quot;,
    &quot;交流中心&quot;
  ],
  &quot;isCenter&quot; : true
&#125;
</code></pre>
<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>MongoDB支持类似MySql的where语句的条件查询：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>格式</th>
<th>例子</th>
<th>RDBMS中的类似语句</th>
<th>条件缩写解释</th>
</tr>
</thead>
<tbody><tr>
<td>等于</td>
<td>{&lt;key&gt;:&lt;value&gt;}</td>
<td>db.city.find({“name”:”北京”})</td>
<td>where name = ‘北京’</td>
<td>equal</td>
</tr>
<tr>
<td>小于</td>
<td>{&lt;key&gt;:{$lt:&lt;value&gt;}}</td>
<td>db.city.find({“nums”:{$lt:50}})</td>
<td>where nums &lt; 50</td>
<td>less than</td>
</tr>
<tr>
<td>小于或等于</td>
<td>{&lt;key&gt;:{$lte:&lt;value&gt;}}</td>
<td>db.city.find({“nums”:{$lte:50}})</td>
<td>where nums &lt;= 50</td>
<td>lt equal</td>
</tr>
<tr>
<td>大于</td>
<td>{&lt;key&gt;:{$gt:&lt;value&gt;}}</td>
<td>db.city.find({“nums”:{$gt:50}})</td>
<td>where nums &gt; 50</td>
<td>greater than</td>
</tr>
<tr>
<td>大于或等于</td>
<td>{&lt;key&gt;:{$gte:&lt;value&gt;}}</td>
<td>db.city.find({“nums”:{$gte:50}})</td>
<td>where nums &gt;= 50</td>
<td>gt equal</td>
</tr>
<tr>
<td>不等于</td>
<td>{&lt;key&gt;:{$ne:&lt;value&gt;}}</td>
<td>db.city.find({“nums”:{$ne:50}})</td>
<td>where nums != 50</td>
<td>not equal</td>
</tr>
</tbody></table>
<h4 id="AND查询"><a href="#AND查询" class="headerlink" title="AND查询"></a>AND查询</h4><p>MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开:</p>
<pre><code>&gt; db.city.find(&#123;&quot;isCenter&quot;:&#123;$ne:false&#125;,&quot;name&quot;:&quot;北京&quot;&#125;).pretty()
&#123;
  &quot;_id&quot; : ObjectId(&quot;5e2818e9f7cb355794d2a86b&quot;),
  &quot;name&quot; : &quot;北京&quot;,
  &quot;code&quot; : &quot;004&quot;,
  &quot;description&quot; : &quot;中华人民共和国首都&quot;,
  &quot;people&quot; : 21542000,
  &quot;tags&quot; : [
    &quot;政治中心&quot;,
    &quot;文化中心&quot;,
    &quot;交流中心&quot;
  ],
  &quot;isCenter&quot; : true
&#125;
</code></pre>
<h4 id="OR查询"><a href="#OR查询" class="headerlink" title="OR查询"></a>OR查询</h4><p>例如，我们查询city集合中，code为004，且包含 isCenter为true 或 name为天津 的数据（AND 和 OR 联合使用）:</p>
<pre><code>&gt; db.city.find(&#123;&quot;code&quot;:&quot;004&quot;,$or:[&#123;&quot;isCenter&quot;:true&#125;,&#123;&quot;name&quot;:&quot;天津&quot;&#125;]&#125;).pretty()
&#123;
  &quot;_id&quot; : ObjectId(&quot;5e2818e9f7cb355794d2a86b&quot;),
  &quot;name&quot; : &quot;北京&quot;,
  &quot;code&quot; : &quot;004&quot;,
  &quot;description&quot; : &quot;中华人民共和国首都&quot;,
  &quot;people&quot; : 21542000,
  &quot;tags&quot; : [
    &quot;政治中心&quot;,
    &quot;文化中心&quot;,
    &quot;交流中心&quot;
  ],
  &quot;isCenter&quot; : true
&#125;
&#123;
  &quot;_id&quot; : ObjectId(&quot;5e36cc388a5af806fe1893ae&quot;),
  &quot;name&quot; : &quot;天津&quot;,
  &quot;code&quot; : &quot;004&quot;
&#125;
</code></pre>
<h3 id="type-操作符"><a href="#type-操作符" class="headerlink" title="$type 操作符"></a>$type 操作符</h3><p>$type操作符是基于BSON类型来检索集合中匹配的数据类型，并返回结果。具体数值对应的数据类型<a href="https://www.runoob.com/mongodb/mongodb-operators-type.html">参考此处</a></p>
<p>例如我们查询所有id为Double类型的文档，结果如下：</p>
<p><img src="5.png"></p>
<h3 id="limit与skip方法"><a href="#limit与skip方法" class="headerlink" title="limit与skip方法"></a>limit与skip方法</h3><p>limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。skip()方法来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数：</p>
<p><img src="6.png"></p>
<h3 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h3><p>sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。</p>
<p><img src="7.png"></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>MongoDB 在创建集合期间在_id字段上创建了唯一索引。该索引可防止客户端插入两个_id字段值相同的文档。_id字段的索引不能删除。<br>MongoDB允许使用createIndex方法来手动创建索引，基本语法格式如下所示：</p>
<pre><code>db.collection.createIndex(keys, options)
</code></pre>
<p>Key 值为你要创建的索引字段，1 为指定按升序创建索引，-1 为按降序创建索引。</p>
<p>例如创建title作为索引</p>
<pre><code>db.col.createIndex(&#123;&quot;title&quot;:1&#125;)
</code></pre>
<p>也可以设置使用多个字段创建索引（关系型数据库中称作复合索引）。</p>
<pre><code>db.col.createIndex(&#123;&quot;title&quot;:1,&quot;description&quot;:-1&#125;)
</code></pre>
<p>关于options的具体配置可<a href="https://www.runoob.com/mongodb/mongodb-indexing.html">参见此处</a></p>
<h2 id="数据库创建管理员"><a href="#数据库创建管理员" class="headerlink" title="数据库创建管理员"></a>数据库创建管理员</h2><p>截止到目前，我们的数据库是对外开放的，意味着任何人只要拿到数据库地址，均可连接访问，显然，这是极其危险的，我们需要对数据库的访问加以限制：</p>
<p>切换到admin数据库：</p>
<pre><code>&gt; use admin
switched to db admin
</code></pre>
<p>创建管理员账号：</p>
<pre><code>&gt; db.createUser(&#123;user: &#39;admin&#39;, pwd: &#39;xxx&#39;,roles:[&#123;role: &#39;root&#39;, db: &#39;admin&#39;&#125;]&#125;)
</code></pre>
<p>此时我们需要重启下数据库（基于<code>/usr/local/mongodb/bin</code>目录）：</p>
<pre><code> ./mongod --shutdown  //关闭数据库
</code></pre>
<p>开启<code>/etc/mongod.conf</code>下的用户认证:</p>
<pre><code>  dbpath = /data/db  #数据存储目录
  logpath = /data/logs/mongodb.log # 日志目录
  fork = true  # 后台进程启动
  auth=true    # 开启验证
  port = 3001  # 端口号  
  bind_ip=0.0.0.0 # 对外访问
</code></pre>
<p>启动数据库：</p>
<pre><code>./mongod -f /etc/mongod.conf
</code></pre>
<p>这样便完成了用户校验功能。</p>
<h2 id="MongoDB监控"><a href="#MongoDB监控" class="headerlink" title="MongoDB监控"></a>MongoDB监控</h2><p>mongostat是mongodb自带的状态检测工具，在命令行下使用。它会间隔固定时间获取mongodb的当前运行状态，并输出。可以shell下执行：</p>
<pre><code>./mongostat --port 3001 -u admin -p xxxx  --authenticationDatabase=admin
</code></pre>
<p>运行结果：</p>
<p><img src="8.png"></p>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><pre><code>use admin
db.changeUserPassword(&#39;admin&#39;,&#39;12xxx&#39;);
</code></pre>
<h3 id="停止mongodb"><a href="#停止mongodb" class="headerlink" title="停止mongodb"></a>停止mongodb</h3><pre><code>db.shutdownServer()
</code></pre>
<p>尽量避免使用看kill命令来操作</p>
<h3 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h3><p>mongodb官网有配套的导出工具：<code>mongoexport</code>, 语法如下：</p>
<pre><code>  mongoexport -d dbname -c collectionname -o file --type json/csv -f field
</code></pre>
<p>参数说明：</p>
<pre><code>  -d ：数据库名
  -c ：collection名
  -o ：输出的文件名
  --type ： 输出的格式，默认为json
  -f ：输出的字段，如果-type为csv，则需要加上-f &quot;字段名&quot;
</code></pre>
<p>例子：</p>
<pre><code>   ./mongoexport -d manage -c orders -o d:/dbs/manage/order.json  # 进入安装目录bin下执行
</code></pre>
<p><img src="./9.png"></p>
<h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>mongodb官网有配套的导出工具：<code>mongoimport</code>, 语法如下：</p>
<pre><code>  mongoimport -d dbname -c collectionname --file filename --headerline --type json/csv -f field
  
</code></pre>
<p>参数说明：</p>
<pre><code>  -d ：数据库名
  -c ：collection名
  --type ：导入的格式默认json
  -f ：导入的字段名
  --headerline ：如果导入的格式是csv，则可以使用第一行的标题作为导入的字段
  --file ：要导入的文件
</code></pre>
<p>例子：</p>
<pre><code>  ./mongoimport --port 7000 -d manage -c orders --file /home/mongodb/dbs/manage/order.json  # 进入安装目录bin下执行
</code></pre>
<p><img src="./10.png"></p>
<p>导入导出过程中需启动mongodb服务，操作过程中无需密码，如果不是默认端口，需要指定端口。window下安装目录若无相关工具，请进入<a href="https://www.mongodb.com/try/download/database-tools">官网下载页面</a>进行下载安装</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/92898439">知乎专栏-MongoDB与MySQL：如何选择</a></li>
<li><a href="https://docs.mongodb.com/manual/reference/operator/update/">MongoDB官方文档-update方法</a></li>
<li><a href="https://www.cnblogs.com/qingtianyu2015/p/5968400.html">MongoDB导入导出以及数据库备份</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>noSql</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>是时候了解下APNG，WEBP了</title>
    <url>/%E6%98%AF%E6%97%B6%E5%80%99%E4%BA%86%E8%A7%A3%E4%B8%8BAPNG%EF%BC%8CWEBP%E4%BA%86/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在日常开发中除了经常看到的png,jpg,bmp,gif外，还存在一些其他图片格式，因为没有正式纳入标准，所以兼容性存在一定问题，但随着web的日益壮大，越来越多的浏览器开始支持这些新的格式，本文我们介绍下APNG与WEBP</p>
<span id="more"></span>

<h2 id="APNG"><a href="#APNG" class="headerlink" title="APNG"></a>APNG</h2><p>APNG（Animated Portable Network Graphics）顾名思义是基于 PNG 格式扩展的一种动画格式，增加了对动画图像的支持，同时加入了 24 位图像和 8 位 Alpha 透明度的支持，这意味着动画将拥有更好的质量，其诞生的目的是为了替代老旧的 GIF 格式，但它目前并没有获得 PNG 组织官方的认可。</p>
<p>APNG 的出现就是为了替代 GIF，诞生于 1987 年的 GIF 为什么能存活 29 年之久？</p>
<p>主要有四个原因：</p>
<ul>
<li>几乎所有的主流浏览器都支持 GIF</li>
<li>早期选择不多，GIF 几乎是唯一选择（GIF - 1987、JPEG - 1992、PNG - 1996、APNG - 2004、WebP - 2010）</li>
<li>实现起来简单，制作的工具多</li>
<li>采用 LZW 数据压缩算法，使得 GIF 体积小，在早期慢速的互联网易于传播</li>
</ul>
<h3 id="为什么要取代gif"><a href="#为什么要取代gif" class="headerlink" title="为什么要取代gif"></a>为什么要取代gif</h3><ul>
<li>最多支持 8 位 256 色，色阶过渡糟糕，图片具有颗粒感</li>
<li>不支持 Alpha 透明通道，边缘有杂边</li>
</ul>
<h3 id="APNG的优点"><a href="#APNG的优点" class="headerlink" title="APNG的优点"></a>APNG的优点</h3><ul>
<li>支持 24 位真彩色图片</li>
<li>支持 8 位 Alpha 透明通道</li>
<li>向下兼容 PNG（不支持动画会展示第一帧静态png图片）</li>
<li>更小的体积：多数情况下比 GIF、WebP 以及有损的 WebP 的体积小</li>
</ul>
<p>假设假设使用一个 4 帧图片合成 APNG，APNG 会通过算法计算帧之间的差异，只存储帧之前的差异，而不是存储全帧，这就是为什么APNG体积更小的原因。</p>
<style>img[title=gif],img[title=apng]{background-color:#000}</style>

<p>gif图片：</p>
<p><img src="./gif.gif" title="gif"></p>
<p>apng图片（如果展示为静态图说明不支持apng）：</p>
<p><img src="./apng.png" title="apng"></p>
<p>可以看出来apng边缘没有杂边，质量要好很多。</p>
<h3 id="如何制作"><a href="#如何制作" class="headerlink" title="如何制作"></a>如何制作</h3><p><a href="http://littlesvr.ca/apng/">APNG Software</a>网站上有大量的制作工具，可根据需求选用。</p>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="./1.png"></p>
<p>从上图可以看到apng的支持率已达到90%，基本可以放心使用。</p>
<h2 id="WEBP"><a href="#WEBP" class="headerlink" title="WEBP"></a>WEBP</h2><p>目前网络中图片仍然是占用流量较大的一部分，对于移动端更是如此。JPEG、PNG、GIF等常用图片格式的优化已几乎达到极致，因此Google于2010年提出了一种新的图片压缩格式 — WebP，给图片的优化提供了新的可能。</p>
<p>又拍云有关于webp的详细介绍（从demo可以看出对比png，webp最多可压缩98%的大小）：</p>
<p><a href="https://www.upyun.com/webp?utm_source=zhihu&utm_medium=referral&utm_campaign=202838955&utm_term=webp">又拍云在线体验</a></p>
<h3 id="动态WEBP"><a href="#动态WEBP" class="headerlink" title="动态WEBP"></a>动态WEBP</h3><p>没错，webp的“野心”只是替换静态图片，对于动图也做了支持。谷歌于2014年提出了动态WebP，拓展WebP使其支持动图能力。动态WebP相比GIF支持更丰富的色彩，并且也占用更小空间。</p>
<p>WebP的优势在于它具有更优的图像数据压缩算法，在拥有肉眼无法识别差异的图像质量前提下，带来更小的图片体积，同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都非常优秀、稳定和统一。</p>
<h3 id="兼容性-1"><a href="#兼容性-1" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="./2.png"></p>
<p>从上图可以看到webp的支持率大约为80%左右，还是存在一些兼容性问题的，对于桌面开发来说，无须关心兼容性，可以放心使用。</p>
<p>对于不支持webp的浏览器（如Safari），打开图片时，浏览器会直接进行下载保存操作，不会展示图片。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://aotu.io/notes/2016/11/07/apng/index.html">APNG 那些事</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23648251">WebP原理和Android支持现状介绍-知乎专栏</a></li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>APNG</tag>
        <tag>WEBP</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析qiankun中的样式隔离与JS沙箱机制</title>
    <url>/%E6%B5%85%E6%9E%90qiankun%E4%B8%AD%E7%9A%84%E6%A0%B7%E5%BC%8F%E9%9A%94%E7%A6%BB%E4%B8%8EJS%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>随着各种“微服务”的流行，“微前端”的概念也被创造出来，在浏览知乎时看到好几篇文章都与“微前端”相关，而<a href="https://qiankun.umijs.org/zh/guide">qiankun</a>更是各类文章绕不开的话题。对于这种新兴的概念我们不表，技术终究是用来为业务服务的，不是越新越好，譬如：<a href="https://zhuanlan.zhihu.com/p/392152863">你可能不需要微前端</a>中就比较中肯，微前端不是银弹，适合自己的才是最好的。</p>
<p>说了一大推，我们回到qiankun上，因为他不是iframe, 所以我一直比较好奇：它是如果实现应用之间的样式与运行时的隔离？</p>
<span id="more"></span>

<h2 id="样式隔离"><a href="#样式隔离" class="headerlink" title="样式隔离"></a>样式隔离</h2><p>通常的实践是通过约定 css 前缀的方式来避免样式冲突，但这属于人为约定，无法保证结果。我们试图从纯技术角度来解决这个问题</p>
<h3 id="Shadow-DOM"><a href="#Shadow-DOM" class="headerlink" title="Shadow DOM"></a>Shadow DOM</h3><p>shadow DOM并不是一个特别新的概念，html中的video标签就是使用shadow DOM的一个案例。使用它时，你在html只会看到一个video标签，但实际上播放器上还有一系列按钮和其他操作，这些就都是封装到shadow dom中的，对外界是不可见的。所以Shadow DOM天然实现了样式隔离。</p>
<p><img src="./2.gif"></p>
<p>更多请访问：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM">MDN-使用 shadow DOM</a></p>
<h3 id="Dynamic-Stylesheet"><a href="#Dynamic-Stylesheet" class="headerlink" title="Dynamic Stylesheet"></a>Dynamic Stylesheet</h3><p>动态插入/移除样式DOM, 没错，这是一个及其简单的方式。原理是浏览器会对所有的样式表的插入、移除做整个 CSSOM 的重构，从而达到 插入、卸载 样式的目的：</p>
<p><img src="./1.gif"></p>
<p>qiankun采用就是这种方案。但这个方案并非完美，它只解决了子应用之间的样式隔离，对于主应用与子应用之间的样式隔离并未解决，参见：<a href="https://zhuanlan.zhihu.com/p/392152863">你可能不需要微前端</a></p>
<h2 id="JS沙箱"><a href="#JS沙箱" class="headerlink" title="JS沙箱"></a>JS沙箱</h2><p>因为各个应用之间的全局变量会互相污染，所以JS沙箱比样式隔离的问题更棘手，社区的普遍玩法是给一些全局副作用加各种前缀从而避免冲突。但其实我们都明白，口头约定这种东西并不靠谱，而且对于已经开发完毕的老系统，这种约定方案并不适用。</p>
<p>其实这部分才是我一直好奇的地方，翻看几篇博客，大致明白了原理：</p>
<p>qiankun的沙箱隔离机制主要分为三种：</p>
<ul>
<li>legacySandBox</li>
<li>proxySandBox</li>
<li>snapshotSandBox</li>
</ul>
<p>其中 legacySandBox、proxySandBox 是基于 Proxy API 来实现的，在不支持 Proxy API 的低版本浏览器中，会降级为 snapshotSandBox</p>
<p>这里我们梳理下主要设计思路，具体的代码实现可参考源码或文末的链接</p>
<h3 id="legacySandBox"><a href="#legacySandBox" class="headerlink" title="legacySandBox"></a>legacySandBox</h3><p>legacySandBox 的本质上还是操作 window 对象，但是他会存在三个状态池，分别用于子应用卸载时还原主应用的状态和子应用加载时还原子应用的状态</p>
<ul>
<li>addedPropsMapInSandbox： 存储在子应用运行时期间新增的全局变量，用于卸载子应用时还原主应用全局变量；</li>
<li>modifiedPropsOriginalValueMapInSandbox：存储在子应用运行期间更新的全局变量，用于卸载子应用时还原主应用全局变量；</li>
<li>currentUpdatedPropsValueMap：存储子应用全局变量的更新，用于运行时切换后还原子应用的状态；</li>
</ul>
<p>同样会对window造成污染(虽然污染已经降到了最低)，但是性能比快照沙箱好，不用遍历window对象。</p>
<h3 id="proxySandBox"><a href="#proxySandBox" class="headerlink" title="proxySandBox"></a>proxySandBox</h3><p>在 qiankun 中，proxySandBox 用于多实例场景。一般我们的中后台系统同一时间只会加载一个子应用的运行时。但是也存在同一时间加载多个子应用的场景。</p>
<p>原理大致如下：激活沙箱后，每次对window取值的时候，先从自己沙箱环境的fakeWindow里面找，如果不存在，就从rawWindow(外部的window)里去找；当对沙箱内部的window对象赋值的时候，会直接操作fakeWindow，而不会影响到rawWindow。</p>
<h3 id="snapshotSandBox"><a href="#snapshotSandBox" class="headerlink" title="snapshotSandBox"></a>snapshotSandBox</h3><p>对于不支持proxy的浏览器，会降级为此模式。主要的原理就是在子应用激活 / 卸载时分别去通过快照的形式记录/还原状态来实现沙箱的。通过对当前的 window 和记录的快照做 diff 来实现沙箱。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/78362028">可能是你见过最完善的微前端解决方案</a></li>
<li><a href="https://www.jianshu.com/p/dc74e3705e4f">浏览器新特性–shadow DOM</a></li>
<li><a href="https://juejin.cn/post/6920110573418086413">15分钟快速理解qiankun的js沙箱原理及其实现</a></li>
<li><a href="https://segmentfault.com/a/1190000038219823">解密微前端：从qiankun看沙箱隔离</a></li>
</ul>
]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>qiankun</tag>
        <tag>隔离</tag>
        <tag>沙箱</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈WebAssembly</title>
    <url>/%E6%B5%85%E8%B0%88WebAssembly/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>WebAssembly（缩写为Wasm）是一种新的编码方式，编码标准。它并不是一门编程语言，而是一份字节码标准，需要用高级编程语言编译出字节码放到 WebAssembly 虚拟机中才能运行， 浏览器厂商需要做的就是根据 WebAssembly 规范实现虚拟机。<br>wasm格式的文件，接近java的字节码，它是通过编译工具（如Emscripten）从高级语言（如C / C ++ / Rust）等编译而来，他可以同js文件一样运行在客户端与服务端。2019年12月5日，W3C WebAssembly 工作组发布 WebAssembly 正式推荐标准（W3C Recommendation）。</p>
<p>WebAssembly具有巨大的意义——它提供了一条途径，以使得以各种语言编写的代码都可以以接近原生的速度在Web中运行。</p>
<p><img src="./01.png"></p>
<span id="more"></span>

<h2 id="为什么需要WebAssembly"><a href="#为什么需要WebAssembly" class="headerlink" title="为什么需要WebAssembly"></a>为什么需要WebAssembly</h2><ul>
<li> javascript语言本身的缺陷，如，没有静态变量类型、语法太灵活导致开发大型 Web 项目困难。</li>
<li> 解释性语言的执行效率相比底层语言要慢很多，性能问题无法突破。</li>
</ul>
<h2 id="WebAssembly-有什么优点"><a href="#WebAssembly-有什么优点" class="headerlink" title="WebAssembly 有什么优点"></a>WebAssembly 有什么优点</h2><ul>
<li>体积小：由于浏览器运行时只加载编译成的字节码，一样的逻辑比用字符串描述的 JS 文件体积要小很多；</li>
<li>加载快：由于文件体积小，再加上无需解释执行，WebAssembly 能更快的加载并实例化，减少运行前的等待时间；</li>
<li>兼容性问题少：WebAssembly 是非常底层的字节码规范，制订好后很少变动，就算以后发生变化,也只需在从高级语言编译成字节码过程中做兼容。可能出现兼容性问题的地方在于 JS 和 WebAssembly 桥接的 JS 接口。</li>
</ul>
<h2 id="WebAssembly-是如何工作的"><a href="#WebAssembly-是如何工作的" class="headerlink" title="WebAssembly 是如何工作的"></a>WebAssembly 是如何工作的</h2><p>我们都知道，机器只能识别0与1，但是这些机器码对人来说是难以阅读与理解的，对于js开发人员来说，JS运行环境中都存在着JavaScript引擎，它的工作就是把你的人类语言转化成机器所理解的语言，而翻译的过程一般有两种模式：</p>
<ul>
<li>使用解释器，翻译的过程基本上是一行一行及时生效的。</li>
<li>使用编译器，在执行前翻译。<br>两种方式各有利弊，实际的浏览器厂商开始引入了编译器来解决解释器重复执行的问题，此处有兴趣的可以了解下浏览器的<a href="https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/">JIT模式</a></li>
</ul>
<p>一般高级语言不会直接通过编译器直接将语言转化为机器语言（如，汇编），这样效率比较低，通常编译器将把高级语言翻译成一种更低级的语言，但比机器码的等级高。这就是中间代码（IR）：</p>
<p><img src="./02.png"></p>
<p>编译器的“前端”将高级编程语言转换为IR。编译器的“后端”将 IR 转换成目标机器的汇编代码。<br>而WebAssembly 字节码不能直接在任何一种 CPU 架构上运行，它是一种抹平了不同 CPU 架构的机器码，由于非常接近机器码，可以非常快的被翻译为对应架构的机器码（它比 JavaScript 代码更快更直接的转换成机器代码，但它们不直接和特定硬件的特定机器代码对应）：</p>
<p><img src="./03.png"></p>
<p>浏览器加载wasm文件后，可以迅速将WebAssembly 字节码转化为机器码，因而执行效率非常高。</p>
<h2 id="在浏览器使用WebAssembly"><a href="#在浏览器使用WebAssembly" class="headerlink" title="在浏览器使用WebAssembly"></a>在浏览器使用WebAssembly</h2><p>对于JavaScript调用wasm（目前还不能像js文件那样直接引用，只能通过 JS 去加载和执行），一般采用如下步骤：</p>
<ol>
<li><p>加载wasm的字节码。</p>
</li>
<li><p>将获取到字节码后转换成 ArrayBuffer，只有这种结构才能被正确编译。编译时会对上述ArrayBuffer进行验证。验证通过方可编译。编译后会通过Promise resolve一个 WebAssembly.Module。</p>
</li>
<li><p>在获取到 module 后需要通过 WebAssembly.Instance API 去同步的实例化 module。</p>
</li>
<li><p>上述第2、3步骤可以用instaniate 异步API等价代替。</p>
</li>
<li><p>之后就可以和像使用JavaScript模块一样调用了。</p>
</li>
</ol>
<p>完整的步骤，也可以参见下面的流程图：</p>
<p><img src="./06.png"></p>
<p>我们看一个实际的demo : <a href="https://roblin.cn/wasm/">通过wasm实现的一种视频播放器</a></p>
<p>查看源码可以看到：</p>
<p><img src="./07.jpg"></p>
<p>控制台里面有.wasm调用：</p>
<p><img src="./08.png"></p>
<p><img src="./09.png"></p>
<p>当然，在WebAssembly也可以调用js, 例如通过<code>WebAssembly.instantiate</code>方法等，此处不再详细介绍。</p>
<h2 id="个人看法"><a href="#个人看法" class="headerlink" title="个人看法"></a>个人看法</h2><p>WebAssembly可以说是web领域的一种扩展，他与javascript是互补，它更多是用在需要大量计算的场景，如大型游戏等，并不是要取代(也无法取代)javascript。其学习成本还是比较高的，而且还有许多性能问题需要去解决，目前成熟的产品似乎只有Google Earth，Egret Engine等，现阶段了解即可，因为几乎没有什么应用场景。WebAssembly依旧任重而道远，且看web的翻天覆地变化吧~</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.ibm.com/developerworks/cn/web/wa-lo-webassembly-status-and-reality/index.html">WebAssembly 现状与实战</a></li>
<li><a href="https://www.w3.org/TR/2019/REC-wasm-web-api-1-20191205/">W3C-WebAssembly Web API</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/WebAssembly/Using_the_JavaScript_API">MDN-使用WebAssembly JavaScript API</a></li>
<li><a href="https://www.jianshu.com/p/bff8aa23fe4d">几张图看懂WebAssembly</a></li>
<li><a href="https://mp.weixin.qq.com/s/MgaanmCN3EIn8GTbXGAD6A">20分钟上手WebAssembly</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WebAssembly</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈字符编码与字符集</title>
    <url>/%E6%B5%85%E8%B0%88%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E9%9B%86/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。</p>
<p>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的对应关系，做了统一规定。这被称为 ASCII 码。ASCII 码一共规定了128个字符的编码，这对英文来说是够用的，但是对于中文来说就远远不够了。每个国家就各自来对 ASCII 字符集做了拓展，最具代表性的就是国内的 GB 类的汉字编码模式，如GB2312字符集。</p>
<p>但当各国互相接轨时就出现了问题：世界上各国都有不同的编码方式（虽然都兼容了ASCII码），同一个二进制数字可以被解码成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。这时候为了解决这个问题，最终的集大成者 Unicode 字符集出现了，它将世界上所有的符号都纳入其中，成功实现了每个数字代表唯一的至少在某种语言中使用的符号。</p>
<span id="more"></span>

<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>Unicode 表示的是一个字符集（注意不是编码方式），但是它衍生出来的编码方案却有三种，分别是 UTF-32、UTF-16 和 UTF-8。而ASCII、GBK 等类编码模式的字符集和编码方式都是一一对应的。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式：</p>
<ul>
<li>对于只有一个字节的符号，字节的第一位设为0，后面 7 位为这个符号的 Unicode 码。此时，对于英语字母UTF-8 编码和 ASCII 码是相同的</li>
<li>对于 n 字节的符号（n &gt; 1），第一个字节的前 n 位都设为 1，第 n + 1 位设为0，后面字节的前两位一律设为 10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码</li>
</ul>
<h3 id="UTF-16-与-UTF-32"><a href="#UTF-16-与-UTF-32" class="headerlink" title="UTF-16 与 UTF-32"></a>UTF-16 与 UTF-32</h3><p>UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示）都是用固定字节来存储，</p>
<p>只有 UTF-8 兼容 ASCII，UTF-32 和 UTF-16 都不兼容 ASCII，因为它们没有单字节编码。</p>
<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>BOM即Byte Order Mark字节序标记。BOM是为UTF-16和UTF-32准备的，用户标记字节序（byte order）。</p>
<h3 id="UTF-8-BOM"><a href="#UTF-8-BOM" class="headerlink" title="UTF-8 BOM"></a>UTF-8 BOM</h3><p>UTF-8 BOM又叫UTF-8 签名，UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。当文本程序读取到以 EF BB BF开头的字节流时，就知道这是UTF-8编码了。Windows就是使用BOM来标记文本文件的编码方式的</p>
<p>我们将一个文本保存为utf-8 带BOM格式，使用fs模块读取(fs.readFile)下文件，得到：</p>
<pre><code>  &lt;Buffer ef bb bf e5 93 88 e5 93 88&gt;
</code></pre>
<p>我们再将其保存为utf-8 无 BOM格式，得到：</p>
<pre><code>  &lt;Buffer e5 93 88 e5 93 88&gt;
</code></pre>
<h3 id="UTF-16-LE-与-UTF-16-BE"><a href="#UTF-16-LE-与-UTF-16-BE" class="headerlink" title="UTF-16 LE 与 UTF-16 BE"></a>UTF-16 LE 与 UTF-16 BE</h3><p>UTF-16，是定长编码，是双字节编码，所以两个字节保存时哪个在前，哪个在后关系到解析出字符的结果。</p>
<p>UTF-16BE (little endian), 俗称小头；UTF-16BE (big endian), 俗称大头；</p>
<p>出现 BE 和 LE 的编码，则是由于历史原因造成的：在 Mac 和 PC 机上，对字节顺序的理解是不一致的。如果一个文件不明确说明 UTF16 使用的是 BE 还是 LE，那么就需要通过 BOM 来指明了, 一般X86机器上都是UTF-16LE。其开始的两个字节也表示该字节数组是大端还是小端：FE FF表示大端，FF FE表示小端。</p>
<p>同样，我们分别读取一个UTF-16LE的文本与UTF-16BE的文本，结果如下：</p>
<pre><code>UTF-16LE (little endian)

    &lt;Buffer ff fe c8 54 c8 54&gt;

UTF-16BE (big endian)

    &lt;Buffer fe ff 54 c8 54 c8&gt;
</code></pre>
<p>PS: win10 中记事本功能相比win7做了升级，编码方式更一目了然：</p>
<ul>
<li>旧版的“Unicode”相当于新版的“UTF-16 LE”；</li>
<li>旧版的“Unicode big endian”相当于新版的“UTF-16 BE”；</li>
</ul>
<h2 id="HTML-CSS-JS的编码"><a href="#HTML-CSS-JS的编码" class="headerlink" title="HTML/CSS/JS的编码"></a>HTML/CSS/JS的编码</h2><p>首选明确的是HTML,CSS和JS，采用的都是Unicode字符集，只是编码方式会稍有不同。</p>
<p>HTML5 中的默认字符编码方式为 UTF-8，这在meta标签中可以声明：</p>
<pre><code>  &lt;meta charset=&quot;UTF-8&quot;&gt;
  
</code></pre>
<p>对于css文件，可以通过以下代码声明编码方式：</p>
<pre><code>  @charset utf-8
</code></pre>
<p>需要注意的是，这种只支持css文件，对于style标签是不支持的。</p>
<p>JavaScript中仅支持ucs-2编码，可以将它理解为utf16的子集，这里面的历史原因可以查看：<a href="http://www.ruanyifeng.com/blog/2014/12/unicode.html">Unicode与JavaScript详解</a></p>
<h3 id="对于Unicode字符集的各自表示方式"><a href="#对于Unicode字符集的各自表示方式" class="headerlink" title="对于Unicode字符集的各自表示方式"></a>对于Unicode字符集的各自表示方式</h3><table>
<thead>
<tr>
<th>类型</th>
<th>表示方式</th>
</tr>
</thead>
<tbody><tr>
<td>HTML</td>
<td>十进制：<code>&amp;#&#123;unicode&#125;;</code>，如：<code>&amp;#20320;</code> <br>十六进制：<code>&amp;#x&#123;unicode&#125;;</code>，如：<code>&amp;#x4F60;</code></td>
</tr>
<tr>
<td>CSS</td>
<td>只接受十六进制的unicode字符：<code>\&#123;unicode&#125;</code>，需要反斜杠转义，如：<code>\4F60;</code>，<code>\3c;</code></td>
</tr>
<tr>
<td>Javascript</td>
<td>4位十六进制： <code>\u&#123;unicode&#125;</code>，如：<code>\u4F60</code><br>2位十六进制：<code>\x&#123;unicode&#125;</code>，如：<code>\x3c</code></td>
</tr>
</tbody></table>
<p>我们以汉字“你”为例，可以通过js内置的方法获取他的十进制与十六进制编码：</p>
<pre><code>    &#39;你&#39;.charCodeAt();  // 20320 十进制 
    &#39;你&#39;.charCodeAt().toString(16) //&quot;4f60&quot; 十六进制 
</code></pre>
<p>所以，我们分别在html，css，js中编写如下代码：</p>
<pre><code>&lt;style&gt;.cont:after&#123; content: &quot;\4F60&quot;;display: block;&#125; &lt;/style&gt;
&lt;p&gt;&amp;#20320;&lt;/p&gt; 
&lt;h1&gt;&amp;#x4F60;&lt;/h1&gt;
&lt;h1 class=&quot;cont&quot;&gt;&lt;/h1&gt;
&lt;script&gt;
  console.log(&#39;\u4F60&#39;);
  console.log(&#39;\x3c&#39;);
&lt;/script&gt;
</code></pre>
<p>得到如下结果：</p>
<p><img src="./1.png"></p>
<p>对于HTML而言，标准里面规定了一些特殊字符的使用，这些字符被称为：<a href="https://codescracker.com/html/html-character-entities.htm#:~:text=The%20character%20entity%20is%20composed%20of%20the%20following,Name%20of%20the%20entity%203%20A%20terminating%20semicolon">HTML转义字符串（Escape Sequence）</a>也称字符实体(Character Entity) 。对于这些特殊字符，推荐直接使用转义字符来直接表示，当然，如果非要使用十进制或十六进制的unicode码来表示也可以：</p>
<pre><code>  &lt;h1&gt;&amp;#60;&lt;/h1&gt;
  &lt;h1&gt;&amp;#x3c;&lt;/h1&gt;
  &lt;h1&gt;&amp;lt;&lt;/h1&gt;
</code></pre>
<p>结果都是小于号</p>
<h2 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h2><p>字体图标其实已经应用很广泛了，iconfont, Font Awesome等都是常见的字体图标库，他的原理其实也很简单。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>HTML/CSS中解析出来的unicode字符会根据当前的字体库设置（font-family属性）来进行查找绘制：</p>
<pre><code>&lt;style&gt;h1&#123;font-family: serif;&#125;&lt;/style&gt;
&lt;h1&gt;&amp;#x4F60;&lt;/h1&gt;
</code></pre>
<p>浏览器会在serif字体（系统内置）中查找<code>4F60</code>所对应的样式进行绘制，从而展示在用户面前。</p>
<p>而css支持自定义字体，预先将不同的编码与图形样式（字体也是一种矢量图形）做好映射关系，生成字体文件，浏览器渲染时候就可以根据当前的字符去渲染对应的图形，从而实现字体图标。</p>
<p>字体图标的好处就是均为矢量图形，设备展示统一，且便于管理。字体文件其实是一套外形描述的集合，对于svg大家都不陌生：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;&lt;svg t=&quot;1624271624281&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;21339&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;32&quot; height=&quot;32&quot;&gt;&lt;defs&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;&lt;/defs&gt;&lt;path d=&quot;M512 62c140.401 0 297.65 117.936 303.265 292.033 33.697 33.697 33.697 101.089 28.080 146.017 73.008 67.392 89.857 179.712 73.008 224.641-11.232 44.928-39.312 67.392-95.472-22.464-11.232 50.544-67.392 106.704-67.392 106.704 73.008 16.848 95.472 84.241 73.008 112.321-22.464 28.080-224.641 67.392-325.73-16.848-67.392 56.16-241.489 78.624-303.264 33.697-56.16-50.544-11.232-112.321 44.928-129.169-50.544-22.464-56.16-101.089-56.16-101.089-33.697 44.928-78.624 89.857-95.472 5.617-5.617-89.857 61.777-202.177 101.088-224.641-16.848-39.312-11.232-78.624 22.464-101.089 11.232-101.089 73.008-325.73 297.65-325.73z&quot; p-id=&quot;21340&quot;&gt;&lt;/path&gt;&lt;/svg&gt;
</code></pre>
<p>他里面就充斥着各种路径描述的说明，svg可以很容易转成ttf, woff等文件，原理基本类似。</p>
<p>unicode字符集里面，E000 至 F8FF属于用户造字区。原本是空的，常见的字体图标一般都在这个区域内。</p>
<h3 id="彩色字体图标"><a href="#彩色字体图标" class="headerlink" title="彩色字体图标"></a>彩色字体图标</h3><p>字体在很长时间内都是只支持单色的，OT-SVG 和 COLR两个标准开始支持多色彩字体，chrome支持的是COLR标准，目前该标准的兼容性还不错，iconfont也做了适配，可以尝试使用：</p>
<p><img src="./2.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/1BtBnne5Jm4gPGCRfjoZ9w">Java技术栈：看完这篇，你也是字符编码大神！</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">阮一峰：字符编码笔记：ASCII，Unicode 和 UTF-8</a></li>
<li><a href="https://www.iconfont.cn/help/article_detail?spm=a313x.7781069.1998910419.30&article_id=7">iconfont 支持全新的彩色字体图标</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/12/unicode.html">Unicode与JavaScript详解</a></li>
<li><a href="https://yanhaijing.com/web/2014/12/20/web-charset/">Web编码总结</a></li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>字符</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器数据库 IndexedDB</title>
    <url>/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%95%B0%E6%8D%AE%E5%BA%93-IndexedDB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>现有的浏览器存储方案有，cookie, localStorage, sessionStorage,他们都可以进行存储，但仅限于key-value形式，而且只能存储字符串，且Cookie 的大小不超过4KB，且每次请求都会发送回服务器；LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。所以，需要一种新的解决方案，于是 IndexedDB 就诞生了。</p>
<span id="more"></span>

<h2 id="IndexedDB-简介"><a href="#IndexedDB-简介" class="headerlink" title="IndexedDB 简介"></a>IndexedDB 简介</h2><p>顾名思义，DB就是database,是浏览器提供的本地数据库，而说到数据库，有两种不同类型的数据库，就是关系型数据库和非关系型数据库，关系型数据库如Mysql、Oracle等将数据存储在表中，而非关系型数据库如Redis、MongoDB等将数据集作为个体对象存储。indexedDB就是一个非关系型数据库，它不需要你去写一些特定的sql语句来对数据库进行操作，因为它是nosql的，数据形式使用的是json。</p>
<p>IndexedDB就不仅仅限于字符串的存储了，它可以存储更复杂的类型，如 Uint8Array, Int8Array, ArrayBuffer, Blob等二进制数据，而且存空间大, 一般来说不少于 250MB，甚至没有上限。IndexedDB同样受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p> 不同于localStorage，IndexedDB的所有操作都是异步的。  </p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>数据库是一系列相关数据的容器。每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库。</p>
<p>IndexedDB 数据库有版本的概念。同一个时刻，只能有一个版本的数据库存在。如果要修改数据库结构（新增或删除表、索引或者主键），只能通过升级数据库版本完成。</p>
<h4 id="对象仓库"><a href="#对象仓库" class="headerlink" title="对象仓库"></a>对象仓库</h4><p>每个数据库包含若干个对象仓库（object store）。它类似于关系型数据库的表格。</p>
<h4 id="数据记录"><a href="#数据记录" class="headerlink" title="数据记录"></a>数据记录</h4><p>对象仓库保存的是数据记录。每条记录类似于关系型数据库的行，但是只有主键和数据体两部分。主键用来建立默认的索引，必须是不同的，否则会报错。主键可以是数据记录里面的一个属性，也可以指定为一个递增的整数编号，一般情况下以id作为主键</p>
<pre><code>&#123; id: 1, text: &#39;foo&#39; &#125;
</code></pre>
<p>上面的对象中，id属性可以当作主键。数据体可以是任意数据类型，不限于对象。</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引。</p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>数据记录的读写和删改，都要通过事务完成。事务对象提供error、abort和complete三个事件，用来监听操作结果</p>
<h3 id="打开-新建-数据库"><a href="#打开-新建-数据库" class="headerlink" title="打开(新建)数据库"></a>打开(新建)数据库</h3><p>open方法打开数据库，返回一个 IDBRequest 对象，通过监听error 与 success事件来执行不同的操作，后续基本所有相关操作都是通过监听这两个方法来执行的。  </p>
<p>新建数据库与打开数据库是同一个操作。如果指定的数据库不存在，就会新建。不同之处在于，后续的操作主要在upgradeneeded事件的监听函数里面完成，因为这时版本从无到有（或版本号更新时），会触发这个事件。  </p>
<p>而一般新建数据库之后的第一件事是新建对象仓库（即新建表），因为后续的所有操作都是围绕这对象仓库来进行的，所以代码封装如下：</p>
<pre><code>const indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;//兼容写法

const openDB(myDB)=&gt; &#123;
    //建立或打开数据库，建立对象存储空间(ObjectStore)
      var request = indexedDB.open(myDB.name, myDB.version || 1);
        request.onerror = (e)=&gt; &#123;
          console.log(&quot;数据库打开失败&quot;);
        &#125;
        request.onsuccess=()=&gt; &#123;
          myDB.db=request.result;
          console.log(&#39;数据库打开成功&#39;);
        &#125;;
        request.onupgradeneeded = (event)=&gt; &#123;
          myDB.db=event.target.result;
          console.log(&#39;数据库更新成功&#39;);
          var objectStore;
          //判断表是否存在，不存在则新建
          if (!myDB.db.objectStoreNames.contains(myDB.table.name)) &#123;
            objectStore = myDB.db.createObjectStore(myDB.table.name, &#123; keyPath:myDB.table.keyPath &#125;);
            //指定id为主键，默认从主键进行搜索
            //此处也可以创建其他索引，详见3.5
          &#125;
    &#125;;
    
&#125;,
</code></pre>
<h3 id="数据的增删改查"><a href="#数据的增删改查" class="headerlink" title="数据的增删改查"></a>数据的增删改查</h3><p>仓库对象创建后，我们就可以执行增删改查操作了，代码封装如下（promise写法）：</p>
<pre><code>const indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;
export default &#123;
      indexedDB:indexedDB?indexedDB:null,
      openDB(myDB) &#123;
        //建立或打开数据库，建立对象存储空间(ObjectStore)
        return new Promise((resolve,reject)=&gt;&#123;
          var request = this.indexedDB.open(myDB.name, myDB.version || 1);
            request.onerror = (e)=&gt; &#123;
              console.log(&quot;数据库打开失败&quot;);
              reject(e)
            &#125;
            request.onsuccess=()=&gt; &#123;
              myDB.db=request.result;
              resolve(request.result);
              console.log(&#39;数据库打开成功&#39;);
            &#125;;
            request.onupgradeneeded = (event)=&gt; &#123;
              myDB.db=event.target.result;
              console.log(&#39;数据库更新成功&#39;);
              resolve(myDB.db);
              var objectStore;
              if (!myDB.db.objectStoreNames.contains(myDB.table.name)) &#123;
                objectStore = myDB.db.createObjectStore(myDB.table.name, &#123; keyPath:myDB.table.keyPath &#125;);
              &#125;
        &#125;;
        &#125;)
        
    &#125;,
    //添加数据
    addData(myDB, data) &#123;
      return new Promise((resolve,reject)=&gt;&#123;
      const request = myDB.db.transaction([myDB.table.name], &#39;readwrite&#39;).objectStore(myDB.table.name).add(data);

      request.onsuccess = (event)=&gt; &#123;
        console.log(&#39;数据写入成功&#39;);
        resolve(event)
      &#125;;

      request.onerror = (event) =&gt;&#123;
        console.log(&#39;数据写入失败&#39;);
        reject(event)
      &#125;
      &#125;)
      
    &#125;,
    //更新数据
    putData(myDB, data) &#123;
      return new Promise((resolve,reject)=&gt;&#123;
        const request = myDB.db.transaction([myDB.table.name], &#39;readwrite&#39;).objectStore(myDB.table.name).put(data);
        request.onsuccess = (event)=&gt; &#123;
          console.log(&#39;数据更新成功&#39;);
          resolve(event)
        &#125;;

        request.onerror = (event) =&gt;&#123;
          console.log(&#39;数据更新失败&#39;);
          reject(event)
      &#125;
      &#125;)
      
    &#125;,
    //读取数据
    getData(myDB, keyPath) &#123;
      return new Promise((resolve,reject)=&gt;&#123;
        const transaction = myDB.db.transaction([myDB.table.name]);
        const objectStore = transaction.objectStore(myDB.table.name);
        const request = objectStore.get(keyPath || myDB.table.keyPath);
        request.onerror = (event)=&gt; &#123;
          console.log(&#39;数据读取失败&#39;);
          reject(event)
        &#125;;
        request.onsuccess = (event)=&gt; &#123;
          console.log(&quot;数据读取成功&quot;)
          resolve(request.result)
        &#125;;
      &#125;)
    &#125;,
    //删除数据
    deleteData(myDB, keyPath) &#123;
      return new Promise((resolve,reject)=&gt;&#123;
        const request=myDB.db.transaction(myDB.table.name, &#39;readwrite&#39;).objectStore(myDB.table.name).delete(keyPath || myDB.table.keyPath);
        request.onerror = (event)=&gt; &#123;
          console.log(&#39;删除数据失败&#39;);
          reject(event)
        &#125;;
        request.onsuccess = (event)=&gt; &#123;
          console.log(&quot;删除数据成功&quot;)
          resolve(event)
        &#125;;
      &#125;)
    &#125;,
    clearData(myDB) &#123;
      //删除指定仓库全部记录
      const request=myDB.db.transaction(myDB.table.name, &#39;readwrite&#39;).objectStore(myDB.table.name).clear(); 
      request.onerror = (event)=&gt; &#123;
        console.log(`删除$&#123;myDB.table.name&#125;仓库失败`);
        reject(event)
      &#125;;
      request.onsuccess = (event)=&gt; &#123;
        console.log(`删除$&#123;myDB.table.name&#125;仓库成功`)
        resolve(event)
      &#125;;
    &#125;
  &#125;
</code></pre>
<p><img src="2.png"></p>
<h3 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h3><p>索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）。  </p>
<p>假定新建表格的时候，对name字段建立了索引(必须在创建的时候就添加，否则无效)。  </p>
<pre><code>objectStore.createIndex(&#39;name&#39;, &#39;name&#39;, &#123; unique: false &#125;);
</code></pre>
<p>此时，在表打开之后，我们可以通过搜索name来检索数据</p>
<pre><code>this.$db.openDB(this.myDB).then((res)=&gt;&#123;
    const transaction = this.myDB.db.transaction([this.myDB.table.name]);
    const objectStore = transaction.objectStore(this.myDB.table.name);
    const index=objectStore.index(&#39;name&#39;);
    const request = index.get(&quot;Leo&quot;);
    request.onsuccess = (event)=&gt; &#123;
      console.log(&#39;数据读取成功&#39;);
      console.log(event.target.result)
    &#125;;

    request.onerror = (event) =&gt;&#123;
      console.log(&#39;数据读取失败&#39;);
    &#125;
 &#125;)
</code></pre>
<p>结果为：</p>
<pre><code> &#123;
    id: 1
    name: &quot;Leo&quot;
    timstap: 1568279789287
 &#125;
</code></pre>
<h3 id="遍历仓库"><a href="#遍历仓库" class="headerlink" title="遍历仓库"></a>遍历仓库</h3><p>indexedDB2规范中,在对象存储空间对象上纳入了一个getAll()，但早期规范中需要使用openCursor指针来获取目标仓库下所有的数据列表（数组）</p>
<pre><code>    //遍历指定仓库所有对象
    getAllData(myDB) &#123;
    
      return new Promise((resolve,reject)=&gt;&#123;
        const objectStore = myDB.db.transaction(myDB.table.name, &#39;readwrite&#39;).objectStore(myDB.table.name);
        // indexedDB2规范中,在对象存储空间对象上纳入了一个getAll()
        if(objectStore.getAll)&#123;
          objectStore.getAll().onsuccess = (event)=&gt; &#123;
            console.log(&quot;获取所有数据成功1&quot;)
            resolve(event.target.result)
          &#125;
        &#125;else&#123;
          objectStore.openCursor().onsuccess = (event)=&gt; &#123;
              console.log(&quot;获取所有数据成功2&quot;)
              resolve(event.target.result)
          &#125;
        &#125;
      &#125;)
    &#125;,
</code></pre>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>indexedDB数据库的相关api并不复杂，本文只是简单介绍了一些常规用法，更深层次的使用需要继续深入研究，最后附上indexedDB在各个浏览器上的实现程度：</p>
<p><img src="3.png"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="http://www.ruanyifeng.com/blog/2018/07/indexeddb.html">阮一峰 浏览器数据库 IndexedDB 入门教程</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">MDN IndexedDB</a></li>
<li><a href="https://blog.csdn.net/weixin_42779950/article/details/81989105">基于vue的localStorage 与indexDB的基本封装</a></li>
<li><a href="https://www.cnblogs.com/dengyulinBlog/p/6141636.html">前端存储之indexedDB</a></li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染页面过程解析</title>
    <url>/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一个老生常谈的问题，也是我们每天都在遇到的事情，我们从输入网址，到页面最终展示，中间到底经历了多少个流程？大致流程是：URL 解析 -&gt; DNS 查询 -&gt; TCP 连接 -&gt; 处理请求 -&gt; 接受响应 -&gt; 渲染页面</p>
<p>这里只讨论一个环节：浏览器的渲染流程</p>
<span id="more"></span>

<h2 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h2><p>先放一张webkit 内核渲染流程：</p>
<p><img src="./1.png"></p>
<p>大体流程就是：  </p>
<p>解析html生成DOM树 -&gt; 解析css生成css规则 -&gt; DOM树+CSS规则生成渲染树（render tree） -&gt;  布局render tree -&gt; 绘制 render tree -&gt;  GPU会将各层合成，显示在屏幕上</p>
<h3 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h3><p>当浏览器接收到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。</p>
<ul>
<li>DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞</li>
<li>display:none的元素也会在DOM树中</li>
<li>注释也会在DOM树中</li>
<li>script标签会在DOM树中</li>
</ul>
<h3 id="构建CSSOM规则树"><a href="#构建CSSOM规则树" class="headerlink" title="构建CSSOM规则树"></a>构建CSSOM规则树</h3><p>浏览器解析CSS文件并生成CSSOM，每个CSS文件都被分析成一个StyleSheet对象，每个对象都包含CSS规则。CSS规则对象包含对应于CSS语法的选择器和声明对象以及其他对象。</p>
<ul>
<li>CSS解析可以与DOM解析同时进行。</li>
<li>CSS解析与script的执行互斥 。</li>
</ul>
<h3 id="构建渲染树（Render-Tree）"><a href="#构建渲染树（Render-Tree）" class="headerlink" title="构建渲染树（Render Tree）"></a>构建渲染树（Render Tree）</h3><p>通过DOM树和CSS规则树，浏览器就可以通过它两构建渲染树了。浏览器会先从DOM树的根节点开始遍历每个可见节点，然后对每个可见节点找到适配的CSS样式规则并应用。</p>
<ul>
<li>Render Tree和DOM Tree不完全对应</li>
<li>display: none的元素不在Render Tree中</li>
<li>visibility: hidden的元素在Render Tree中</li>
</ul>
<h3 id="渲染树布局-layout-of-the-render-tree"><a href="#渲染树布局-layout-of-the-render-tree" class="headerlink" title="渲染树布局(layout of the render tree)"></a>渲染树布局(layout of the render tree)</h3><p>布局阶段会从渲染树的根节点开始遍历，由于渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置。</p>
<ul>
<li>float元素，absoulte元素，fixed元素会发生位置偏移。</li>
<li>常说的脱离文档流，其实就是脱离Render Tree。</li>
<li>新的 CSS 标准中，规定了 will-change 属性，可以大大提升合成策略的效果</li>
</ul>
<h3 id="渲染树绘制（Painting-the-render-tree）"><a href="#渲染树绘制（Painting-the-render-tree）" class="headerlink" title="渲染树绘制（Painting the render tree）"></a>渲染树绘制（Painting the render tree）</h3><p>在绘制阶段，浏览器会遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。不过，一般来说，浏览器并不需要用代码来处理这个过程，浏览器只需要把最终要显示的位图交给操作系统即可。</p>
<h2 id="渲染中遇到的其他事儿"><a href="#渲染中遇到的其他事儿" class="headerlink" title="渲染中遇到的其他事儿"></a>渲染中遇到的其他事儿</h2><h3 id="渲染阻塞"><a href="#渲染阻塞" class="headerlink" title="渲染阻塞"></a>渲染阻塞</h3><p>JS可以操作DOM来修改DOM结构，可以操作CSSOM来修改节点样式，这就导致了浏览器在遇到<code>&lt;script&gt;</code>标签时，DOM构建将暂停，直至脚本完成执行(src属性的话需要等待下载且执行完毕)，然后继续构建DOM。JS也可以阻塞其后的构建CSSOM规则树，整个解析进程必须等待JS的执行完成才能够继续。<br>对于如下html页面</p>
<pre><code>  &lt;!DOCTYPE html&gt;
  &lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script src=&quot;https://www.google.com/test.js&quot;&gt;&lt;/script&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;./common.css&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h2&gt;我是测试&lt;/h2&gt;
  &lt;/body&gt;
  
</code></pre>
<p>加载流程是这样的：</p>
<p><img src="./2.png"></p>
<p>JS阻塞了DOM构建（进入即为白屏）和css规则的生成（css可以正常下载，但不会执行），整个页面必须等待test.js执行完毕后才可以继续执行，所以script标签在页面中的位置很重要。</p>
<h3 id="回流（reflow）"><a href="#回流（reflow）" class="headerlink" title="回流（reflow）"></a>回流（reflow）</h3><p>当浏览器发现布局发生了变化，这个时候就需要倒回去重新渲染，这个回退的过程叫reflow。reflow几乎是无法避免的，因为只要用户进行交互操作，就势必会发生页面的一部分的重新渲染，且通常我们也无法预估浏览器到底会reflow哪一部分的代码，因为他们会相互影响。</p>
<p>现代浏览器会对回流做优化，它会等到足够数量的变化发生，再做一次批处理回流。</p>
<ul>
<li>页面第一次渲染（初始化）</li>
<li>DOM树变化（如：增删节点）</li>
<li>Render树变化（如：padding改变）</li>
<li>浏览器窗口resize</li>
<li>获取元素的某些属性</li>
</ul>
<h3 id="重绘（repaint）"><a href="#重绘（repaint）" class="headerlink" title="重绘（repaint）"></a>重绘（repaint）</h3><p>repaint则是当我们改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸和位置没有发生改变。</p>
<ul>
<li>display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发生位置变化。</li>
<li>reflow必定引起repaint，repain可以单独触发。</li>
</ul>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul>
<li>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li>
<li>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li>
</ul>
<p>而我们的浏览器是多进程的，打开chrome的任务管理器</p>
<p><img src="./3.png"></p>
<p>主要包含以下进程：</p>
<ul>
<li>Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有：浏览器界面显示，页面的管理，資源下載等等</li>
<li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li>
<li>GPU进程：最多一个，用于3D绘制等</li>
<li>浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为页面渲染，脚本执行，事件处理等</li>
</ul>
<p>前端的js,css和html等都是在浏览器的渲染进程中执行的，每个渲染进程中，大致包含以下线程:</p>
<ul>
<li>GUI渲染线程:负责解析渲染页面，上面提到的内核渲染流程就是在GUI线程中执行的</li>
<li>JS引擎线程：负责处理js脚本的线程，并且<strong>GUI渲染线程与JS引擎线程是互斥的</strong></li>
<li>事件触发线程：归属浏览器的渲染进程，并不在js引擎中。</li>
<li>定时触发器线程：setInterval与setTimeout所在线程。</li>
<li>异步http请求线程：XMLHttpRequest在连接后是通过浏览器新开一个线程请求，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行</li>
</ul>
<h2 id="浏览器中的Event-Loop"><a href="#浏览器中的Event-Loop" class="headerlink" title="浏览器中的Event Loop"></a>浏览器中的Event Loop</h2><p>JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变，js中所有的任务可以分为两种：一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</p>
<p><img src="./4.png"></p>
<p>任务队列的执行机制如下：</p>
<ul>
<li><p>所有同步任务都在主线程上执行，形成一个执行栈（stack）。</p>
</li>
<li><p>主线程之外，还存在一个”任务队列”（queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</p>
</li>
<li><p>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p>
</li>
</ul>
<p>主线程不断重复上面的第三步，这也被称为Event Loop。上面提到的事件触发线程,定时触发器线程和异步http请求线程都是来处理生成“任务队列”的</p>
<p>更多请访问之前的博文：<a href="https://weblog.wangminghuan.cn/Nodejs%E7%B3%BB%E5%88%97-2-EventLoop/">Nodejs系列-2-EventLoop</a></p>
<h2 id="Performance-工具"><a href="#Performance-工具" class="headerlink" title="Performance 工具"></a>Performance 工具</h2><p>为了更好理解浏览器渲染页面的过程，我们通过chrome浏览器的Performance工具来详解查看整个渲染过程：点刷新按钮重载页面并记录事件，得到如下报告。</p>
<p><img src="./5.png"></p>
<pre><code>蓝色(Loading)：网络通信和HTML解析
黄色(Scripting)：JavaScript执行
紫色(Rendering)：样式计算和布局，即重排
绿色(Painting)：重绘
灰色(other)：其它事件花费的时间
白色(Idle)：空闲时间（是一次timeline中的无实际捕获时间，并非白屏时间）
</code></pre>
<h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><p>Network选项中有不同颜色的请求，它们分别代表的是蓝色-HTML、黄色-JS、紫色-css文件、绿色-图片的资源请求，可以看到他们触发加载的时间顺序</p>
<h3 id="Event-log"><a href="#Event-log" class="headerlink" title="Event log"></a>Event log</h3><p><img src="./6.png"></p>
<p>Event log 记录了整个加载过程中所有的事件触发记录，包括在send requerst请求Html之前，会触发浏览器一系列默认事件行为：webkitvisibilitychange,unloadEventStart,unloadEventEnd等等。</p>
<p>可以看到渲染页面（截图只有一部分）在Paint 与 Rendering 之间来回执行，中间还穿插着<code>Evaluate Script</code>与<code>Parse Stylesheet</code>,整个过程基本遵循着内核渲染流程图。</p>
<p>HTML 页面的生命周期包含三个重要事件：</p>
<ul>
<li>DOMContentLoaded —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像图片和样式表之类的外部资源可能尚未加载完成。</li>
<li>load —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。</li>
<li>beforeunload/unload —— 当用户正在离开页面时（Event Log最顶部）。</li>
</ul>
<p><img src="./8.png"></p>
<p>各部分执行时间如下（从高到低）：</p>
<p><img src="./7.png"></p>
<p>Performance 工具非常强大，本文只是大概观察了下页面的渲染过程，如果要做优化，这里将会为你提供很多优化的依据与目标</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jianshu.com/p/e6252dc9be32">浏览器渲染原理与过程</a></li>
<li><a href="https://www.cnblogs.com/cangqinglang/p/8963557.html">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></li>
<li><a href="https://mp.weixin.qq.com/s/Y_iNtM2TdvilRY6NN1Ag9g">大转转FE-前端隐秘角落 - 页面渲染</a></li>
<li><a href="https://www.cnblogs.com/zjjing/p/9106111.html">chrome-performance页面性能分析使用教程</a></li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>私有npm仓库搭建</title>
    <url>/%E7%A7%81%E6%9C%89npm%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>2020年第一篇博客，我们来探索下私有npm仓库的搭建~</p>
<p>在开发中经常会遇到一些公共的组件调用，将代码抽离成模块后，想通过npm进行管理，但很多时候这些代码是包含业务相关功能的，是不能对外发布的，这个时候就亟需搭建一个私有npm仓库来进行存放。</p>
<p>查阅资料可以发现，类似的开源库基本有以下两种： cnpm 和 sinopia(verdaccio)。本文选用的为verdaccio，它是sinopia的fork版本（sinopia2015年已经停止更新），不同于cnpm的繁琐，verdaccio基本是属于傻瓜式的操作。那么废话不多，开始搭建。</p>
<span id="more"></span>

<h2 id="verdaccio-安装"><a href="#verdaccio-安装" class="headerlink" title="verdaccio 安装"></a>verdaccio 安装</h2><p>以下所有操作是基于 <code>CentOS Linux release 7.6.1810</code> 进行的。</p>
<p>全局安装verdaccio模块</p>
<pre><code>npm install -global verdaccio 
</code></pre>
<p>如果出现报错，请使用：</p>
<pre><code>npm install -global verdaccio --unsafe-perm
</code></pre>
<p>运行verdaccio命令（如果提示verdaccio命令不存在请先进行软连配置）</p>
<pre><code>verdaccio
</code></pre>
<p>运行结果：</p>
<pre><code>warn --- config file  - /root/.config/verdaccio/config.yaml
warn --- Verdaccio started
warn --- Plugin successfully loaded: verdaccio-htpasswd
warn --- Plugin successfully loaded: verdaccio-audit
warn --- http address - http://localhost:4873/ - verdaccio/4.4.2
</code></pre>
<p>但此时对应的端口号开启也是无法访问的，需要再进行一下配置：</p>
<p>配置文件从运行结果可以看出，位于<code>/root/.config/verdaccio/config.yaml</code></p>
<p>最底部添加监听端口：</p>
<pre><code>listen: 0.0.0.0:3004
</code></pre>
<p>再进行访问：</p>
<p><img src="1.png"></p>
<p>ok, 安装完毕，我们开始配置（ps:如需常驻进程请用pm2 进行启动）</p>
<h2 id="verdaccio-配置"><a href="#verdaccio-配置" class="headerlink" title="verdaccio 配置"></a>verdaccio 配置</h2><p>首先我们对verdaccio进行配置修改，配置文件位于<code>/root/.config/verdaccio/config.yaml</code></p>
<h3 id="web-UI-部分"><a href="#web-UI-部分" class="headerlink" title="web UI 部分"></a>web UI 部分</h3><p>webUI部分,具体可参照<a href="https://verdaccio.org/docs/en/webui">UI配置文档</a></p>
<pre><code>web:
  title: npm | packages and modules
  primary_color: &quot;#353535&quot;
  # comment out to disable gravatar support
  # gravatar: false
  # by default packages are ordercer ascendant (asc|desc)
  # sort_packages: asc
  # logo: http://my/logopath/logo.png
  # scope: &quot;@myscope&quot;
</code></pre>
<p>整个UI是基于react进行开发的，UI源码位于:<code>/usr/local/src/node/lib/node_modules/verdaccio/node_modules/@verdaccio/ui-theme/static</code>下。</p>
<h3 id="权限部分"><a href="#权限部分" class="headerlink" title="权限部分"></a>权限部分</h3><p>我们配置的是所有人可以访问web站点，但是发布与拉取需要指定用户才可以访问(多个用户空格隔开)：</p>
<pre><code>packages:
  &#39;**&#39;:
    # allow all users (including non-authenticated users) to read and
    # publish all packages
    #
    # you can specify usernames/groupnames (depending on your auth plugin)
    # and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot;
    access: $all
    # allow all known users to publish/publish packages
    # (anyone can register by default, remember?)
    publish: wmh wmh1
    unpublish: wmh wmh1
</code></pre>
<h2 id="私有仓库的使用"><a href="#私有仓库的使用" class="headerlink" title="私有仓库的使用"></a>私有仓库的使用</h2><p>verdaccio支持代理转发，通过uplinks配置可以将不存在私有仓库的包转发到指定仓库进行拉取：</p>
<pre><code>uplinks:
  npmjs:
    url: https://registry.npm.taobao.org/
</code></pre>
<p>但这样，我觉得不适用公司现在的模式，于是就想到了模块的命名空间设置:</p>
<p>在本地进行如下操作：</p>
<ol>
<li><p>将私有模块关联到指定仓库</p>
<pre><code> npm config set @myscope:registry http://xx.xxx.xxx:3004
</code></pre>
</li>
<li><p>向指定仓库注册账号</p>
<pre><code> npm adduser --registry=http://xx.xxx.xxx:3004
</code></pre>
</li>
</ol>
<p>此时，我们就完成了将@myscope命名空间下的插件全部设置到我们的私有仓库，其他模块仓库地址不变</p>
<p>除此外，还有其他操作指令:</p>
<p>登录指定仓库</p>
<pre><code>npm login --registry=http://xx.xxx.xxx:3004
</code></pre>
<p>查看指定仓库当前用户名</p>
<pre><code>npm whoami --registry=http://xx.xxx.xxx:3004
</code></pre>
<p>退出指定仓库</p>
<pre><code>npm logout --registry=http://xx.xxx.xxx:3004
</code></pre>
<h2 id="私有模块发布"><a href="#私有模块发布" class="headerlink" title="私有模块发布"></a>私有模块发布</h2><p>通过一下执行发布指定命名空间下的私有模块</p>
<pre><code>npm init --scope=@myscope
</code></pre>
<p>index.js内容如下：</p>
<pre><code>(function (global, factory) &#123;
typeof exports === &#39;object&#39; &amp;&amp; typeof module !== &#39;undefined&#39; ? module.exports = factory() :
typeof define === &#39;function&#39; &amp;&amp; define.amd ? define(factory) : (global.randomNumber = factory());

&#125;)(this, function () &#123;
  function randomNumber (min, max) &#123;
    return min + Math.round(Math.random()*(max-min));
&#125;
  return randomNumber
&#125;)
</code></pre>
<p>再运行指令：</p>
<p>   npm publish </p>
<p>这样便发布完成了</p>
<p><img src="2.png"></p>
<p>安装与使用跟正常模块无异：</p>
<pre><code>npm install @myscope/utils
</code></pre>
<p>或</p>
<pre><code>yarn add @myscope/utils
</code></pre>
<h2 id="新增权限用户"><a href="#新增权限用户" class="headerlink" title="新增权限用户"></a>新增权限用户</h2><p>如果需要新增用户，用户通过 npm addUser 指令添加注册用户后： </p>
<ol>
<li><p><code>/root/.config/verdaccio/htpasswd</code> 文件会出现注册用户名单；  </p>
</li>
<li><p>编辑 <code>/root/.config/verdaccio/config.yaml</code> 文件添加对应用户与对应权限</p>
</li>
<li><p>重启verdaccio服务（切记~）</p>
</li>
</ol>
<p>PS: 密码是通过htpasswd方式进行管理的，所以常规手段是无法重置与找回密码的，如果无法登录，只能重新添加一个用户了~</p>
<h2 id="关于-htpasswd"><a href="#关于-htpasswd" class="headerlink" title="关于 htpasswd"></a>关于 htpasswd</h2><p>htpasswd 是开源 http 服务器 apache httpd 的一个命令工具，用于生成 http 基本认证的密码文件,每行内容格式为“用户名:密码”，</p>
<p>用于用户文件的基本身份认证。默认采用MD5加密方式.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://verdaccio.org/">verdaccio 官网</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/86949640">前端-团队效率（四）私有npm仓库</a></li>
<li><a href="https://www.jianshu.com/p/0c905e4a8b70">使用verdaccio 搭建私有npm 服务器</a></li>
</ul>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>verdaccio</tag>
      </tags>
  </entry>
  <entry>
    <title>详谈Object.defineProperty</title>
    <url>/%E8%AF%A6%E8%B0%88Object.defineProperty/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Object.defineProperty()的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性，并返回这个对象。</p>
<span id="more"></span>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre><code>Object.defineProperty(obj,prop,descriptor)
</code></pre>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>obj 需要定义属性的对象。</li>
<li>prop 需定义或修改的属性的名字。</li>
<li>descriptor 将被定义或修改的属性的描述符。</li>
</ul>
<h2 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h2><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">configurable</td>
<td align="left">false</td>
<td align="left">描述属性是否可以被删除，默认为 false ; 具备 数据描述符 和 存取描述符</td>
</tr>
<tr>
<td align="left">enumerable</td>
<td align="left">false</td>
<td align="left">描述属性是否可以被for…in或Object.keys枚举，默认为 false ; 具备 数据描述符 和 存取描述符</td>
</tr>
<tr>
<td align="left">writable</td>
<td align="left">false</td>
<td align="left">描述属性是否可以修改，默认为 false ; 具备 数据描述符</td>
</tr>
<tr>
<td align="left">value</td>
<td align="left">undefined</td>
<td align="left">属性值，默认为undefined ; 具备 数据描述符</td>
</tr>
<tr>
<td align="left">get</td>
<td align="left">undefined</td>
<td align="left">当访问属性时触发该方法，默认为undefined ; 具备 存取描述符</td>
</tr>
<tr>
<td align="left">set</td>
<td align="left">undefined</td>
<td align="left">当属性被修改时触发该方法，默认为undefined; 具备 存取描述符</td>
</tr>
</tbody></table>
<p>js对象中属性描述符号有两种形式： 数据描述符和存取描述符：</p>
<h3 id="数据描述符"><a href="#数据描述符" class="headerlink" title="数据描述符"></a>数据描述符</h3><p>拥有可写或不可写值的属性，可选键值如下：</p>
<ul>
<li>configurable</li>
<li>enumerable</li>
<li>writable</li>
<li>value</li>
</ul>
<p>举个例子：</p>
<pre><code>  var a=&#123;&#125;;
    Object.defineProperty(a, &quot;b&quot;, &#123;
      configurable: false, // 不可删除
      enumerable: false,// 不可通过for in 枚举
      writable: false, // 不可通过等号赋值改写
      value: 8  //属性值
    &#125;)
    console.log(a.b);//8
    console.log(Object.keys(a));// []
    a.b=1; //报错  Uncaught TypeError: Cannot assign to read only property &#39;b&#39; of object &#39;#&lt;Object&gt;&#39;
    delete a.b //报错 Uncaught TypeError: Cannot delete property &#39;b&#39; of #&lt;Object&gt;
</code></pre>
<h3 id="存取描述符"><a href="#存取描述符" class="headerlink" title="存取描述符"></a>存取描述符</h3><p>由一对getter-setter函数功能来描述的属性，可选键值如下：</p>
<ul>
<li>configurable</li>
<li>enumerable</li>
<li>get</li>
<li>set</li>
</ul>
<p>举个例子：</p>
<pre><code>  var b=&#123;&#125;,val=&#39;7&#39;;
  Object.defineProperty(b, &quot;a&quot;, &#123;
    configurable: false, // 不可删除
    enumerable: false,// 不可通过for in 枚举
    get: function () &#123;
      return val
    &#125;,
    set: function (newVal) &#123;
      val = newVal
    &#125;
  &#125;)
  console.log(b.a);// 7
  console.log(Object.keys(b));//[]
  b.a=1;
  console.log(b.a);// 1
  delete b.a ;//报错 Uncaught TypeError: Cannot delete property &#39;a&#39; of #&lt;Object&gt;
</code></pre>
<p>因为JS的数据描述符和存取描述符只能选取一种规则，所以在 descriptor 中 如果设置了 set 或 get, 就不能设置 writable 和 value 中的任何一个，否则报如下错误：</p>
<pre><code>    Uncaught TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute, #&lt;Object&gt; at Function.defineProperty 
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - CSS部分-@规则</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-CSS%E9%83%A8%E5%88%86-@%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h2 id="css-规则"><a href="#css-规则" class="headerlink" title="css 规则"></a>css 规则</h2><p>CSS 的顶层样式表由两种规则组成的规则列表构成，一种被称为 at-rule，也就是 at 规则，另一种是 qualified rule，也就是普通规则。</p>
<span id="more"></span>
<h2 id="at-rule"><a href="#at-rule" class="headerlink" title="at-rule"></a>at-rule</h2><p>at-rule 由一个 @ 关键字和后续的一个区块组成，如果没有区块，则以分号结束。这些 at-rule 在开发中使用机会远远小于普通的规则，所以它的大部分内容，你可能会感觉很陌生。但是at 规则又是掌握 CSS 的一些高级特性所必须的内容。</p>
<h3 id="charset"><a href="#charset" class="headerlink" title="@charset"></a>@charset</h3><p>@charset 用于提示 CSS 文件使用的字符编码方式，它如果被使用，必须出现在最前面。这个规则只在给出语法解析阶段前使用，并不影响页面上的展示效果。</p>
<pre><code>@charset &quot;utf-8&quot;;
</code></pre>
<h3 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h3><p>@import 用于引入一个 CSS 文件，除了 @charset 规则不会被引入，@import 可以引入另一个文件的全部内容。</p>
<pre><code>@import &quot;mystyle.css&quot;;
@import url(&quot;mystyle.css&quot;);
</code></pre>
<h3 id="media"><a href="#media" class="headerlink" title="@media"></a>@media</h3><p>media 就是大名鼎鼎的 media query 使用的规则了，它能够对设备的类型进行一些判断。在 media 的区块内，是普通规则列表。</p>
<pre><code>@media print &#123;
    body &#123; font-size: 10pt &#125;
&#125;
</code></pre>
<h3 id="page"><a href="#page" class="headerlink" title="@page"></a>@page</h3><p>@page 规则用于在打印文档时修改某些CSS属性。页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。</p>
<pre><code>@page:first&#123;margin:100px;&#125;
</code></pre>
<h3 id="counter-style"><a href="#counter-style" class="headerlink" title="@counter-style"></a>@counter-style</h3><p>counter-style 产生一种数据，用于定义列表项的表现。</p>
<p>  @counter-style triangle {<br>    system: cyclic;<br>    symbols: ‣;<br>    suffix: “ “;<br>  }</p>
<h3 id="key-frames"><a href="#key-frames" class="headerlink" title="@key-frames"></a>@key-frames</h3><p>keyframes 产生一种数据，用于定义动画关键帧。</p>
<pre><code>@keyframes diagonal-slide &#123;

  from &#123;
    left: 0;
    top: 0;
  &#125;

  to &#123;
    left: 100px;
    top: 100px;
  &#125;

&#125;
</code></pre>
<h3 id="fontface"><a href="#fontface" class="headerlink" title="@fontface"></a>@fontface</h3><p>fontface 用于定义一种字体，icon font 技术就是利用这个特性来实现的。</p>
<pre><code>@font-face &#123;
  font-family: Gentium;
  src: url(http://example.com/fonts/Gentium.woff);
&#125;

p &#123; font-family: Gentium, serif; &#125;
</code></pre>
<p>PS: 关于字体文件，因为没有一个字体格式可以支持所有浏览器，常见做法是加载先加载woff（压缩率较高），不支持的话加载备用tff格式。且字体加载存在跨域情况，或利用webpack将字体直接转成base64。</p>
<h3 id="support"><a href="#support" class="headerlink" title="@support"></a>@support</h3><p>support 检查环境的特性，它与 media 比较类似。</p>
<h3 id="namespace"><a href="#namespace" class="headerlink" title="@namespace"></a>@namespace</h3><p>用于跟 XML 命名空间配合的一个规则，表示内部的 CSS 选择器全都带上特定命名空间。</p>
<h3 id="viewport"><a href="#viewport" class="headerlink" title="@viewport"></a>@viewport</h3><p>用于设置视口的一些特性，不过兼容性目前不是很好，多数时候被 html 的 meta 代替。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>除了以上这些，还有些目前不太推荐使用的 at 规则。</p>
<ol>
<li>@color-profile 是 SVG1.0 引入的 CSS 特性，但是实现状况不怎么好。</li>
<li>@document 还没讨论清楚，被推迟到了 CSS4 中。</li>
<li>@font-feature-values</li>
</ol>
<h2 id="普通规则"><a href="#普通规则" class="headerlink" title="普通规则"></a>普通规则</h2><p>普通主要是由选择器和声明区块构成。声明区块又由属性和值构成：</p>
<ul>
<li>选择器</li>
<li>声明列表</li>
<li>属性</li>
<li>值<ul>
<li>值的类型</li>
<li>函数</li>
</ul>
</li>
</ul>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ul>
<li>complex-selector（复合选择器）<ul>
<li>combinator(组合器)<ul>
<li>空格</li>
<li><blockquote>
</blockquote>
</li>
<li>+</li>
<li>~</li>
<li>||</li>
</ul>
</li>
<li>compound-selector(复合选择器) <ul>
<li>type-selector(类型选择器)</li>
<li>subclass-selector（子类选择器）<ul>
<li>id</li>
<li>class</li>
<li>attribute</li>
<li>pseudo-class(伪类)</li>
</ul>
</li>
<li>pseudo-element(伪元素)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/5-1.png"></p>
<h3 id="知识点补充：css组合器"><a href="#知识点补充：css组合器" class="headerlink" title="知识点补充：css组合器"></a>知识点补充：css组合器</h3><ol>
<li><p>空格，后代选择器，选中它的子节点和所有子节点的后代节点。</p>
<pre><code> div p&#123;
   color: red;
 &#125;
 &lt;div&gt;
 &lt;p&gt;我是红色&lt;/p&gt;
 &lt;p&gt;我是红色&lt;/p&gt;
 &lt;section&gt;&lt;p&gt;我也是红色&lt;/p&gt;&lt;/section&gt;
 &lt;/div&gt;
</code></pre>
</li>
<li><p>&gt; ,子代选择器，选中它的子节点，只选中符合条件的子节点，不包含后代节点</p>
<pre><code> div &gt; p&#123;
   color: red;
 &#125;
 &lt;div&gt;
 &lt;p&gt;我是红色&lt;/p&gt;
 &lt;p&gt;我是红色&lt;/p&gt;
 &lt;section&gt;&lt;p&gt;我不是&lt;/p&gt;&lt;/section&gt;
 &lt;/div&gt;
</code></pre>
</li>
<li><p>+ ,直接后继选择器，选中它的下一个相邻节点。</p>
<pre><code> div + p&#123;
   color: red;
 &#125;

   div&gt;
     &lt;p&gt;我不是&lt;/p&gt;
     &lt;p&gt;我不是&lt;/p&gt;
     &lt;section&gt;&lt;p&gt;我不是&lt;/p&gt;&lt;/section&gt;
   &lt;/div&gt;
   &lt;p&gt;我是红色&lt;/p&gt;
   &lt;p&gt;我不是&lt;/p&gt;
   &lt;section&gt;&lt;p&gt;我不是&lt;/p&gt;&lt;/section&gt;
</code></pre>
</li>
<li><p>~ ,后继选择器，选中它之后所有的相邻节点。</p>
</li>
</ol>
<pre><code>    div ~ p&#123;
      color: red;
    &#125;
      &lt;div&gt;
        &lt;p&gt;我不是&lt;/p&gt;
        &lt;p&gt;我不是&lt;/p&gt;
        &lt;section&gt;&lt;p&gt;我不是&lt;/p&gt;&lt;/section&gt;
      &lt;/div&gt;
      &lt;p&gt;我是红色&lt;/p&gt;
      &lt;p&gt;我是红色&lt;/p&gt;
      &lt;section&gt;&lt;p&gt;我不是&lt;/p&gt;&lt;/section&gt;
</code></pre>
<ol start="5">
<li>||：列，选中表格中的一列。不太重要，可以忽略</li>
</ol>
<h3 id="声明：属性和值"><a href="#声明：属性和值" class="headerlink" title="声明：属性和值"></a>声明：属性和值</h3><p>声明部分是一个由“属性: 值”组成的序列：  </p>
<p><strong>属性</strong>是由中划线、下划线、字母等组成的标识符，CSS 还支持使用反斜杠转义。我们需要注意的是：属性不允许使用连续的两个中划线开头，这样的属性会被认为是 CSS 变量。</p>
<pre><code>    //以双中划线开头的属性被当作变量，与之配合的则是 var 函数
    :root &#123;
    --main-color: #06c;
    --accent-color: #006;
    &#125;
    /* The rest of the CSS file */
    #foo h1 &#123;
    color: var(--main-color);
    &#125;
</code></pre>
<p><strong>值</strong>：根据每个 CSS 属性可以取到不同的值，这里的值可能是字符串、标识符。  </p>
<p>CSS 属性值可能是以下类型。</p>
<ol>
<li>CSS 范围的关键字：initial，unset，inherit，任何属性都可以的关键字。</li>
<li>字符串：比如 content 属性。</li>
<li>URL：使用 url() 函数的 URL 值。</li>
<li>整数 / 实数：比如 flex 属性。</li>
<li>维度：单位的整数 / 实数，比如 width 属性。</li>
<li>百分比：大部分维度都支持。</li>
<li>颜色：比如 background-color 属性。</li>
<li>图片：比如 background-image 属性。</li>
<li>2D 位置：比如 background-position 属性。</li>
<li>函数：来自函数的值，比如 transform 属性。</li>
</ol>
<p>CSS 支持一批特定的计算型函数：</p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><pre><code>* filter
    * blur()
    * brightness()
    * contrast()
    * drop-shadow()
    * grayscale()
    * hue_rotate()
    * invert()
    * opacity()
    * saturate()
    * sepia()
* cross-fade()
* element()
* image-set()
* imagefunction()
</code></pre>
<h3 id="图形绘制"><a href="#图形绘制" class="headerlink" title="图形绘制"></a>图形绘制</h3><pre><code>* conic-gradient()
* linear-gradient()
* radial-gradient()
* repeating-linear-gradient()
* repeating-radial-gradient()
* shape()
</code></pre>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><pre><code>* calc()
* clamp()
* fit-content()
* max()
* min()
* minmax()
* repeat()
</code></pre>
<h3 id="变形-动画"><a href="#变形-动画" class="headerlink" title="变形/动画"></a>变形/动画</h3><pre><code>* transform
  * matrix()
  * matrix3d()
  * perspective()
  * rotate()
  * rotate3d()
  * rotateX()
  * rotateY()
  * rotateZ()
  * scale()
  * scale3d()
  * scaleX()
  * scaleY()
  * scaleZ()
  * skew()
  * skewX()
  * skewY()
  * translate()
  * translate3d()
  * translateX()
  * translateY()
  * translateZ()
</code></pre>
<h3 id="环境与元素"><a href="#环境与元素" class="headerlink" title="环境与元素"></a>环境与元素</h3><pre><code>* var()
* env()
* attr()
</code></pre>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - CSS部分-颜色的绘制</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-CSS%E9%83%A8%E5%88%86-CSS%E9%A2%9C%E8%89%B2%E7%9A%84%E7%BB%98%E5%88%B6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最常见的颜色相关的属性就是 color 和 backgroud-color。css中颜色表示有一下几种方式：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>版本</th>
<th>继承性</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>HEX</td>
<td>CSS1</td>
<td>无</td>
<td>CSS颜色值十六进制(HEX)表示,语法如：#rrggbb或#rgb</td>
</tr>
<tr>
<td>RGB</td>
<td>CSS2</td>
<td>无</td>
<td>CSS2 颜色 RGB表示方式</td>
</tr>
<tr>
<td>RGBA</td>
<td>CSS3</td>
<td>无</td>
<td>CSS3 颜色值RGBA表示方式</td>
</tr>
<tr>
<td>HSL</td>
<td>CSS3</td>
<td>无</td>
<td>CSS3 颜色值HSL表示方式</td>
</tr>
<tr>
<td>HSLA</td>
<td>CSS3</td>
<td>无</td>
<td>CSS3 颜色值HSLA表示方式</td>
</tr>
<tr>
<td>Transparent</td>
<td>CSS3</td>
<td>无</td>
<td>CSS3 颜色值透明(Transparent)表示方式(RGBA)</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="RGB-颜色"><a href="#RGB-颜色" class="headerlink" title="RGB 颜色"></a>RGB 颜色</h2><p>我们在计算机中，最常见的颜色表示法是 RGB 颜色，它符合光谱三原色理论：红、绿、蓝三种颜色的光可以构成所有的颜色。 0 - 255 的数字表示每一种颜色，这正好占据了一个字节，每一个颜色就占据三个字节。 </p>
<p>红绿蓝三种颜色的光混合起来就是白光，没有光就是黑暗，所以在 RGB 表示法中，三色数值最大表示白色，三色数值为 0 表示黑色。  </p>
<h2 id="CMYK-颜色"><a href="#CMYK-颜色" class="headerlink" title="CMYK 颜色"></a>CMYK 颜色</h2><p>颜料显示颜色的原理是它吸收了所有别的颜色的光，只反射一种颜色，所以颜料三原色其实是红、绿、蓝的补色，也就是：品红、黄、青。</p>
<p>在印刷行业，使用的就是这样的三原色（品红、黄、青）来调配油墨，这种颜色的表示法叫做 CMYK，它用一个四元组来表示颜色。</p>
<p>为什么它比三原色多了一种？在印刷行业中，黑色颜料价格最低，而品红、黄、青颜料价格较贵，如果要用三原色调配黑色，经济上是不划算的，所以印刷时会单独指定黑色。</p>
<p>对 CMYK 颜色表示法来说，同一种颜色会有多种表示方案，但是我们参考印刷行业的习惯，会尽量优先使用黑色。</p>
<h2 id="HSL-颜色"><a href="#HSL-颜色" class="headerlink" title="HSL 颜色"></a>HSL 颜色</h2><p>HSL颜色模型用一个值来表示人类认知中的颜色，专业的术语叫做色相（H）。加上颜色的纯度（S）和明度（L），就构成了一种颜色的表示。它是一种语义化的颜色。当我们对一张图片改变色相时，人们感知到的是“图片的颜色变了”。相比RGB颜色。</p>
<h2 id="RGBA"><a href="#RGBA" class="headerlink" title="RGBA"></a>RGBA</h2><p>RGBA 是代表 Red（红色）、Green（绿色）、Blue（蓝色）和 Alpha 的色彩空间。RGBA 颜色被用来表示带透明度的颜色，实际上，Alpha 通道类似一种颜色值的保留字。在 CSS 中，Alpha 通道被用于透明度，所以我们的颜色表示被称作 RGBA，而不是 RGBO（Opacity）。</p>
<p>为了方便使用，CSS 还规定了名称型的颜色，它内置了大量（140 种）的颜色名称。不过这里我要挑出两个颜色来讲一讲：金（gold）和银（silver）。</p>
<p>如果你使用过这两个颜色，你会发现，金（gold）和银（silver）的视觉表现跟我们想象中的金色和银色相差甚远。与其被叫做金色和银色，它们看起来更像是难看的暗黄色和浅灰色。</p>
<p>为什么会这样呢？在人类天然的色彩认知中，实际上混杂了很多其它因素，金色和银色不仅仅是一种颜色，它还意味着一定的镜面反光程度，在同样的光照条件下，金属会呈现出更亮的色彩，这并非是用一个色值可以描述的，这就引出了接下来要讲的渐变。</p>
<h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p>在 CSS 中，background-image这样的属性，可以设为渐变。CSS 中支持两种渐变，一种是线性渐变，一种是放射性渐变：</p>
<h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><pre><code>linear-gradient(direction, color-stop1, color-stop2, ...);
</code></pre>
<p>direction 可以是方向，也可以是具体的角度：</p>
<pre><code>to bottom
to top
to left
to right
to bottom left
to bottom right
to top left
to top right
120deg
3.14rad
</code></pre>
<p>color-stop 是一个颜色和一个区段：</p>
<pre><code>rgba(255,0,0,0)
orange
yellow 10%
green 20%
lime 28px
</code></pre>
<h3 id="放射性渐变"><a href="#放射性渐变" class="headerlink" title="放射性渐变"></a>放射性渐变</h3><pre><code>radial-gradient(shape size at position, start-color, ..., last-color);
</code></pre>
<h2 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h2><p>CSS 中的很多属性还会产生形状，比如我们常见的属性：</p>
<pre><code>border
box-shadow
border-radius
</code></pre>
<p>这些产生形状的属性非常有趣，我们也能看到很多利用它们来产生的 CSS 黑魔法。winter建议把它们用于基本的用途，把 border 用于边框、把阴影用于阴影，把圆角用于圆角，所有其它的场景，都有一个更好的替代品：datauri+svg。</p>
<h2 id="补充-svg-作为-dataURI"><a href="#补充-svg-作为-dataURI" class="headerlink" title="补充 svg 作为 dataURI"></a>补充 svg 作为 dataURI</h2><p>举个例子：</p>
<pre><code>&lt;style&gt;
.bg &#123;
  background: url(&quot;data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;30&#39; height=&#39;30&#39;&gt;&lt;circle cx=&#39;15&#39; cy=&#39;15&#39; r=&#39;10&#39; /&gt;&lt;/svg&gt;&quot;)  no-repeat;
  background-size: 100% 100%;
  height: 50px;
  width: 50px;
 &#125;
.img&#123;
    height: 50px;
    width: 50px;
    display: block;
  &#125;
  &lt;/style&gt;

  &lt;img class=&quot;img&quot; src=&quot;data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSczMCcgaGVpZ2h0PSczMCc+PGNpcmNsZSBjeD0nMTUnIGN5PScxNScgcj0nMTAnIC8+PC9zdmc+&quot;&gt;
  &lt;div class=&quot;bg&quot;&gt;&lt;/div&gt;
</code></pre>
<p>最终个效果：</p>
<p><img src="/30-1.png"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://youhaosuda.com/blog/43">【译】在 dataURI 中使用 SVG 的最佳方法</a></li>
<li><a href="https://segmentfault.com/a/1190000013237541">关于SVG</a></li>
</ol>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - CSS部分-伪类伪元素和优先级</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-CSS%E9%83%A8%E5%88%86-%E4%BC%AA%E7%B1%BB%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<h2 id="选择器的优先级"><a href="#选择器的优先级" class="headerlink" title="选择器的优先级"></a>选择器的优先级</h2><p>CSS 标准用一个三元组 (a, b, c) 来构成一个复杂选择器的优先级。</p>
<pre><code>id 选择器的数目记为 a；
伪类选择器和 class 选择器的数目记为 b；
伪元素选择器和标签选择器数目记为 c；
“*” 不影响优先级。
</code></pre>
<p>CSS 标准建议用一个足够大的进制，获取“ a-b-c ”来表示选择器优先级。</p>
<pre><code>specificity = base * base * a + base * b + c
</code></pre>
<ul>
<li>同一优先级的选择器遵循“后面的覆盖前面的”原则</li>
<li>行内属性的优先级永远高于 CSS 规则</li>
<li>!important优先级高于行内属性</li>
</ul>
<span id="more"></span>
<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><p>伪元素本身不单单是一种选择规则，它还是一种机制。伪元素的语法跟伪类相似，但是实际产生的效果却是把不存在的元素硬选出来。  </p>
<p>目前兼容性达到可用的伪元素有以下几种。</p>
<pre><code>::first-line
::first-letter
::before
::after
</code></pre>
<h3 id="first-line-和-first-letter"><a href="#first-line-和-first-letter" class="headerlink" title="::first-line 和 ::first-letter"></a>::first-line 和 ::first-letter</h3><p>二者是比较类似的伪元素，其中一个表示元素的第一行，一个表示元素的第一个字母。</p>
<pre><code>//首字母变大并向左浮动（一个非常常见的排版方式）
p::first-letter &#123; 
  text-transform: uppercase;
  font-size:2em;
  float:left; 
&#125;
</code></pre>
<p>CSS 标准规定了 first-line 必须出现在最内层的块级元素之内。</p>
<pre><code>&lt;style&gt;
    div&gt;span#a &#123;
      color:green;
    &#125;
    div&gt;p#b &#123;
      color:red;
    &#125;
    div::first-line &#123; 
      color:blue; 
    &#125;
&lt;/style&gt;
&lt;div&gt;
  &lt;span id=&#39;a&#39;&gt;First paragraph(green)&lt;/span&gt;&lt;br /&gt;
  &lt;span&gt;Second paragraph&lt;/span&gt;
&lt;/div&gt;
&lt;div&gt;
  &lt;p id=&#39;b&#39;&gt;First paragraph(blue)&lt;/p&gt;
  &lt;p&gt;Second paragraph&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<h3 id="before-和-after-。"><a href="#before-和-after-。" class="headerlink" title="::before 和 ::after 。"></a>::before 和 ::after 。</h3><p>这两个伪元素跟前面两个不同的是，它不是把已有的内容套上一个元素，而是真正的无中生有，造出一个元素。<br>这两个伪元素所在的 CSS 规则必须指定 content 属性才会生效</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Introduction_to_CSS/Pseudo-classes_and_pseudo-elements">MDN-伪类和伪元素
</a></li>
</ol>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - CSS部分-动画与交互</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-CSS%E9%83%A8%E5%88%86-%E5%8A%A8%E7%94%BB%E4%B8%8E%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>CSS 中跟动画相关的属性有两个：animation 和 transition。</p>
<span id="more"></span>

<h2 id="animation-属性"><a href="#animation-属性" class="headerlink" title="animation 属性"></a>animation 属性</h2><p>基本用法：</p>
<pre><code>@keyframes mykf
&#123;
  from &#123;background: red;&#125;
  to &#123;background: yellow;&#125;
&#125;

div
&#123;
    animation:mykf 5s infinite;
&#125;
</code></pre>
<p>实际上 animation 分成六个部分：</p>
<ul>
<li>animation-name 动画的名称，这是一个 keyframes 类型的值（产生一种数据，用于定义动画关键帧）；</li>
<li>animation-duration 动画的时长；</li>
<li>animation-timing-function 动画的时间曲线；</li>
<li>animation-delay 动画开始前的延迟；</li>
<li>animation-iteration-count 动画的播放次数；</li>
<li>animation-direction 动画的方向。</li>
</ul>
<h2 id="transition-属性"><a href="#transition-属性" class="headerlink" title="transition 属性"></a>transition 属性</h2><p>它有四个部分：</p>
<ul>
<li>transition-property 要变换的属性；</li>
<li>transition-duration 变换的时长；</li>
<li>transition-timing-function 时间曲线；</li>
<li>transition-delay 延迟。</li>
</ul>
<p>实际上，有时候我们会把 transition 和 animation 组合，抛弃 animation 的 timing-function，以编排不同段用不同的曲线。</p>
<pre><code>@keyframes mykf &#123;

    
  0% &#123; top: 0; transition:top ease&#125;
    
  50% &#123; top: 30px;transition:top ease-in &#125;

  75% &#123; top: 10px;transition:top ease-out &#125;

  100% &#123; top: 0; transition:top linear&#125;
    
&#125;
</code></pre>
<h3 id="timing-function-动画的时间曲线"><a href="#timing-function-动画的时间曲线" class="headerlink" title="timing-function-动画的时间曲线"></a>timing-function-动画的时间曲线</h3><p>CSS 的时间曲线选用的是（三次）贝塞尔曲线，贝塞尔曲线是一种被工业生产验证了很多年的曲线，它最大的特点就是“平滑”。时间曲线平滑，意味着较少突兀的变化，这是一般动画设计所追求的。</p>
<p>理论上，贝塞尔曲线可以通过分段的方式拟合任意曲线，但是有一些特殊的曲线，是可以用贝塞尔曲线完美拟合的，比如抛物线。</p>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - CSS部分-文档流</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-CSS%E9%83%A8%E5%88%86-%E6%96%87%E6%A1%A3%E6%B5%81/</url>
    <content><![CDATA[<h2 id="正常流的行为"><a href="#正常流的行为" class="headerlink" title="正常流的行为"></a>正常流的行为</h2><p>我们可以用一句话来描述正常流的排版行为，那就是：依次排列，排不下了换行。</p>
<p>当我们要把正常流中的一个盒或者文字排版，需要分成三种情况处理:</p>
<ul>
<li>当遇到块级盒：排入块级格式化上下文。</li>
<li>当遇到行内级盒或者文字：首先尝试排入行内级格式化上下文，如果排不下，那么创建一个行盒，先将行盒排版（行盒是块级，所以到第一种情况），行盒会创建一个行内级格式化上下文。</li>
<li>遇到 float 盒：把盒的顶部跟当前行内级上下文上边缘对齐，然后根据 float 的方向把盒的对应边缘对到块级格式化上下文的边缘，之后重排当前行盒。</li>
</ul>
<span id="more"></span>

<h2 id="正常流实现的两种布局"><a href="#正常流实现的两种布局" class="headerlink" title="正常流实现的两种布局"></a>正常流实现的两种布局</h2><h3 id="等分布局"><a href="#等分布局" class="headerlink" title="等分布局"></a>等分布局</h3><pre><code>//css样式
.outer &#123;
  width: 101px;
  /* 在某些浏览器中，因为像素计算精度问题，还是会出现换行，我们给 outer 添加一个特定宽度： */
  font-size: 0;
  /* 解决换行和空格被 HTML 当作空格文本，跟 inline 盒混排了的问题。 */
&#125;

.inner &#123;
  width: 33.33%;
  height: 300px;
  display: inline-block;
  outline: solid 1px blue;
&#125;

.inner:last-child &#123;
  margin-right: -5px;
  /* 解决某些旧版本浏览器中会出现换行的问题 */
&#125;
 
//html
&lt;div class=&quot;outer&quot;&gt;
    &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3 id="自适应宽"><a href="#自适应宽" class="headerlink" title="自适应宽"></a>自适应宽</h3><p>自适应宽（一个元素固定宽度，另一个元素填满父容器剩余宽度）是个经典的布局问题，我们现在就看一下如何使用正常流来解决：</p>
<pre><code>.outer &#123;
  font-size: 0;
&#125;

.fixed,
.auto &#123;
  outline: solid 1px red;
  display: inline-block;
  vertical-align: top;
  height: 300px;
&#125;

.fixed &#123;
  width: 200px;
&#125;
.auto &#123;
  width: 100%;
  margin-left: -200px;
  padding-left: 200px;
  box-sizing: border-box;
&#125;

//html文件
 &lt;div class=&quot;outer&quot;&gt;
    &lt;div class=&quot;fixed&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;auto&quot;&gt;&lt;/div&gt;
 &lt;/div&gt;
</code></pre>
<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>BFC可以包含浮动元素（闭合浮动）</li>
<li>BFC所确定的区域不会与外部浮动元素发生重叠</li>
<li>位于同一BFC下的相邻块级子元素在垂直方向上会发生margin重叠</li>
<li>位于不同BFC下的相邻元素之间不会发生margin重叠</li>
</ul>
<p>将以上特点一言以蔽之，即BFC在页面上是一个封闭的区域，如同“结界”一般。即便是内部的浮动元素也无法脱离该区域。该区域内部的子元素无法影响区域外部，同时也不受外部影响。</p>
<h3 id="如何触发-创建BFC"><a href="#如何触发-创建BFC" class="headerlink" title="如何触发/创建BFC"></a>如何触发/创建BFC</h3><p>满足下面任一条件即可：</p>
<ul>
<li>&lt;html&gt;根元素</li>
<li>float的值不为none</li>
<li>overflow的值为auto、scroll或hidden</li>
<li>display的值为table-cell、table-caption或inline-block</li>
<li>position的值为fixed或absolute</li>
</ul>
<h3 id="BFC的常见用途"><a href="#BFC的常见用途" class="headerlink" title="BFC的常见用途"></a>BFC的常见用途</h3><h4 id="闭合浮动"><a href="#闭合浮动" class="headerlink" title="闭合浮动"></a>闭合浮动</h4><pre><code>#container &#123;
 overflow: auto;  /* 创建BFC */
&#125;
</code></pre>
<h4 id="阻止margin重叠"><a href="#阻止margin重叠" class="headerlink" title="阻止margin重叠"></a>阻止margin重叠</h4><p>发生重叠的代码：</p>
<pre><code>/* HTML代码 */
&lt;div id=&quot;box1&quot;&gt;我是box1&lt;/div&gt;
&lt;div id=&quot;box2&quot;&gt;我是box2&lt;/div&gt;

/* CSS代码 */
#box1 &#123;
    margin-bottom: 20px;
    background-color: lightskyblue;
&#125;

#box2 &#123;
    margin-top: 20px;
    background-color: orange;
&#125;
</code></pre>
<p>创建BFC解决：</p>
<pre><code>/* HTML代码 */
&lt;div id=&quot;box1&quot;&gt;我是box1&lt;/div&gt;
&lt;div id=&quot;bfc&quot;&gt;
    &lt;div id=&quot;box2&quot;&gt;我是box2&lt;/div&gt;
&lt;/div&gt;
/* CSS代码 */
#bfc &#123;
    overflow: auto;  /* 创建BFC */
&#125;
</code></pre>
<h4 id="自适应流体布局"><a href="#自适应流体布局" class="headerlink" title="自适应流体布局"></a>自适应流体布局</h4><p>BFC最强大的用途其实是用于自适应流体布局，这是基于BFC所确定的区域不会与外部浮动元素发生重叠的特性实现的。  </p>
<p>假设我们需要创建一个左侧宽度固定为200px，右侧宽度自适应的两列布局，一般情况下有如下解决方案：</p>
<pre><code>/* HTML代码 */
&lt;div id=&quot;layout&quot;&gt;
    &lt;div id=&quot;left&quot;&gt;&lt;/div&gt;
    &lt;div id=&quot;right&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

/* CSS代码 */
#layout&#123;
    overflow: auto;   /* 创建BFC闭合浮动 */ 
&#125;

#left &#123;
    width: 200px;
    float: left;
&#125;

#right &#123;
    margin-left: 200px;
&#125;
</code></pre>
<p>创建BFC解决：</p>
<pre><code>#right &#123;
    overflow: auto;  /* 创建BFC */
&#125;
</code></pre>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://www.jianshu.com/p/4ed27e9ea441">BFC的理解和运用</a></li>
</ol>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - CSS部分-选择器整体结构</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-CSS%E9%83%A8%E5%88%86-%E9%80%89%E6%8B%A9%E5%99%A8%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="简单选择器"><a href="#简单选择器" class="headerlink" title="简单选择器"></a>简单选择器</h2><p><img src="https://static001.geekbang.org/resource/image/4c/ce/4c9ac78870342dc802137ea9c848c0ce.png"></p>
<span id="more"></span>
<h3 id="类型选择器"><a href="#类型选择器" class="headerlink" title="类型选择器"></a>类型选择器</h3><pre><code>span &#123;display:block&#125;
</code></pre>
<p><strong>命名空间</strong>：如果svg 和 html 中都有 a 元素，我们若要想区分选择 svg 中的 a 和 html 中的 a，就必须用带命名空间的类型选择器。</p>
<pre><code>@namespace svg url(http://www.w3.org/2000/svg);
@namespace html url(http://www.w3.org/1999/xhtml);

html|a &#123;
  color: red;
&#125;

svg|a &#123;
  stroke:blue;
  stroke-width:1;
&#125;
</code></pre>
<h3 id="全体选择器"><a href="#全体选择器" class="headerlink" title="全体选择器"></a>全体选择器</h3><pre><code>* &#123;margin:0&#125;
</code></pre>
<h3 id="id-选择器与-class-选择器"><a href="#id-选择器与-class-选择器" class="headerlink" title="id 选择器与 class 选择器"></a>id 选择器与 class 选择器</h3><p>略</p>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>[attribute]    用于选取带有指定属性的元素。<br>[attribute=value]    用于选取带有指定属性和值的元素。<br>[attribute~=value]    用于选取属性值中包含指定词汇的元素。<br>[attribute|=value]    用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。<br>[attribute^=value]    匹配属性值以指定值开头的每个元素。<br>[attribute$=value]    匹配属性值以指定值结尾的每个元素。<br>[attribute*=value]    匹配属性值中包含指定值的每个元素。</p>
<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>伪类选择器有普通型和函数型两种,带括号的就是函数型</p>
<h4 id="树结构关系伪类选择器"><a href="#树结构关系伪类选择器" class="headerlink" title="树结构关系伪类选择器"></a>树结构关系伪类选择器</h4><ul>
<li><p><code>:root</code> 伪类表示树的根元素，基本等同于html元素</p>
<p>  在声明全局 CSS 变量时 :root 会很有用：</p>
<pre><code>  :root &#123;
    --main-color: hotpink;
    --pane-padding: 5px 42px;
  &#125;
</code></pre>
</li>
<li><p><code>:empty</code> 伪类表示没有子节点的元素，选择每个没有任何子级的元素（包括文本节点）。</p>
<pre><code>  p:empty&#123;
    height: 20px;
    background:#ff0000;
  &#125;
</code></pre>
</li>
<li><p><code>:nth-child(n)</code> ， <code>:nth-of-type(n)</code> </p>
<pre><code>  p:nth-child(2)  选择每个p元素是其父级的第二个子元素 
  p:nth-of-type(2)：选择每个p元素是其父级的第二个p元素
</code></pre>
</li>
<li><p><code>:nth-last-child(n)</code>，<code>nth-last-of-type(n)</code> 的区别仅仅是从后往前数。</p>
</li>
<li><p><code>:first-child 和 :last-child</code> , <code>:first-of-type 和 :last-of-type</code>分别表示第一个和最后一个元素。</p>
</li>
<li><p><code>:only-child</code>，<code>only-of-type</code> 唯一个子元素和唯一一个同类型子元素。</p>
</li>
</ul>
<h4 id="链接与行为伪类选择器"><a href="#链接与行为伪类选择器" class="headerlink" title="链接与行为伪类选择器"></a>链接与行为伪类选择器</h4><pre><code>:any-link 表示任意的链接，包括 a、area 和 link 标签都可能匹配到这个伪类。
:link 表示未访问过的链接， :visited 表示已经访问过的链接。
:hover 表示鼠标悬停在上的元素，
:active 表示用户正在激活这个元素，如用户按下按钮，鼠标还未抬起时，这个按钮就处于激活状态
:focus 表示焦点落在这个元素之上。
:target 用于选中浏览器 URL 的 hash 部分所指示的元素。demo请访问：http://www.runoob.com/try/try.php?filename=trycss3_target
</code></pre>
<h4 id="逻辑伪类选择器"><a href="#逻辑伪类选择器" class="headerlink" title="逻辑伪类选择器"></a>逻辑伪类选择器</h4><p>:not(x) 伪类:它匹配不符合参数选择器X描述的元素。X不能包含另外一个否定选择器(函数型伪类)</p>
<pre><code>:not(.cls)&#123;
  color: aqua
&#125;
</code></pre>
<p>css3 级标准中，not 只支持简单选择器，CSS4功能更强大，但目前还没有浏览器实现它。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="http://www.ruanyifeng.com/blog/2017/05/css-variables.html">CSS 变量教程</a></li>
</ol>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - HML部分-替换型元素</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-HML%E9%83%A8%E5%88%86-%E6%9B%BF%E6%8D%A2%E5%9E%8B%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>之前讲到过链接，这里要讲的替换型元素，就是另一种引入文件的方式了。替换型元素是把文件的内容引入，替换掉自身位置的一类标签</p>
<span id="more"></span>
<h2 id="script-标签"><a href="#script-标签" class="headerlink" title="script 标签"></a>script 标签</h2><p>script 标签是为数不多的既可以作为替换型标签，又可以不作为替换型标签的元素。</p>
<p>写法一：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
console.log(&quot;Hello world!&quot;);    
&lt;/script&gt;
</code></pre>
<p>写法二：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;my.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>上述两种写法是等效的，可以发现：<strong>凡是替换型元素，都是使用 src 属性来引用文件的，而链接型元素是使用 href 标签的</strong>  </p>
<p>但是对于样式来说：style 标签并非替换型元素，不能使用 src 属性，这样，我们用 link 标签引入 CSS 文件，当然就是用 href。</p>
<!-- more -->

<h2 id="img-标签"><a href="#img-标签" class="headerlink" title="img 标签"></a>img 标签</h2><p>我们最熟悉的替换型标签就是 img 标签。它的的作用是引入一张图片。这个标签是没有办法像 script 标签那样作为非替换型标签来使用的，它必须有 src 属性才有意义。   </p>
<p>如果一定不想要引入独立文件，可以使用 data uri 作为图片的 src，这样，并没有产生独立的文件，客观上做到了和内联相同的结果，这是一个常用的技巧。</p>
<h3 id="alt-属性"><a href="#alt-属性" class="headerlink" title="alt 属性"></a>alt 属性</h3><p>这个属性很难被普通用户感知，对于视障用户非常重要，可以毫不夸张地讲，给 img 加上 alt 属性，已经做完了可访问性的一半。</p>
<h3 id="srcset-和-sizes"><a href="#srcset-和-sizes" class="headerlink" title="srcset 和 sizes"></a>srcset 和 sizes</h3><p>img 标签还有一组重要的属性，那就是 srcset 和 sizes，这两个属性的作用是在不同的屏幕大小和特性下，使用不同的图片源：</p>
<pre><code> &lt;img srcset=&quot;elva-fairy-320w.jpg 320w,
     elva-fairy-480w.jpg 480w,
     elva-fairy-800w.jpg 800w&quot;
   sizes=&quot;(max-width: 320px) 280px,
    (max-width: 480px) 440px,
    800px&quot;
  src=&quot;elva-fairy-800w.jpg&quot; alt=&quot;Elva dressed as a fairy&quot;&gt;
</code></pre>
<p>在不同的屏幕尺寸从1000到200缩小的过程中会依次加载：<code>elva-fairy-800w.jpg, elva-fairy-480w.jpg, elva-fairy-320w.jpg</code>。  </p>
<p>但是其实更好的做法，是使用 picture 元素。</p>
<h2 id="picture-标签"><a href="#picture-标签" class="headerlink" title="picture 标签"></a>picture 标签</h2><p>picture 元素可以根据屏幕的条件为其中的 img 元素提供不同的源，它的基本用法如下：</p>
<pre><code>&lt;picture&gt;
  &lt;source srcset=&quot;https://zuhaowan.zuhaowan.com/v1/channel/img/bg_01.png&quot; media=&quot;(min-width: 600px)&quot;&gt;
  &lt;source srcset=&quot;https://zuhaowan.zuhaowan.com/v1/channel/img/bg_02.png&quot; media=&quot;(min-width: 300px) and (max-width: 600px)&quot; &gt;
  &lt;img src=&quot;https://zuhaowan.zuhaowan.com/v1/channel/img/first.png&quot;&gt;
&lt;/picture&gt;
</code></pre>
<p>它跟 img 搭配 srcset 和 sizes 不同，它使用 source 元素来指定图片源，并且支持多个。这里的 media 属性是 media query，跟 CSS 的 @media 规则一致。</p>
<h2 id="video标签"><a href="#video标签" class="headerlink" title="video标签"></a>video标签</h2><p>在 HTML5 早期的设计中，video 标签跟 img 标签类似，也是使用 src 属性来引入源文件的，不过，考虑到了各家浏览器支持的视频格式不同，现在的 video 标签跟 picture 元素一样，也是提倡使用 source 的。</p>
<p>早期写法：</p>
<pre><code>&lt;video controls=&quot;controls&quot; src=&quot;movie.ogg&quot;&gt;&lt;/video&gt;
</code></pre>
<p>现代写法：</p>
<pre><code>&lt;video controls=&quot;controls&quot; &gt;
  &lt;source src=&quot;movie.webm&quot; type=&quot;video/webm&quot; &gt;
  &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot; &gt;
  &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt;
  You browser does not support video.
&lt;/video&gt;
</code></pre>
<p><strong>source 标签除了支持 media 之外，还可以使用 type 来区分源文件的使用场景</strong></p>
<p>对于更古老的浏览器，还可以在其中加入 object 或者 embed 标签</p>
<h3 id="video中的trak标签"><a href="#video中的trak标签" class="headerlink" title="video中的trak标签"></a>video中的trak标签</h3><p>track 是一种播放时序相关的标签，它最常见的用途就是字幕。track 标签中，必须使用 srclang 来指定语言，此外，track 具有 kind 属性，共有五种。</p>
<pre><code>subtitles：就是字幕了，不一定是翻译，也可能是补充性说明
captions：报幕内容，可能包含演职员表等元信息，适合听障人士或者没有打开声音的人了解音频内容
descriptions：视频描述信息，适合视障人士或者没有视频播放功能的终端打开视频时了解视频内尔用
chapters：用于浏览器视频内容。
metadata：给代码提供的元信息，对普通用户不可见。
</code></pre>
<p>一个完整的 video 标签可能会包含多种 track 和多个 source，这些共同构成了一个视频播放所需的全部信息。</p>
<h2 id="aduio标签"><a href="#aduio标签" class="headerlink" title="aduio标签"></a>aduio标签</h2><p>与picture 和 video 两种标签一样，audio 也可以使用 source 元素来指定源文件：</p>
<pre><code>&lt;audio controls&gt;
  &lt;source src=&quot;song.mp3&quot; type=&quot;audio/mpeg&quot;&gt;
  &lt;source src=&quot;song.ogg&quot; type=&quot;audio/ogg&quot;&gt;
  &lt;p&gt;You browser does not support audio.&lt;/p&gt;    
&lt;/audio&gt;
</code></pre>
<p>同时也可以使用src属性，且兼容性要比video标签乐观</p>
<pre><code>&lt;audio controls=&quot;controls&quot; src=&quot;audio.ogg&quot;&gt;&lt;/audio&gt;
</code></pre>
<h2 id="iframe标签"><a href="#iframe标签" class="headerlink" title="iframe标签"></a>iframe标签</h2><p>这个标签能够嵌入一个完整的网页：</p>
<pre><code>&lt;iframe src=&quot;http://time.geekbang.org&quot;&gt;&lt;/iframe&gt;
</code></pre>
<p>但同时会带来很多安全问题，html5加入了一些新标准，在新标准中，为 iframe 加入了 sandbox 模式和 srcdoc 属性，这样，给 iframe 带来了一定的新场景：</p>
<pre><code>&lt;iframe sandbox=&quot;allow-scripts&quot; src=&quot;http://www.b.com/&quot;&gt;&lt;/iframe&gt;
</code></pre>
<p>sandbox模式的加入可以解决跨域问题，同时对加载的页面加入各种限制，如是否允许脚本执行，是否允许表单提交等操作。</p>
<p>sandbox模式下子页面与父页面的交互完全被隔离开，无法进行任何相互操作。</p>
<h3 id="引申：如何阻止自己的页面被iframe引用"><a href="#引申：如何阻止自己的页面被iframe引用" class="headerlink" title="引申：如何阻止自己的页面被iframe引用"></a>引申：如何阻止自己的页面被iframe引用</h3><h4 id="修改http响应头"><a href="#修改http响应头" class="headerlink" title="修改http响应头"></a>修改http响应头</h4><pre><code>header(‘X-Frame-Options:Deny&#39;);
</code></pre>
<p>一劳永逸，非常靠谱</p>
<h4 id="脚本检测"><a href="#脚本检测" class="headerlink" title="脚本检测"></a>脚本检测</h4><pre><code>try&#123;
　　top.location.hostname;
　　if (top.location.hostname != window.location.hostname) &#123;
　　　　top.location.href =window.location.href;
　　&#125;
&#125;catch(e)&#123;
　　top.location.href = window.location.href;
&#125;
</code></pre>
<p>代码解释：  </p>
<p>top 对象始终指向最高（最外）层的框架:</p>
<pre><code>top===window.top
</code></pre>
<p>在某些情况下，window.parent 有可能等于 top;  </p>
<p>但在没有框架的情况下，parent 一定等于top （此时它们都等于 window ）:</p>
<pre><code>window.parent===top
window.parent===window.top
</code></pre>
<p>被嵌套时，如果跨域，子页面执行 top.location.hostname会被block，进入catch逻辑；</p>
<p>如何主域相同，子域不同，可以在父页面和子页面都设置相同的<code>docum.domain</code>来解决跨域；</p>
<p>此时代码就会进入try逻辑，判断后发现hostname不一致，然后有进行了跳转；</p>
<p>但如果对方采用sandbox模式，且不允许js执行的话，该方法会失效；</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="http://www.w3school.com.cn/tags/tag_iframe.asp">HTML5 iframe标签新属性</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options">X-Frame-Options</a></li>
<li><a href="https://www.cnblogs.com/boystar/p/6909214.html">iFrame跨域解决办法</a></li>
</ol>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - HTML部分-语义</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-HML%E9%83%A8%E5%88%86-%E8%AF%AD%E4%B9%89/</url>
    <content><![CDATA[<h2 id="语义标签"><a href="#语义标签" class="headerlink" title="语义标签"></a>语义标签</h2><p>html属于标记形语言，标签语义化更接近我们平常说话的自然语言，并没有唯一的标准措辞，语义标签的使用也是一样。    </p>
<span id="more"></span>
<p>语义化的三个明确的场景：</p>
<ol>
<li>自然语言表达能力的补充：用来表达一定的结构或者消除歧义； </li>
<li>文章标题摘要； </li>
<li>适合机器阅读的整体结构</li>
</ol>
<p>HTML最初的设计场景就是“超文本”，早期HTML工作组的专家都是出版界书籍排版的专家。</p>
<p>实际上，HTML这种语言，并不像严谨的编程语言一样，有一条非此即彼的线。一些语义的使用其实会带来争议，所以我的建议是：你可以尽量只用自己熟悉的语义标签，并且只在有把握的场景引入语义标签。这样，我们才能保证语义标签不被滥用，造成更多的问题。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>ruby标签的使用, 本意在东亚使用，显示的是东亚字符的发音，现在网络多用来在表情包上</p>
<pre><code>&lt;p&gt;一个&lt;ruby&gt;友善&lt;rt&gt;bi shi&lt;rp&gt;不支持的标签&lt;/rp&gt;&lt;/rt&gt;&lt;/ruby&gt;的眼神&lt;/p&gt;
</code></pre>
<p>效果：</p>
<p><img src="1.png"></p>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - HML部分-链接种类</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-HML%E9%83%A8%E5%88%86-%E9%93%BE%E6%8E%A5%E7%A7%8D%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="HTML中所有的链接种类"><a href="#HTML中所有的链接种类" class="headerlink" title="HTML中所有的链接种类"></a>HTML中所有的链接种类</h2><p>链接是 HTML 中的一种机制，它是 HTML 文档和其它文档或者资源的连接关系，在 HTML 中，链接有两种类型。一种是超链接型标签，一种是外部资源链接。</p>
<p><img src="17-1.png"></p>
<span id="more"></span>
<h2 id="link-标签"><a href="#link-标签" class="headerlink" title="link 标签"></a>link 标签</h2><h3 id="超链接类-link-标签"><a href="#超链接类-link-标签" class="headerlink" title="超链接类 link 标签"></a>超链接类 link 标签</h3><p>超链接型 link 标签是一种被动型链接，在用户不操作的情况下，它们不会被主动下载。</p>
<p>link 标签具有特定的 rel 属性，会成为特定类型的 link 标签。产生超链接的 link 标签包括：具有 rel=“canonical” 的 link、具有 rel=”alternate”的 link、具有 rel=“prev” rel=”next”的 link 等等。</p>
<h4 id="canonical型"><a href="#canonical型" class="headerlink" title="canonical型"></a>canonical型</h4><pre><code>    &lt;link rel=&quot;canonical&quot; href=&quot;...&quot;&gt;
</code></pre>
<p>这个标签提示页面它的主 URL，在网站中常常有多个 URL 指向同一页面的情况，搜索引擎访问这类页面时会去掉重复的页面，这个 link 会提示搜索引擎保留哪一个 URL。</p>
<h4 id="alternate型"><a href="#alternate型" class="headerlink" title="alternate型"></a>alternate型</h4><pre><code>    &lt;link rel=&quot;alternate&quot; href=&quot;...&quot;&gt;
</code></pre>
<p>这个标签提示页面它的变形形式，这个所谓的变形可能是当前页面内容的不同格式、不同语言或者为不同的设备设计的版本，这种 link 通常也是提供给搜索引擎来使用的。<br>一个典型应用场景是，页面提供 rss 订阅时，可以用这样的 link 来引入(除了搜索引擎外，很多浏览器插件都能识别这样的 link。)：</p>
<pre><code>    &lt;link rel=&quot;alternate&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot; href=&quot;...&quot;&gt;
</code></pre>
<h4 id="prev-amp-next型"><a href="#prev-amp-next型" class="headerlink" title="prev &amp; next型"></a>prev &amp; next型</h4><p>来告诉搜索引擎或者浏览器它的前一项和后一项，这有助于页面的批量展示。因为 next 型 link 告诉浏览器“这是很可能访问的下一个页面”，HTML 标准还建议对 next 型 link 做预处理。</p>
<h4 id="其他超链类型"><a href="#其他超链类型" class="headerlink" title="其他超链类型"></a>其他超链类型</h4><pre><code>    rel=“author” 链接到本页面的作者，一般是 mailto: 协议
    rel=“help” 链接到本页面的帮助页
    rel=“license” 链接到本页面的版权信息页
    rel=“search” 链接到本页面的搜索页面（一般是站内提供搜索时使用）
</code></pre>
<h3 id="外部资源类-link-标签"><a href="#外部资源类-link-标签" class="headerlink" title="外部资源类 link 标签"></a>外部资源类 link 标签</h3><p>外部资源型 link 标签会被主动下载，并且根据 rel 类型做不同的处理。外部资源型的标签包括：具有 icon 型的 link、预处理类 link、modulepreload 型的 link、stylesheet、pingback。</p>
<h4 id="icon型"><a href="#icon型" class="headerlink" title="icon型"></a>icon型</h4><pre><code>    &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;32x32&quot; href=&quot;//static001.geekbang.org/static/icon/time/favicon-32x32.png&quot;&gt;
</code></pre>
<p>只有 icon 型 link 有有效的 sizes 属性，HTML 标准允许一个页面出现多个 icon 型 link，并且用 sizes 指定它适合的 icon 尺寸</p>
<h4 id="预处理类"><a href="#预处理类" class="headerlink" title="预处理类"></a>预处理类</h4><pre><code>    dns-prefetch 型 link 提前对一个域名做 dns 查询，这样的 link 里面的 href 实际上只有域名有意义。
    preconnect 型 link 提前对一个服务器建立 tcp 连接。
    prefetch 型 link 提前取 href 指定的 url 的内容。
    preload 型 link 提前加载 href 指定的 url。
    prerender 型 link 提前渲染 href 指定的 url。
    modulepreload 型的 link
</code></pre>
<p>预处理类 link 标签就是允许我们控制浏览器，提前针对一些资源去做这些操作，以提高性能（当然如果你乱用的话，性能反而更差）。</p>
<h4 id="modulepreload"><a href="#modulepreload" class="headerlink" title="modulepreload"></a>modulepreload</h4><pre><code>    &lt;link rel=&quot;modulepreload&quot; href=&quot;app.js&quot;&gt;
</code></pre>
<p>modulepreload 型 link 的作用是预先加载一个 JavaScript 的模块。这可以保证 JS 模块不必等到执行时才加载。<br>这里的所谓加载，是指完成下载并放入内存，并不会执行对应的 JavaScript。</p>
<h4 id="stylesheet"><a href="#stylesheet" class="headerlink" title="stylesheet"></a>stylesheet</h4><pre><code>    &lt;link rel=&quot;stylesheet&quot; href=&quot;xxx.css&quot; type=&quot;text/css&quot;&gt;
</code></pre>
<p>基本用法是从一个 CSS 文件创建一个样式表。这里 type 属性可以没有，如果有，必须是”text/css”才会生效。</p>
<ul>
<li>pingback<br>这样的 link 表示本网页被引用时，应该使用的 pingback 地址，这个机制是一份独立的标准，遵守 pingback 协议的网站在引用本页面时，会向这个 pingback url 发送一个消息。</li>
</ul>
<h2 id="a-标签"><a href="#a-标签" class="headerlink" title="a 标签"></a>a 标签</h2><p>具有 href 的 a 标签跟一些 link 一样，会产生超链接，也就是在用户不操作的情况下，它们不会被主动下载的被动型链接。</p>
<p>a 标签也可以有 rel 属性，我们来简单了解一下，首先是跟 link 相同的一些 rel，包括下面的几种：</p>
<pre><code>alternate
author
help
license
next
prev
search
</code></pre>
<p>这些跟 link 语义完全一致，不同的是，a 标签产生的链接是会实际显示在网页中的，而 link 标签仅仅是元信息。</p>
<p>a 标签独有的 rel 类型：</p>
<pre><code>tag 表示本网页所属的标签；
bookmark 到上级章节的链接。
</code></pre>
<p>a 标签还有一些辅助的 rel 类型，用于提示浏览器或者搜索引擎做一些处理：</p>
<pre><code>nofollow 此链接不会被搜索引擎索引；
noopener 此链接打开的网页无法使用 opener 来获得当前页面的窗口；
noreferrer 此链接打开的网页无法使用 referrer 来获得当前页面的 url；
opener 打开的网页可以使用 window.opener 来访问当前页面的 window 对象，这是 a 标签的默认行为。
</code></pre>
<h2 id="area-标签"><a href="#area-标签" class="headerlink" title="area 标签"></a>area 标签</h2><p>area 标签与 a 标签非常相似，不同的是，它不是文本型的链接，而是区域型的链接。area 标签支持的 rel 与 a 完全一样。area 是整个 html 规则中唯一支持非矩形热区的标签，它的 shape 属性支持三种类型：circle(圆形)，rect(矩形)，poly(多边形)</p>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - HTML部分-head内的标签</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-HTML%E9%83%A8%E5%88%86%20-%20head%E5%86%85%E7%9A%84%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h2 id="head-标签本身"><a href="#head-标签本身" class="headerlink" title="head 标签本身"></a>head 标签本身</h2><p>首先我们先来了解一下 head 标签，head 标签本身并不携带任何信息，它主要是作为盛放其它语义类标签的容器使用。</p>
<p>head 标签规定了自身必须是 html 标签中的第一个标签，它的内容必须包含一个 title；</p>
<span id="more"></span>
<h3 id="title-标签"><a href="#title-标签" class="headerlink" title="title 标签"></a>title 标签</h3><p>title 标签表示文档的标题，从字面上就非常容易理解。</p>
<h3 id="base-标签"><a href="#base-标签" class="headerlink" title="base 标签"></a>base 标签</h3><p>base 标签实际上是个历史遗留标签。它的作用是给页面上所有的 URL 相对地址提供一个基础。最多只有一个，它改变全局的链接地址，它是一个非常危险的标签，慎重使用。</p>
<h3 id="meta-标签"><a href="#meta-标签" class="headerlink" title="meta 标签"></a>meta 标签</h3><p>meta 标签是一组键值对，它是一种通用的元信息表示标签。在 head 中可以出现任意多个 meta 标签。一般的 meta 标签由 name 和 content 两个属性来定义。name 表示元信息的名，content 则用于表示元信息的值。</p>
<pre><code>  &lt;meta name=application-name content=&quot;lsForums&quot;&gt;
</code></pre>
<p><strong>meta标签的一些变体</strong></p>
<h4 id="具有-charset-属性的-meta"><a href="#具有-charset-属性的-meta" class="headerlink" title="具有 charset 属性的 meta"></a>具有 charset 属性的 meta</h4><p>从 HTML5 开始，为了简化写法，meta 标签新增了 charset 属性。添加了 charset 属性的 meta 标签无需再有 name 和 content。</p>
<pre><code>  &lt;meta charset=&quot;UTF-8&quot; &gt;
</code></pre>
<p>charset 型 meta 标签非常关键，它描述了 HTML 文档自身的编码形式。因此，建议这个标签放在 head 的第一个。</p>
<h4 id="具有-http-equiv-属性的-meta"><a href="#具有-http-equiv-属性的-meta" class="headerlink" title="具有 http-equiv 属性的 meta"></a>具有 http-equiv 属性的 meta</h4><p>具有 http-equiv 属性的 meta 标签，表示执行一个命令，这样的 meta 标签可以不需要 name 属性了。</p>
<p>例如，下面一段代码，相当于添加了 content-type 这个 http 头，并且指定了 http 编码方式。</p>
<pre><code>&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
</code></pre>
<p>除了 content-type，还有以下几种命令：</p>
<pre><code>content-language 指定内容的语言；
default-style 指定默认样式表；
refresh 刷新；
set-cookie 模拟 http 头 set-cookie，设置 cookie；
x-ua-compatible 模拟 http 头 x-ua-compatible，声明 ua 兼容性；
content-security-policy 模拟 http 头 content-security-policy，声明内容安全策略。
name 为 viewport 的 meta
</code></pre>
<p>meta 标签可以被自由定义，只要写入和读取的双方约定好 name 和 content 的格式就可以了</p>
<h4 id="name-为-viewport-的-meta"><a href="#name-为-viewport-的-meta" class="headerlink" title="name 为 viewport 的 meta"></a>name 为 viewport 的 meta</h4><p>这类 meta 的 name 属性为 viewport，它的 content 是一个复杂结构，是用逗号分隔的键值对，键值对的格式是 key=value。</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=500, initial-scale=1&quot;&gt;
</code></pre>
<p>参数含义如下：</p>
<pre><code>width：页面宽度，可以取值具体的数字，也可以是 device-width，表示跟设备宽度相等。
height：页面高度，可以取值具体的数字，也可以是 device-height，表示跟设备高度相等。
initial-scale：初始缩放比例。
minimum-scale：最小缩放比例。
maximum-scale：最大缩放比例。
user-scalable：是否允许用户缩放。
</code></pre>
<p>对于已经做好了移动端适配的网页，应该把用户缩放功能禁止掉，宽度设为设备宽度，一个标准的 meta 如下：</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;&gt;
</code></pre>
<h4 id="其它预定义的-meta"><a href="#其它预定义的-meta" class="headerlink" title="其它预定义的 meta"></a>其它预定义的 meta</h4><p>在 HTML 标准中，还定义了一批 meta 标签的 name，可以视为一种有约定的 meta，可以简单了解一下:(name为如下值，content为对应值)</p>
<pre><code>application-name：如果页面是 Web application，用这个标签表示应用名称。
author: 页面作者。
description：页面描述，这个属性可能被用于搜索引擎或者其它场合。
generator: 生成页面所使用的工具，主要用于可视化编辑器，如果是手写 HTML 的网页，不需要加这个 meta。
keywords: 页面关键字，对于 SEO 场景非常关键。
referrer: 跳转策略，是一种安全考量。
theme-color: 页面风格颜色，实际并不会影响页面，但是浏览器可能据此调整页面之外的 UI（如窗口边框或者 tab 的颜色）
</code></pre>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://blog.csdn.net/changjiangbuxi/article/details/26054755">标签中http-equiv属性的属性值X-UA-Compatible详解</a></li>
</ol>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - HTML部分-ARIA</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-HTML%E9%83%A8%E5%88%86-ARIA/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们平时写 HTML 语言，都习惯把关注点放到各种标签上，很少去深究它的语法。HTML 这样的语言，与 JavaScript 这样的语言有一些本质的不同。他不具备<a href="https://segmentfault.com/q/1010000000692654">图灵完备</a>性，为“标记语言（mark up language）”，它是纯文本的一种升级，“标记”一词的概念来自：编辑审稿时使用不同颜色笔所做的“标记”。  </p>
<p>HTML 其实是 SGML （一种古老的标记语言）中规定的一种格式，但是实际的浏览器没有任何一个是通过 SGML 引擎来解析 HTML 的。今天的 HTML 仍然有 SGML 的不少影子，本次介绍的是 SGML 留给 HTML 的重要的遗产：基本语法和 DTD。</p>
<span id="more"></span>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>HTML 作为 SGML 的子集，它遵循 SGML 的基本语法：包括标签、转义等。</p>
<p><img src="/1.jpg"></p>
<h3 id="标签语法"><a href="#标签语法" class="headerlink" title="标签语法"></a>标签语法</h3><ul>
<li><p>开始标签：<code>&lt;tagname&gt;</code></p>
<p>带属性的开始标签： <code>&lt;tagname attributename=&quot;attributevalue&quot;&gt;</code></p>
</li>
<li><p>结束标签：<code>&lt;/tagname&gt;</code></p>
</li>
<li><p>自闭合标签：<code>&lt;tagname /&gt;</code></p>
</li>
</ul>
<h3 id="文本语法"><a href="#文本语法" class="headerlink" title="文本语法"></a>文本语法</h3><p>在 HTML 中，规定了两种文本语法，一种是普通的文本节点，另一种是 CDATA 文本节点。</p>
<p>文本节点看似是普通的文本，但是，其中有两种字符是必须做转义的：<code>&lt; 和 &amp;</code>。<br>CDATA 也是一种文本，它存在的意义是语法上的意义：在 CDATA 节点内，不需要考虑多数的转义情况。只有字符组合 <code>]]&gt;</code> 需要处理，这里不能使用转义，只能拆成两个 CDATA 节点。</p>
<h3 id="注释语法"><a href="#注释语法" class="headerlink" title="注释语法"></a>注释语法</h3><p>注释语法以<code>&lt;!--开头，以--&gt;</code>结尾，注释的内容非常自由，除了<code>--&gt;</code>都没有问题。</p>
<h3 id="DTD-语法（文档类型定义）"><a href="#DTD-语法（文档类型定义）" class="headerlink" title="DTD 语法（文档类型定义）"></a>DTD 语法（文档类型定义）</h3><p>SGML 的 DTD 语法十分复杂，但是对 HTML 来说，其实 DTD 的选项是有限的，具体参见第二部分。</p>
<h3 id="ProcessingInstruction-语法（处理信息）"><a href="#ProcessingInstruction-语法（处理信息）" class="headerlink" title="ProcessingInstruction 语法（处理信息）"></a>ProcessingInstruction 语法（处理信息）</h3><p>ProcessingInstruction 多数情况下，是给机器看的。HTML 中规定了可以有 ProcessingInstruction，但是并没有规定它的具体内容，所以可以把它视为一种保留的扩展机制。对浏览器而言，ProcessingInstruction 的作用类似于注释。</p>
<h2 id="关于DTD"><a href="#关于DTD" class="headerlink" title="关于DTD"></a>关于DTD</h2><p>DTD 的全称是 Document Type Defination，也就是文档类型定义。SGML 用 DTD 来定义每一种文档类型，HTML 属于 SGML，在 HTML5 出现之前，HTML 都是使用符合 SGML 规定的 DTD。  </p>
<p>HTML4.01 有三种 DTD。分别是严格模式、过渡模式和 frameset 模式。</p>
<ul>
<li><p>严格模式的 DTD 规定了 HTML4.01 中需要的标签：</p>
<pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
</code></pre>
</li>
<li><p>过渡模式的 DTD 除了 html4.01，还包含了一些被贬斥的标签，这些标签已经不再推荐使用了，但是过渡模式中仍保留了它们：</p>
<pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
</code></pre>
</li>
<li><p>frameset 结构的网页如今已经很少见到了，它使用 frameset 标签把几个网页组合到一起：</p>
<pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;
</code></pre>
</li>
</ul>
<p>HTML4.01 又规定了 XHTML 语法，同样有三个版本：</p>
<ul>
<li><p>版本一</p>
<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;
</code></pre>
</li>
<li><p>版本二</p>
<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
</code></pre>
</li>
</ul>
<ul>
<li>版本三  <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"></li>
</ul>
<p>但是这些复杂的 DTD 写法并没有什么实际作用， 浏览器根本不会用 SGML 引擎解析它们，所以到了 HTML5，干脆放弃了 SGML 子集这项坚持，规定了一个简单的，大家都能记住的 DTD：</p>
<pre><code>&lt;!DOCTYPE html&gt;
</code></pre>
<p>但是，HTML5 也仍然保留了 HTML 语法和 XHTML 语法。</p>
<h2 id="文本实体"><a href="#文本实体" class="headerlink" title="文本实体"></a>文本实体</h2><p>HTML4.01 的 DTD 里包含的 URL ，其实是可以访问的。</p>
<p>但是 W3C 警告说，禁止任何浏览器在解析网页的时候访问这个 URL，不然 W3C 的服务器会被压垮。</p>
<p>url里面的内容是符合 SGML 规范的 DTD，它规定了 HTML 包含了哪些标签、属性和文本实体。其中文本实体分布在三个文件中：HTMLsymbol.ent HTMLspecial.ent 和 HTMLlat1.ent, 了解即可。</p>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - HTML部分-html的语法</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-HTML%E9%83%A8%E5%88%86-html%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们平时写 HTML 语言，都习惯把关注点放到各种标签上，很少去深究它的语法。HTML 这样的语言，与 JavaScript 这样的语言有一些本质的不同。他不具备<a href="https://segmentfault.com/q/1010000000692654">图灵完备</a>性，为“标记语言（mark up language）”，它是纯文本的一种升级，“标记”一词的概念来自：编辑审稿时使用不同颜色笔所做的“标记”。  </p>
<p>HTML 其实是 SGML （一种古老的标记语言）中规定的一种格式，但是实际的浏览器没有任何一个是通过 SGML 引擎来解析 HTML 的。今天的 HTML 仍然有 SGML 的不少影子，本次介绍的是 SGML 留给 HTML 的重要的遗产：基本语法和 DTD。</p>
<span id="more"></span>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>HTML 作为 SGML 的子集，它遵循 SGML 的基本语法：包括标签、转义等。</p>
<p><img src="29-1.jpg"></p>
<h4 id="标签语法"><a href="#标签语法" class="headerlink" title="标签语法"></a>标签语法</h4><ul>
<li><p>开始标签：<code>&lt;tagname&gt;</code></p>
<p>带属性的开始标签： <code>&lt;tagname attributename=&quot;attributevalue&quot;&gt;</code></p>
</li>
<li><p>结束标签：<code>&lt;/tagname&gt;</code></p>
</li>
<li><p>自闭合标签：<code>&lt;tagname /&gt;</code></p>
</li>
</ul>
<h4 id="文本语法"><a href="#文本语法" class="headerlink" title="文本语法"></a>文本语法</h4><p>在 HTML 中，规定了两种文本语法，一种是普通的文本节点，另一种是 CDATA 文本节点。</p>
<p>文本节点看似是普通的文本，但是，其中有两种字符是必须做转义的：<code>&lt; 和 &amp;</code>。<br>CDATA 也是一种文本，它存在的意义是语法上的意义：在 CDATA 节点内，不需要考虑多数的转义情况。只有字符组合 <code>]]&gt;</code> 需要处理，这里不能使用转义，只能拆成两个 CDATA 节点。</p>
<h4 id="注释语法"><a href="#注释语法" class="headerlink" title="注释语法"></a>注释语法</h4><p>注释语法以<code>&lt;!--开头，以--&gt;</code>结尾，注释的内容非常自由，除了<code>--&gt;</code>都没有问题。</p>
<h4 id="DTD-语法（文档类型定义）"><a href="#DTD-语法（文档类型定义）" class="headerlink" title="DTD 语法（文档类型定义）"></a>DTD 语法（文档类型定义）</h4><p>SGML 的 DTD 语法十分复杂，但是对 HTML 来说，其实 DTD 的选项是有限的，具体参见第二部分。</p>
<h4 id="ProcessingInstruction-语法（处理信息）"><a href="#ProcessingInstruction-语法（处理信息）" class="headerlink" title="ProcessingInstruction 语法（处理信息）"></a>ProcessingInstruction 语法（处理信息）</h4><p>ProcessingInstruction 多数情况下，是给机器看的。HTML 中规定了可以有 ProcessingInstruction，但是并没有规定它的具体内容，所以可以把它视为一种保留的扩展机制。对浏览器而言，ProcessingInstruction 的作用类似于注释。</p>
<h2 id="关于DTD"><a href="#关于DTD" class="headerlink" title="关于DTD"></a>关于DTD</h2><p>DTD 的全称是 Document Type Defination，也就是文档类型定义。SGML 用 DTD 来定义每一种文档类型，HTML 属于 SGML，在 HTML5 出现之前，HTML 都是使用符合 SGML 规定的 DTD。  </p>
<p>HTML4.01 有三种 DTD。分别是严格模式、过渡模式和 frameset 模式。</p>
<ul>
<li><p>严格模式的 DTD 规定了 HTML4.01 中需要的标签：</p>
<pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
</code></pre>
</li>
<li><p>过渡模式的 DTD 除了 html4.01，还包含了一些被贬斥的标签，这些标签已经不再推荐使用了，但是过渡模式中仍保留了它们：</p>
<pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
</code></pre>
</li>
<li><p>frameset 结构的网页如今已经很少见到了，它使用 frameset 标签把几个网页组合到一起：</p>
<pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;
</code></pre>
</li>
</ul>
<p>HTML4.01 又规定了 XHTML 语法，同样有三个版本：</p>
<ul>
<li><p>版本一</p>
<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;
</code></pre>
</li>
<li><p>版本二</p>
<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
</code></pre>
</li>
</ul>
<ul>
<li>版本三  <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"></li>
</ul>
<p>但是这些复杂的 DTD 写法并没有什么实际作用， 浏览器根本不会用 SGML 引擎解析它们，所以到了 HTML5，干脆放弃了 SGML 子集这项坚持，规定了一个简单的，大家都能记住的 DTD：</p>
<pre><code>&lt;!DOCTYPE html&gt;
</code></pre>
<p>但是，HTML5 也仍然保留了 HTML 语法和 XHTML 语法。</p>
<h2 id="文本实体"><a href="#文本实体" class="headerlink" title="文本实体"></a>文本实体</h2><p>HTML4.01 的 DTD 里包含的 URL ，其实是可以访问的。</p>
<p>但是 W3C 警告说，禁止任何浏览器在解析网页的时候访问这个 URL，不然 W3C 的服务器会被压垮。</p>
<p>url里面的内容是符合 SGML 规范的 DTD，它规定了 HTML 包含了哪些标签、属性和文本实体。其中文本实体分布在三个文件中：HTMLsymbol.ent HTMLspecial.ent 和 HTMLlat1.ent, 了解即可。</p>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - JavaScript部分-对象</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-JavaScript%E9%83%A8%E5%88%86-%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="面向对象与基于对象"><a href="#面向对象与基于对象" class="headerlink" title="面向对象与基于对象"></a>面向对象与基于对象</h2><h3 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h3><p>Object（对象）在英文中，是一切事物的总称，这和面向对象编程的抽象思维有互通之处。</p>
<p>在《面向对象分析与设计》这本书中，Grady Booch 替我们做了总结，他认为，从人类的认知角度来说，对象应该是下列事物之一：</p>
<ol>
<li>一个可以触摸或者可以看见的东西；</li>
<li>人的智力可以理解的东西；</li>
<li>可以指导思考或行动（进行想象或施加动作）的东西。</li>
</ol>
<p>有了对象的自然定义后，我们就可以描述编程语言中的对象了。在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象，最为成功的流派是使用“类”的方式来描述对象，这诞生了诸如 C++、Java 等流行的编程语言。而 JavaScript 早年却选择了一个更为冷门的方式：原型。</p>
<span id="more"></span>
<h3 id="JavaScript对象的特征"><a href="#JavaScript对象的特征" class="headerlink" title="JavaScript对象的特征"></a>JavaScript对象的特征</h3><ol>
<li>对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。</li>
<li>对象有状态：对象具有状态，同一对象可能处于不同状态之下。</li>
<li>对象具有行为：即对象的状态，可能因为它的行为产生变迁。</li>
</ol>
<p>我们先来看第一个特征，对象具有唯一标识性。一般而言，各种语言的对象唯一标识性都是用内存地址来体现的， 对象具有唯一标识的内存地址，所以具有唯一的标识。</p>
<p>关于对象的第二个和第三个特征“状态和行为”，不同语言会使用不同的术语来抽象描述它们，比如 C++ 中称它们为“成员变量”和“成员函数”，Java 中则称它们为“属性”和“方法”。 </p>
<p>在 JavaScript 中，将状态和行为统一抽象为“属性”，考虑到 JavaScript 中将函数设计成一种特殊对象，所以 JavaScript 中的行为和状态都能用属性来抽象。</p>
<pre><code>var o = &#123; 
    d: 1,
    f() &#123;
        console.log(this.d);
    &#125;    
&#125;;
//o 是对象，d 是一个属性，而函数 f 也是一个属性。
</code></pre>
<p><strong>在实现了对象基本特征的基础上, winter认为，JavaScript 中对象独有的特色是：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</strong></p>
<pre><code>var o = &#123; a: 1 &#125;;
o.b = 2;
console.log(o.a, o.b); //1 2
</code></pre>
<p>JavaScript 允许运行时向对象添加属性，这就跟绝大多数基于类的、静态的对象设计完全不同(如Java)。</p>
<h3 id="JavaScript-对象的两类属性"><a href="#JavaScript-对象的两类属性" class="headerlink" title="JavaScript 对象的两类属性"></a>JavaScript 对象的两类属性</h3><h4 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h4><p>它比较接近于其它语言的属性概念。数据属性具有四个特征:</p>
<ol>
<li>value：就是属性的值。</li>
<li>writable：决定属性能否被赋值(修改)。</li>
<li>enumerable：决定 for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ol>
<p>在大多数情况下，我们只关心数据属性的值即可。我们可以使用<code>Object.defineProperty</code>来定义属性：  </p>
<pre><code>var o = &#123;
  a: 1
&#125;;
Object.defineProperty(o, &quot;b&quot;, &#123;
  value: 2,
  writable: false,
  enumerable: true,
  configurable: false
&#125;);
//a 和 b 都是数据属性，但特征值变化了
Object.getOwnPropertyDescriptor(o, &quot;a&quot;); // &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;
Object.getOwnPropertyDescriptor(o, &quot;b&quot;); // &#123;value: 2, writable: false, enumerable: true, configurable: false&#125;

o.b = 3;
delete o.b; // configurable为false后无法删除属性
console.log(o.b); // 2，b的值不会发生变化

Object.defineProperty(o, &quot;b&quot;, &#123;
  value: 10,
  writable: true,
  enumerable: true,
  configurable: true
&#125;); // TypeError: Cannot redefine property: b
</code></pre>
<p>对于configurable属性来说，如果通过<code>defineProperty</code>修改成 false, 那便无法再修改回来（单向操作，无法撤销）。</p>
<h4 id="访问器（getter-setter）属性"><a href="#访问器（getter-setter）属性" class="headerlink" title="访问器（getter/setter）属性"></a>访问器（getter/setter）属性</h4><p>访问器属性也有四个特征:</p>
<ol>
<li>getter：函数或 undefined，在取属性值时被调用。</li>
<li>setter：函数或 undefined，在设置属性值时被调用。</li>
<li>enumerable：决定 for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ol>
<p>访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。</p>
<pre><code>const k=&#123;
  get age()&#123;
   console.log(&quot;get&quot;)
   return 5
  &#125;,
  set age(val)&#123;
    console.log(&quot;set:&quot;+val)
  &#125;
&#125;
k.age=2;// set:2
k.age;// 5
</code></pre>
<p>访问器属性跟数据属性不同，每次访问属性都会执行 getter 或者 setter 函数。</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>实际上 JavaScript 对象的运行时是一个“属性的集合”，属性以字符串或者 Symbol 为 key，以数据属性特征值或者访问器属性特征值为 value。</p>
<h2 id="原型与类"><a href="#原型与类" class="headerlink" title="原型与类"></a>原型与类</h2><h3 id="基于类和基于原型的差异"><a href="#基于类和基于原型的差异" class="headerlink" title="基于类和基于原型的差异"></a>基于类和基于原型的差异</h3><p>第一部分提到过：在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象：  </p>
<p>最为成功的流派是使用“类”的方式来描述对象，这诞生了诸如 C++、Java 等流行的编程语言。这个流派叫做<strong>基于类的编程语言</strong>。   </p>
<p>还有一种就是<strong>基于原型的编程语言</strong>，它们利用原型来描述对象。我们的 JavaScript 就是其中代表。</p>
<p>“基于类”的编程提倡使用一个关注分类和类之间关系开发模型。在这类语言中，总是先有类，再从类去实例化一个对象。类与类之间又可能会形成继承、组合等关系。类又往往与语言的类型系统整合，形成一定编译时的能力。</p>
<p>而“基于原型”的编程看起来更为提倡程序员去关注一系列对象实例的行为，而后才去关心如何将这些对象，划分到最近的使用方式相似的原型对象，而不是将它们分成类。</p>
<p>JavaScript 并非第一个使用原型的语言，在它之前，self、kevo 等语言已经开始使用原型来描述对象了。原型系统的“复制操作”有两种实现思路：</p>
<ol>
<li>一个是并不真的去复制一个原型对象，而是使得新对象持有一个原型的引用；</li>
<li>另一个是切实地复制对象，从此两个对象再无关联。</li>
</ol>
<p>显然JavaScript选择的是第一种方案。</p>
<h3 id="JavaScript的原型"><a href="#JavaScript的原型" class="headerlink" title="JavaScript的原型"></a>JavaScript的原型</h3><p>原型系统可以说相当简单，可以用两条概括：</p>
<ol>
<li>如果所有对象都有私有字段 [[prototype]]，就是对象的原型；</li>
<li>读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。</li>
</ol>
<p>这个模型在ES的各个版本中并没有很大改变，但在ES6中提供了一系列的内置函数，可以更直接的访问操作原型。三个方法分别是：</p>
<ol>
<li>Object.create 根据指定的原型创建新对象，原型可以是 null；<pre><code> //关于Object.create的补充
 ECMAScript 5 通过新增 Object.create() 方法规范化了原型式继承。
 这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。
 在传入一个参数的情况下，Object.create() 与 object() 方法的行为相同。
 //object 方法如下：
 function object(o)&#123;
     function F()&#123;&#125;
     F.prototype = o;
     return new F();
 &#125;
</code></pre>
</li>
<li>Object.getPrototypeOf 获得一个对象的原型；</li>
<li>Object.setPrototypeOf 设置一个对象的原型。</li>
</ol>
<p>利用这三个方法，可以安全抛开类的思想，利用原型链来实现抽象和复用：</p>
<pre><code>var cat = &#123;
  say()&#123;
      console.log(&quot;meow~&quot;);
  &#125;,
  jump()&#123;
      console.log(&quot;jump&quot;);
  &#125;
&#125;
    
var tiger = Object.create(cat,  &#123;
  say:&#123;
      writable:true,
      configurable:true,
      enumerable:true,
      value:function()&#123;
          console.log(&quot;roar!&quot;);
      &#125;
  &#125;
&#125;)


var anotherCat = Object.create(cat);

anotherCat.say();//&quot;meow~&quot;
var anotherTiger = Object.create(tiger);

anotherTiger.say();//&quot;roar!&quot;
</code></pre>
<h3 id="早期版本中的类与原型"><a href="#早期版本中的类与原型" class="headerlink" title="早期版本中的类与原型"></a>早期版本中的类与原型</h3><p>在早期版本的 JavaScript 中，“类”的定义是一个私有属性 [[class]]，语言标准为内置类型诸如 Number、String、Date 等指定了 [[class]] 属性，以表示它们的类。语言使用者唯一可以访问 [[class]] 属性的方式是 Object.prototype.toString。  </p>
<pre><code>var o = new Object;
var n = new Number;
var s = new String;
var b = new Boolean;
var d = new Date;
var arg = function()&#123; return arguments &#125;();
var r = new RegExp;
var f = new Function;
var arr = new Array;
var e = new Error;
console.log([o, n, s, b, d, arg, r, f, arr, e].map(v =&gt; Object.prototype.toString.call(v))); 
//运行结果：
//[&quot;[object Object]&quot;, &quot;[object Number]&quot;, &quot;[object String]&quot;, &quot;[object Boolean]&quot;, &quot;[object Date]&quot;, &quot;[object Arguments]&quot;, &quot;[object RegExp]&quot;, &quot;[object Function]&quot;, &quot;[object Array]&quot;, &quot;[object Error]&quot;]
</code></pre>
<p>在 ES3 和之前的版本，JS 中类的概念是相当弱的，它仅仅是运行时的一个字符串属性。在 ES5 开始，[[class]] 私有属性被 Symbol.toStringTag 代替，Object.prototype.toString 的意义从命名上不再跟 class 相关。我们甚至可以自定义 Object.prototype.toString 的行为:</p>
<pre><code>var o = &#123; [Symbol.toStringTag]: &quot;MyObject&quot; &#125;;
console.log(Object.prototype.toString.call(o));//[object MyObject]
console.log(o + &quot;&quot;);//[object MyObject] 对于Object类型,如果toString方法没有被改写过（如Number类型），通过加法也可以触发；
</code></pre>
<p>对于new运算符：它接受一个构造器和一组调用参数，实际上做了几件事：</p>
<ol>
<li>以构造器的 prototype 属性（注意与私有字段 [[prototype]] 的区分）为原型，创建新对象；</li>
<li>将 this 和调用参数传给构造器，执行；</li>
<li>如果构造器返回的是对象，则返回，否则返回第一步创建的对象。</li>
</ol>
<p>没有 Object.create、Object.setPrototypeOf 的早期版本中，new 运算是唯一一个可以指定 [[prototype]] 的方法，我们甚至可以用它来实现一个 Object.create 的不完整的 pollyfill，见以下代码（同上面object方法）：</p>
<pre><code>function object(o)&#123;
    function F()&#123;&#125;
    F.prototype = o;
    return new F();
&#125;
</code></pre>
<p>但是这个函数无法做到与原生的 Object.create 一致，一个是不支持第二个参数，另一个是不支持 null 作为原型，所以意义已经不大了。</p>
<h3 id="ES6中的类与原型"><a href="#ES6中的类与原型" class="headerlink" title="ES6中的类与原型"></a>ES6中的类与原型</h3><p>ES6 中加入了新特性 class，new 跟 function 搭配的怪异行为终于可以退休了。在任何场景，推荐使用 ES6 的语法来定义类，而令 function 回归原本的函数语义。</p>
<p>同时，ES6 中引入了 class 关键字，并且在标准中删除了所有 [[class]] 相关的私有属性描述，类的概念正式从属性升级成语言的基础设施，从此，基于类的编程方式成为了 JavaScript 的官方编程范式。</p>
<p>此外，最重要的是，类提供了继承能力（extends）</p>
<h2 id="JavaScript对象分类"><a href="#JavaScript对象分类" class="headerlink" title="JavaScript对象分类"></a>JavaScript对象分类</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>我们可以把对象分为以下种类：</p>
<ol>
<li>宿主对象（host Objects）：由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。</li>
<li>内置对象（Built-in Objects）：由 JavaScript 语言提供的对象<ul>
<li>固有对象（Intrinsic Objects ）：由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。</li>
<li>原生对象（Native Objects）：可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。  </li>
<li>普通对象（Ordinary Objects）：由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。</li>
</ul>
</li>
</ol>
<p>这里主要介绍处理普通对象之外的其他对象</p>
<h3 id="宿主对象"><a href="#宿主对象" class="headerlink" title="宿主对象"></a>宿主对象</h3><p>JavaScript 宿主对象千奇百怪，但是前端最熟悉的无疑是浏览器环境中的宿主了。浏览器对象中有一个window全局对象，实际上，这个全局对象 window 上的属性，一部分来自 JavaScript 语言，一部分来自浏览器环境。  </p>
<p>宿主对象也分为固有的和用户可创建的两种，比如 document.createElement 就可以创建一些 dom 对象。    </p>
<p>宿主也会提供一些构造器，比如我们可以使用 new Image 来创建 img 元素，这些我们会在浏览器的 API 部分详细讲解。  </p>
<h3 id="内置对象-固有对象"><a href="#内置对象-固有对象" class="headerlink" title="内置对象-固有对象"></a>内置对象-固有对象</h3><p>固有对象是由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。</p>
<p>可以点击<a href="https://www.ecma-international.org/ecma-262/9.0/index.html#sec-well-known-intrinsic-objects">这个链接</a>查看固有对象。</p>
<h3 id="内置对象-原生对象"><a href="#内置对象-原生对象" class="headerlink" title="内置对象-原生对象"></a>内置对象-原生对象</h3><p>我们把 JavaScript 中，能够通过语言本身的构造器创建的对象称作原生对象。在 JavaScript 标准中，提供了 30 多个构造器。按照winter的理解，按照不同应用场景，可以把原生对象分成了以下几个种类：</p>
<p><img src="/4-1.png"><br>通过这些构造器，我们可以用 new 运算创建新的对象，所以我们把这些对象称作原生对象。几乎所有这些构造器的能力都是无法用纯 JavaScript 代码实现的，它们也无法用 class/extend 语法来继承（作者说的不能继承是指无法完全一模一样，只能继承部分方法，具体可以参见<a href="http://es6.ruanyifeng.com/#docs/class-extends#%E5%8E%9F%E7%94%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF">原生构造函数的继承</a>）</p>
<h3 id="特殊行为的对象"><a href="#特殊行为的对象" class="headerlink" title="特殊行为的对象"></a>特殊行为的对象</h3><p>除了上面介绍的对象之外，在固有对象和原生对象中，有一些对象的行为跟正常对象有很大区别。</p>
<ol>
<li>Array：Array 的 length 属性根据最大的下标自动发生变化。</li>
<li>Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。</li>
<li>String：为了支持下标运算，String 的正整数属性访问会去字符串里查找。</li>
<li>Arguments：arguments 的非负整数型下标属性跟对应的变量联动。</li>
<li>模块的 namespace 对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。</li>
<li>类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。</li>
<li>bind 后的 function：跟原来的函数相关联。</li>
</ol>
<h3 id="用对象来模拟函数与构造器：函数对象与构造器对象"><a href="#用对象来模拟函数与构造器：函数对象与构造器对象" class="headerlink" title="用对象来模拟函数与构造器：函数对象与构造器对象"></a>用对象来模拟函数与构造器：函数对象与构造器对象</h3><p>在 JavaScript 中，还有一个看待对象的不同视角，这就是用对象来模拟函数和构造器。  </p>
<p>函数对象的定义是：具有 [[call]] 私有字段的对象; </p>
<p>构造器对象的定义是：具有私有字段 [[construct]] 的对象;</p>
<p>任何对象只需要实现 [[call]]，它就是一个函数对象，可以去作为函数被调用。而如果它能实现 [[construct]]，它就是一个构造器对象，可以作为构造器被调用。</p>
<p>用户用 function 关键字创建的函数必定同时是函数和构造器。不过，它们表现出来的行为效果却并不相同。</p>
<p>对于宿主和内置对象来说，它们实现 [[call]]（作为函数被调用）和 [[construct]]（作为构造器被调用）不总是一致的。比如内置对象 Date 在作为构造器调用时产生新的对象，作为函数时，则产生字符串，见以下代码：</p>
<pre><code>console.log(new Date,typeof new Date); // Tue Mar 05 2019 18:09:07 GMT+0800 (中国标准时间) &quot;object&quot;
console.log( Date(),typeof Date()); // Tue Mar 05 2019 18:09:07 GMT+0800 (中国标准时间) string
</code></pre>
<p>而浏览器宿主环境中，提供的 Image 构造器，则根本不允许被作为函数调用。</p>
<pre><code>console.log(new Image); 
console.log(Image());// 抛出错误
</code></pre>
<p>再比如基本类型（String、Number、Boolean），它们的构造器被当作函数调用，则产生类型转换的效果。</p>
<p>在 ES6 之后 =&gt; 语法创建的函数仅仅是函数，它们无法被当作构造器使用，见以下代码：</p>
<pre><code>new (a =&gt; 0) // error
</code></pre>
<p>对于用户使用 function 语法或者 Function 构造器创建的对象来说，[[call]] 和 [[construct]] 行为总是相似的，它们执行同一段代码。我们大致可以认为，它们 [[construct]] 的执行过程如下：</p>
<ol>
<li>以 Object.protoype 为原型创建一个新对象；</li>
<li>以新对象为 this，执行函数的 [[call]]；</li>
<li>如果 [[call]] 的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。</li>
</ol>
<p>这样的规则造成了个有趣的现象，如果我们的构造器返回了一个新的对象，那么 new 创建的新对象就变成了一个构造函数之外完全无法访问的对象，这一定程度上可以实现“私有”。</p>
<pre><code>function cls()&#123;
  this.a = 100;
  return &#123;
      getValue:() =&gt; this.a
  &#125;
&#125;
var o = new cls();
o.getValue(); //100
//a 在外面永远无法访问到
</code></pre>
<h3 id="JavaScript-全局对象的属性"><a href="#JavaScript-全局对象的属性" class="headerlink" title="JavaScript 全局对象的属性"></a>JavaScript 全局对象的属性</h3><ol>
<li><p>三个值：</p>
<pre><code> Infinity、NaN、undefined。
</code></pre>
</li>
<li><p>九个函数：</p>
<pre><code> eval、isFinite、isNaN、parseFloat、parseInt、decodeURI、decodeURIComponent、
 encodeURI、encodeURIComponent
</code></pre>
</li>
<li><p>一些构造器：  </p>
<pre><code> Array、Date、RegExp、Promise、Proxy、Map、WeakMap、Set、WeapSet、
 Function、Boolean、String、Number、Symbol、Object、Error、EvalError、
 RangeError、ReferenceError、SyntaxError、TypeError
</code></pre>
</li>
<li><p>四个用于当作命名空间的对象：</p>
<pre><code> Atomics、JSON、Math、Reflect
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - JavaScript部分-执行(一)</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-JavaScript%E9%83%A8%E5%88%86-%E6%89%A7%E8%A1%8C(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>由于我们这里主要讲 JavaScript 语言，那么采纳 JSC 引擎的术语，我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。</p>
<span id="more"></span>
<h2 id="宏观和微观任务"><a href="#宏观和微观任务" class="headerlink" title="宏观和微观任务"></a>宏观和微观任务</h2><p>JavaScript 引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在 Node 术语中，也会把这个部分称为事件循环。</p>
<p>在底层的 C/C++ 代码中，这个事件循环是一个跑在独立线程中的循环，我们用伪代码来表示，大概是这样的：</p>
<pre><code>while(TRUE) &#123;
    r = wait();
    execute(r);
&#125;
</code></pre>
<p>可以看到，整个循环做的事情基本上就是反复“等待 - 执行”  </p>
<p>这里每次的执行过程，其实都是一个宏观任务。我们可以大概理解：宏观任务的队列就相当于事件循环。</p>
<p>在宏观任务中，JavaScript 的 Promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列：</p>
<p><img src="11-1.jpg"></p>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API，则会添加宏观任务。</p>
<pre><code>var r = new Promise(function (resolve, reject) &#123;
  console.log(&quot;a&quot;);
  resolve()
&#125;);
setTimeout(()=&gt;&#123;
  console.log(&quot;d&quot;)
&#125;)
r.then(() =&gt; console.log(&quot;c&quot;));
console.log(&quot;b&quot;)
//运行结果依次为：a,b,c,d
</code></pre>
<p>我们再看下面的代码</p>
<pre><code>var r = new Promise(function (resolve, reject) &#123;
  console.log(&quot;a&quot;);
  resolve()
&#125;);

setTimeout(() =&gt; console.log(&quot;d&quot;), 0)
var r1 = new Promise(function (resolve, reject) &#123;
  resolve()
&#125;);

r.then(() =&gt; &#123;
  var begin = Date.now();
  while (Date.now() - begin &lt; 1000);
  console.log(&quot;c1&quot;)
  new Promise(function (resolve, reject) &#123;
    resolve()
  &#125;).then(() =&gt; console.log(&quot;c2&quot;))
&#125;);
//执行结果：a, c1, c2 ,d
</code></pre>
<p>这里我们强制了 1 秒的执行耗时，这样，我们可以确保任务 c2 是在 d 之后被添加到任务队列。可以看到，即使耗时一秒的 c1 执行完毕，再 创建的 c2，仍然先于 d 执行了，这很好地解释了微任务优先的原理。</p>
<p>通过一系列的实验，我们可以总结一下如何分析异步执行的顺序：</p>
<ul>
<li>首先我们分析有多少个宏任务；</li>
<li>在每个宏任务中，分析有多少个微任务；</li>
<li>根据调用次序，确定宏任务中的微任务执行次序；</li>
<li>根据宏任务的触发规则和调用次序，确定宏任务的执行次序；</li>
<li>确定整个顺序。</li>
</ul>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>async函数返回的是 Promise 对象, 一旦遇到await就会先返回(可以通过await来等待一个Promise)，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<pre><code>function sleep(duration) &#123;
    return new Promise(function(resolve, reject) &#123;
    setTimeout(resolve,duration);
    &#125;)
&#125;
async function foo()&#123;
    console.log(&quot;a&quot;)
    await sleep(2000)
    console.log(&quot;b&quot;)
&#125;
foo().then(()=&gt;&#123;
  console.log(&quot;foo over&quot;)
&#125;);
 //执行结果：a, b, foo over
</code></pre>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - JavaScript部分-执行(二)</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-JavaScript%E9%83%A8%E5%88%86-%E6%89%A7%E8%A1%8C(%E4%BA%8C)/</url>
    <content><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包其实<strong>只是一个绑定了执行环境的函数</strong>，闭包与普通函数的区别是，它携带了执行的环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境。</p>
<span id="more"></span>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”。  </p>
<p>执行上下文在 ES2018 中，包含以下部分：</p>
<ul>
<li>lexical environment：词法环境，当获取变量或者 this 值时使用。</li>
<li>variable environment：变量环境，当声明变量时使用</li>
<li>code evaluation state：用于恢复代码执行位置。</li>
<li>Function：执行的任务是函数时使用，表示正在被执行的函数。</li>
<li>ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。</li>
<li>Realm：使用的基础库和内置对象实例。</li>
<li>Generator：仅生成器上下文有这个属性，表示当前生成器。</li>
</ul>
<p>在js中任何语句的执行都会依赖特定的上下文。一旦上下文被切换，整个语句的效果可能都会发生改变。在 JavaScript，切换上下文最主要的场景是函数调用。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote>
<p>补充:仅普通函数和类能够跟 new 搭配使用</p>
</blockquote>
<h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><p>用 function 关键字定义的函数。</p>
<pre><code>function foo()&#123;
    // code
&#125;
</code></pre>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>用 =&gt; 运算符定义的函数。</p>
<pre><code>const foo = () =&gt; &#123;
    // code
&#125;
</code></pre>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>在 class 中定义的函数。</p>
<pre><code>class C &#123;
    foo()&#123;
        //code
    &#125;
    
&#125;
</code></pre>
<h3 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h3><p>用 function * 定义的函数。</p>
<pre><code>function* foo()&#123;
    // code
&#125;
</code></pre>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>用 class 定义的类，实际上也是函数。</p>
<pre><code>class Foo &#123;
    constructor()&#123;
        //code
    &#125;
&#125;
</code></pre>
<h3 id="异步函数："><a href="#异步函数：" class="headerlink" title="异步函数："></a>异步函数：</h3><p>普通函数、箭头函数和生成器函数加上 async 关键字。</p>
<pre><code>async function foo()&#123;
    // code
&#125;


    
const foo = async () =&gt; &#123;
    // code
&#125;


    
async function foo*()&#123;&#123;
    // code
&#125;
</code></pre>
<p>对普通变量而言，这些函数并没有本质区别，它们的一个行为差异在于 this 关键字。</p>
<h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p>this 是执行上下文中很重要的一个组成部分。同一个函数调用方式不同，得到的 this 值也不同。</p>
<p>调用函数时使用的引用，决定了函数执行时刻的 this 值。实际上从运行时的角度来看，this 跟面向对象毫无关联，它是与函数调用时使用的表达式相关。</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><img src="/12-1.jpg"></p>
<h3 id="在-try-中有-return-语句，finally-中的内容还会执行吗？"><a href="#在-try-中有-return-语句，finally-中的内容还会执行吗？" class="headerlink" title="在 try 中有 return 语句，finally 中的内容还会执行吗？"></a>在 try 中有 return 语句，finally 中的内容还会执行吗？</h3><p>代码一：</p>
<pre><code>function foo()&#123;
  try&#123;
    return 0;
  &#125; catch(err) &#123;

  &#125; finally &#123;
    console.log(&quot;a&quot;)
  &#125;
&#125;

console.log(foo()); 
</code></pre>
<p>finally执行了，并且函数有返回值</p>
<p>代码二：</p>
<pre><code>function foo()&#123;
  try&#123;
    return 0;
  &#125; catch(err) &#123;

  &#125; finally &#123;
    return 1;
  &#125;
&#125;

console.log(foo());
</code></pre>
<p>返回值为1，<code>try</code>的返回值被 <code>finally</code> 擦写了</p>
<p>这个怪异的表现行为是由于 Javascript 的Completion Record机制来实现的（Completion Record用于描述异常、跳出等语句执行过程）</p>
<p>Completion Record 表示一个语句执行完之后的结果，它有三个字段：</p>
<ul>
<li>[[type]] 表示完成的类型，有 break continue return throw 和 normal 几种类型；</li>
<li>[[value]] 表示语句的返回值，如果语句没有，则是 empty；</li>
<li>[[target]] 表示语句的目标，通常是一个 JavaScript 标签。</li>
</ul>
<p>普通语句执行后，会得到 [[type]] 为 normal 的 Completion Record，JavaScript 引擎遇到这样的 Completion Record，会继续执行下一条语句。</p>
<p>在一个语句块中，，如果每一个语句都是 normal 类型，那么它会顺次执行。但是假如我们在语句块中插入了一条 return 语句，产生了一个非 normal 记录，那么整个语句块会成为非 normal。这个结构就保证了非 normal 的完成类型可以穿透复杂的语句嵌套结构，产生控制效果。</p>
<p>那么对于上述的例子：因为 finally 中的内容必须保证执行，所以 try/catch 执行完毕，即使得到的结果是非 normal 型的完成记录，也必须要执行 finally。而当 finally 执行也得到了非 normal 记录，则会使 finally 中的记录作为整个 try 结构的结果。</p>
<h3 id="带标签的语句"><a href="#带标签的语句" class="headerlink" title="带标签的语句"></a>带标签的语句</h3><p>实际上，任何 JavaScript 语句是可以加标签的，在语句前加冒号即可：</p>
<pre><code> firstStatement: var i = 1;
</code></pre>
<p>一般情况下没什么用，break/continue 语句如果后跟了lable语句，就会跳到对应的label位置，一般用于多层嵌套循环的跳出</p>
<pre><code>var num=0;
outter:
for(var i=0;i&lt;10;i++)&#123;
    for(var j=0;j&lt;10;j++)&#123;
        if(i==5&amp;&amp;j==5)&#123;
            break outter;    //退出内部循环，指向outter，即外循环，同时退出外循环
        &#125;
        num++;
    &#125;
&#125;
document.write(num);   //55
</code></pre>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - JavaScript部分-数据类型</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-JavaScript%E9%83%A8%E5%88%86-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>根据最新的语言标准，js共有七种语言类型：</p>
<ol>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>Object</li>
<li>Symbol</li>
</ol>
<span id="more"></span>
<h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p>Undefined 类型表示未定义，它的类型只有一个值，就是 undefined。任何变量在赋值前是 Undefined 类型、值为 undefined，但是，因为 JavaScript 的代码 undefined 是一个变量，而并非是一个关键字(这是 JavaScript 语言公认的设计失误之一)，在低版本中可以被纂改：</p>
<pre><code>var undefinedBackup = undefined;
undefined = 1;

console.log(typeof undefinedBackup);// 显示&quot;undefined&quot;

console.log(typeof undefined);// 在IE5.5~8中显示&quot;number&quot;，其他浏览器中则显示&quot;undefined&quot;
</code></pre>
<p>所以，我们为了避免无意中被篡改，我建议使用 void 0 来获取 undefined 值。</p>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>Null 类型也只有一个值，就是 null，它的语义表示空值，与 undefined 不同，null 表示的是：“定义了但是为空”。同时null 是 JavaScript 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。<br>但是有时候null会被当作一种对象类型，这是语言本身设计缺陷：<code>typeof null === &#39;object&#39;</code>，究其原因是因为：</p>
<pre><code>不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。
</code></pre>
<p>因为Undefined 类型与 Null 类型的值也对应只有一个（undefined/null），所以在有些代码中也直接通过判断值来判断类型：</p>
<pre><code>var obj;
console.log(obj===undefined);//true
console.log(Object.prototype.__proto__===null);// true
</code></pre>
<p>undefined 值是派生自 null 值的，因此 ECMA-262 规定对它们的相等性测试要返回 true：</p>
<pre><code>console.log(null==undefined);// true
console.log(null===undefined);// false
</code></pre>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String 用于表示文本数据。String 有最大长度是 2^53 - 1，这在一般开发中都是够用的，但这个所谓最大长度，并不完全是我们理解中的字符数。因为 String 的意义并非“字符串”，而是字符串的 UTF16 编码，我们字符串的操作 charAt、charCodeAt、length 等方法针对的都是 UTF16 编码。所以，字符串的最大长度，实际上是受字符串的编码长度影响的。</p>
<h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><p>布尔类型有两个值：true和false，其他不做赘述。</p>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>JavaScript 中有 +0 和 -0，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分，“忘记检测除以 -0，而得到负无穷大”的情况经常会导致错误，而区分 +0 和 -0 的方式，正是检测 1/x 是 Infinity 还是 -Infinity。</p>
<p>补充:ES6中增加了Object.is来判断两个数值是否相等（解决正负零和NaN的问题，其他等同于<code>===</code>）</p>
<pre><code> +0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
</code></pre>
<p>因为 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，所以对于浮点数运算会存在精度问题：</p>
<pre><code>console.log( 0.1 + 0.2 == 0.3);//false
</code></pre>
<p>但是 </p>
<pre><code>console.log( 0.3 + 0.2 == 0.5);//true
</code></pre>
<p>原因：</p>
<pre><code>1. 因为十进制转二进制的小数部分的原则是乘2取整顺序表达，这边会发现0.1 0.2 0.3这三个数都不能有限表达，会产生无限位数。
2 .固定位数二进制无法表示无限循环序列（截断部分会进行进位或者舍去，这边会产生误差）
</code></pre>
<p>那么如何正确比较浮点数：</p>
<pre><code>  console.log( Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON); //true Number.EPSILON表示js的最小精度
</code></pre>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>ES5 的对象属性名都是字符串，很容易产生冲突。Symbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合，在 ES6 规范中，整个对象系统被用 Symbol 重塑。</p>
<p>我们创建 Symbol 的方式是使用全局的 Symbol 函数（无法通过字面量方式创建）。</p>
<p>ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性上，所以可以通过Symbol.iterator来定义 for..of在对象上的行为。</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>Object 是 JavaScript 中最复杂的类型，也是 JavaScript 的核心机制之一。  </p>
<p>在 JavaScript 中，对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是 key-value 结构，key 可以是字符串或者 Symbol 类型。</p>
<p>JavaScript 中的六个基本类型，有四个都在对象类型中有一个“亲戚”（包装类型）。它们是： Number,String,Boolean,Symbol（null 与 undefined 表示不知道你们在说什么）：</p>
<ul>
<li>Number、String 和 Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。<pre><code>  new String() instanceof String;//true
  new String instanceof String;//true, 
  //参见《js高级程序设计》--3.4.7 Object 类型章节，new关键字后面构造函数可以省略括号，但是不推荐
  new Boolean() instanceof Boolean;//true
  new Number() instanceof Number;//true
  // 补充：String() 和运算符 new 一起作为构造函数使用时，它返回一个新创建的 String 对象,存放的是字符串 s 或 s 的字符串表示。
  // 当不用 new 运算符调用 String() 时，它只把 s 转换成原始的字符串，并返回转换后的值
</code></pre>
</li>
</ul>
<p>当不用 new 运算符调用 String() 时，它只把 s 转换成原始的字符串，并返回转换后的值</p>
<ul>
<li><p>Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。</p>
<pre><code>// 我们无法通过new 调用来得到一个Symbol对象，可以利用call强制进行装箱
var symbolObject = (function()&#123; return this; &#125;).call(Symbol(&quot;a&quot;));
console.log(typeof symbolObject); //object
console.log(symbolObject instanceof Symbol); //true
console.log(symbolObject.constructor == Symbol); //true
</code></pre>
</li>
</ul>
<p><img src="./1.png"><br>JavaScript 语言设计上试图模糊对象和基本类型之间的关系，我们日常代码可以把对象的方法在基本类型上使用，比如：</p>
<pre><code>console.log(&quot;abc&quot;.charAt(0)); //a
</code></pre>
<p>甚至我们在原型上添加方法，都可以应用于基本类型，比如以下代码，在 Symbol 原型上添加了 hello 方法，在任何 Symbol 类型变量都可以调用。</p>
<pre><code>Symbol.prototype.hello = () =&gt; console.log(&quot;hello&quot;);

var a = Symbol(&quot;a&quot;);
console.log(typeof a); //symbol，a 并非对象
  a.hello(); //hello，有效
</code></pre>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>  <img src="/3-1.jpg"></p>
<h3 id="StringToNumber"><a href="#StringToNumber" class="headerlink" title="StringToNumber"></a>StringToNumber</h3><pre><code>parseInt(&quot;1.1&quot;);//1
parseFloat(&quot;1.1&quot;);//1.1
Math.floor(&quot;1000&quot;);//1000
Math.round(&quot;1000&quot;);//1000
Math.ceil(&quot;1000&quot;);//1000
+&quot;1000&quot;;//1000
&quot;1000&quot;&gt;&gt;&gt;0;//1000
&quot;1000&quot;*1;//1000
 Number(&quot;1000);//1000
</code></pre>
<h3 id="NumberToString"><a href="#NumberToString" class="headerlink" title="NumberToString"></a>NumberToString</h3><pre><code>(2.2).toFixed();//&quot;2.2&quot;
(2.2).toString();//&quot;2.2&quot;
(2.2).toLocaleString();//&quot;2.2&quot;
(2.2)+&#39;&#39;;//&quot;2.2&quot;
String(2.2);//&quot;2.2&quot;
</code></pre>
<h3 id="装箱转换"><a href="#装箱转换" class="headerlink" title="装箱转换"></a>装箱转换</h3><p>每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象。<code>.</code>运算符提供了装箱操作。  </p>
<p>每一类装箱对象皆有私有的 Class 属性，这些属性可以用 Object.prototype.toString 获取：</p>
<pre><code>var symbolObject = Object(Symbol(&quot;a&quot;));

console.log(Object.prototype.toString.call(symbolObject)); //[object Symbol]
</code></pre>
<p>它可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。</p>
<h3 id="拆箱转换"><a href="#拆箱转换" class="headerlink" title="拆箱转换"></a>拆箱转换</h3><p>在 JavaScript 标准中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）。  </p>
<p>对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。</p>
<p>拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。</p>
<pre><code>var o = &#123;
    valueOf : () =&gt; &#123;console.log(&quot;valueOf&quot;); return &#123;&#125;&#125;,
    toString : () =&gt; &#123;console.log(&quot;toString&quot;); return &#123;&#125;&#125;
&#125;

o * 2
// valueOf
// toString
// TypeError: Cannot convert object to primitive value
</code></pre>
<p>到 String 的拆箱转换会优先调用 toString。我们把刚才的运算从 o*2 换成 o + “”，那么你会看到调用顺序就变了：</p>
<pre><code>var o = &#123;
    valueOf : () =&gt; &#123;console.log(&quot;valueOf&quot;); return &#123;&#125;&#125;,
    toString : () =&gt; &#123;console.log(&quot;toString&quot;); return &#123;&#125;&#125;
&#125;

o + &quot;&quot;
// toString
// valueOf
// TypeError
</code></pre>
<p>在 ES6 之后，还允许对象通过显式指定 <code>Symbol.toPrimitive</code>属性来覆盖原有的行为。</p>
<pre><code>var o = &#123;
    valueOf : () =&gt; &#123;console.log(&quot;valueOf&quot;); return &#123;&#125;&#125;,
    toString : () =&gt; &#123;console.log(&quot;toString&quot;); return &#123;&#125;&#125;
&#125;

o[Symbol.toPrimitive] = () =&gt; &#123;console.log(&quot;toPrimitive&quot;); return &quot;hello&quot;&#125;


console.log(o + &quot;&quot;)
// toPrimitive
// hello
</code></pre>
<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>事实上，“类型”在 JavaScript 中是一个有争议的概念。一方面，标准中规定了运行时数据类型； 另一方面，JS 语言中提供了 typeof 这样的运算，用来返回操作数的类型，但 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。我们可以看下表来对照一下。</p>
<p><img src="/3-2.png"></p>
<p>从一般语言使用者的角度来看，毫无疑问，我们应该按照 typeof 的结果去理解语言的类型系统。但 JS 之父本人也在多个场合表示过，typeof 的设计是有缺陷的，只是现在已经错过了修正它的时机。</p>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - JavaScript部分-词法</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-JavaScript%E9%83%A8%E5%88%86-%E8%AF%8D%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们都知道JS是一种“解释执行”的语言，不同于c++等语言的提前编译，它的编译过程是在JS引擎中完成的（代码执行前进行编译），更多内容可参考：<a href="/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E7%B3%BB%E5%88%97-1/#more">你不知道的JS系列-1</a>  </p>
<p>对于所有需要编译的语言来说，都需要提前指定一些规则来设计语言，这些规则就可以称之为“文法”。  </p>
<p>文法是编译原理中对语言的写法的一种规定，一般来说，文法分成词法和语法两种。词法规定了语言的最小语义单元：token，可以翻译成“标记”或者“词”。这里我们统一称为“词”，</p>
<p>我们把视角再转回到JS身上：所有源码中出现的内容包括了：空白符号、换行符、注释、标识符名称、符号、数字直接量、字符串直接量、正则表达式直接量、字符串模板。接下来，编译器在代码执行前就需要对这些内容进行语法分析（拆词）</p>
<h2 id="几点说明"><a href="#几点说明" class="headerlink" title="几点说明"></a>几点说明</h2><ol>
<li>Javascript支持多种空白符号</li>
<li>Javascript只支持四种字符作为换行符</li>
<li>Javascript支持单行注释与多行注释</li>
<li>Javascript中的标识符名称可以以“$”、“_”或者 Unicode 字母开始</li>
<li>Javascript中的字符串直接量支持单引号和多引号两种</li>
<li>Javascript中‘/’不仅可以作为除法，也可以作为正则表达式，所以词法分析器需要两套词法</li>
<li>Javascript中模板字符串也需要单独的词法来处理</li>
<li>Javascript支持数字直接量，不过对于<code>12.toString()</code>这种写法要人为处理，否则默认词法会将<code>12.</code>划分为一个“token”,从而引发异常</li>
</ol>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端-JavaScript部分-语法(一)</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-JavaScript%E9%83%A8%E5%88%86-%E8%AF%AD%E6%B3%95(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文我们开始介绍语法部分相关内容</p>
<span id="more"></span>

<h2 id="脚本与模块"><a href="#脚本与模块" class="headerlink" title="脚本与模块"></a>脚本与模块</h2><p>ES6之前，JS中只有一种源文件，称之为脚本；ES6之后，出现了另外一种源文件，称之为：模块</p>
<h3 id="模块的使用"><a href="#模块的使用" class="headerlink" title="模块的使用"></a>模块的使用</h3><p>我们可以在script标签中加入<code>type=&quot;module&quot;</code> 属性，这时候加载的文件就是模块，反之则为脚本</p>
<pre><code>  &lt;script type=&quot;module&quot; src=&quot;xxxxx.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>在脚本文件中我们可以使用import声明与export声明</p>
<p><img src="./2.jpg"></p>
<p>关于import 与 export的用法可以参考<a href="/ES6%E7%B3%BB%E5%88%97-5-Class%E4%B8%8EModule/">ES6系列-5-Class与Module</a></p>
<h3 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h3><p>宏任务中可能会执行的代码包括“脚本”、“模块”和“函数体”，函数体其实也是一个语句的列表。跟脚本和模块比起来，函数体中的语句列表中多了 return 语句可以用，函数体实际上有四种，下图做了对比</p>
<p><img src="./3.jpg"></p>
<h2 id="JS语法的全局机制"><a href="#JS语法的全局机制" class="headerlink" title="JS语法的全局机制"></a>JS语法的全局机制</h2><p> JavaScript 语法的全局机制：预处理和指令序言，这两个机制对于我们解释一些 JavaScript 的语法现象非常重要</p>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>JavaScript 执行前，会对脚本、模块和函数体中的语句进行预处理。预处理过程将会提前处理 var、函数声明、class、const 和 let 这些语句，以确定其中变量的意义。</p>
<h4 id="var-声明"><a href="#var-声明" class="headerlink" title="var 声明"></a>var 声明</h4><p>在预处理阶段，var 的作用能够穿透一切语句结构（包括<code>if(false)</code>也无法阻挡），它只认脚本、模块和函数体三种语法结构。在ES6出现之前，为了模拟函数作用域，经常使用IIFE</p>
<h4 id="function-声明"><a href="#function-声明" class="headerlink" title="function 声明"></a>function 声明</h4><p>在全局（脚本、模块和函数体），function 声明表现跟 var 相似，不同之处在于，function 声明不但在作用域中加入变量，还会给它赋值：</p>
<pre><code>console.log(foo); // 打印出函数体
function foo()&#123;&#125;
</code></pre>
<p>如果出现在<code>if(false)</code>下，仍然会产生变量，只是不会被提前赋值</p>
<pre><code>console.log(foo); // undefined 
if(true) &#123;
    function foo()&#123;&#125; // 如果没有此处代码，上面console部分会报错
&#125;
</code></pre>
<h4 id="class-声明"><a href="#class-声明" class="headerlink" title="class 声明"></a>class 声明</h4><p>class 声明在全局的行为跟 function 和 var 都不一样</p>
<p>提前使用会报错，这符合正常预期</p>
<pre><code>console.log(c); // 报错 Uncaught ReferenceError: c is not defined
class c&#123;&#125;
</code></pre>
<p>但下面这种情况仍然会报错</p>
<pre><code>var c = 1;
function foo()&#123;
    console.log(c); // ReferenceError: Cannot access &#39;c&#39; before initialization
    class c &#123;&#125;
&#125;
foo();
</code></pre>
<p>这说明，class 声明也是会被预处理的，它会在作用域中创建变量，并且要求访问它时抛出错误。class 的声明作用不会穿透 if 等语句结构，所以只有写在全局环境才会有声明作用</p>
<h3 id="指令序列"><a href="#指令序列" class="headerlink" title="指令序列"></a>指令序列</h3><p>脚本和模块都支持一种特别的语法，叫做指令序言（Directive Prologs）。的目的是留给 JavaScript 的引擎和实现者一些统一的表达方式，在静态扫描时指定 JavaScript 代码的一些特性。</p>
<p>“use strict”是 JavaScript 标准中规定的唯一一种指令序言</p>
<h2 id="自动插入分号规则"><a href="#自动插入分号规则" class="headerlink" title="自动插入分号规则"></a>自动插入分号规则</h2><p>因为JavaScript 语言提供了相对可用的分号自动补全规则，所以很多开发者倾向于不写分号。<br>分号自动补全规则有三条：</p>
<ul>
<li>有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。</li>
<li>有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。</li>
<li>源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。</li>
</ul>
<p>但在实际应用中，还有一个no LineTerminator here 规则：表示它所在的结构中的这一位置不能插入换行符</p>
<p><img src="./1.jpg"></p>
<p>举个例子：</p>
<pre><code>function foo()&#123;
  return 
  1
&#125;
foo(); // undefined;
</code></pre>
<p>上面例子中，根据no LineTerminator here规则，return后面不能插入换行符，但现在存在换行符，那个一句分号自动补全规则的第二条：<code>有换行符，且语法中规定此处不能有换行符，那么就自动插入分号</code>，引擎会在return后面直接插入分号，那么执行结果就不难理解了。</p>
<p>日常开发中还会出现几种不写分号，极易造成错误的情况：</p>
<ul>
<li><p>以括号开头的语句</p>
<pre><code>(function(a)&#123;
    console.log(a);
&#125;)()/*这里没有被自动插入分号*/
(function(a)&#123;
    console.log(a);
&#125;)()
</code></pre>
</li>
<li><p>以数组开头的语句</p>
<pre><code>var a = [[]]/*这里没有被自动插入分号*/
[3, 2, 1, 0].forEach(e =&gt; console.log(e))
</code></pre>
</li>
<li><p>以正则表达式开头的语句</p>
<pre><code>var x = 1, g = &#123;test:()=&gt;0&#125;, b = 1/*这里没有被自动插入分号*/
/(a)/g.test(&quot;abc&quot;)
console.log(RegExp.$1)
</code></pre>
</li>
<li><p>以模板字符串开头的语句</p>
<pre><code>var f = function()&#123;
  return &quot;&quot;;
&#125;
var g = f/*这里没有被自动插入分号*/
`Template`.match(/(a)/);
console.log(RegExp.$1)
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端-JavaScript部分-语法(二)</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-JavaScript%E9%83%A8%E5%88%86-%E8%AF%AD%E6%B3%95(%E4%BA%8C)/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JavaScript 遵循了一般编程语言的“语句 - 表达式”结构，多数编程语言都是这样设计的。本章我们学习下语句与表达式</p>
<span id="more"></span>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>在 JavaScript 标准中，把语句分成了两种：声明和语句。可进行如下分类<br><img src="./1.png"><br><img src="./2.jpg"></p>
<p>下面介绍几种语句：</p>
<h3 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h3><p>语句块就是一对大括号,且会产生作用域</p>
<h3 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h3><p>空语句就是一个独立的分号，实际上没什么大用。</p>
<h3 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h3><p>with 语句是个非常巧妙的设计，但它把 JavaScript 的变量引用关系变得不可分析，所以一般都认为这种语句都属于糟粕</p>
<pre><code>let o = &#123;a:1, b:2&#125;
with(o)&#123;
    console.log(a, b);
&#125;
</code></pre>
<h3 id="try语句和throw语句"><a href="#try语句和throw语句" class="headerlink" title="try语句和throw语句"></a>try语句和throw语句</h3><p>try 语句和 throw 语句用于处理异常。一般来说，throw 用于抛出异常，但是单纯从语言的角度，我们可以抛出任何值，但是不建议这样使用</p>
<pre><code>try &#123;
    throw new Error(&quot;error&quot;);
&#125; catch(e) &#123;
    console.log(e);
&#125; finally &#123;
    console.log(&quot;finally&quot;);
&#125;
</code></pre>
<h2 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h2><p>上面讲到了很多种语句类型，但是，其实最终产生执行效果的语句不多。事实上，真正能干活的就只有表达式语句，其它语句的作用都是产生各种结构，来控制表达式语句执行，或者改变表达式语句的意义。下面介绍下都有哪些表达式（语句）</p>
<h3 id="Primary-Expression-主要表达式"><a href="#Primary-Expression-主要表达式" class="headerlink" title="Primary Expression 主要表达式"></a>Primary Expression 主要表达式</h3><p>Primary Expression。它是表达式的最小单位，它所涉及的语法结构也是优先级最高的，包含了各种直接量，如数字123，字符串hello world等。<br>同时，任何表达式加上圆括号，都被认为是 Primary Expression，这个机制使得圆括号成为改变运算优先顺序的手段</p>
<pre><code>(&#123;&#125;);
(function()&#123;&#125;);
(class&#123; &#125;);
[];
/abc/g;
this;
</code></pre>
<p>以上都可以理解为直接量</p>
<h3 id="Member-Expression-成员表达式"><a href="#Member-Expression-成员表达式" class="headerlink" title="Member Expression 成员表达式"></a>Member Expression 成员表达式</h3><p>Member Expression 通常是用于访问对象成员</p>
<pre><code>a.b;
a[&quot;b&quot;];
new.target; //用于判断函数是否是被 new 调用
super.b;    //构造函数中，用于访问父类的属性的语法
</code></pre>
<p>带函数的模板也被当做 Member Expression</p>
<p>   fn<code>a$&#123;b&#125;c</code> // 等同于 fn({0:[‘a’,’c’],1:b的值})</p>
<p>带参数列表的 new 运算也被当做 Member Expression（不带参数的不是）</p>
<p>   new Cls();</p>
<h3 id="NewExpression-NEW-表达式"><a href="#NewExpression-NEW-表达式" class="headerlink" title="NewExpression NEW 表达式"></a>NewExpression NEW 表达式</h3><p>Member Expression 加上 new 就是 New Expression，注意此处的New Expression没有参数列表</p>
<pre><code>  new Cls
  new new Cls(1) //等同 new (new Cls(1))
</code></pre>
<h3 id="CallExpression-函数调用表达式"><a href="#CallExpression-函数调用表达式" class="headerlink" title="CallExpression 函数调用表达式"></a>CallExpression 函数调用表达式</h3><p>Member Expression 还能构成 Call Expression，基本形式就是Member Expression + 参数</p>
<pre><code>a.b(c)(d)(e);
a.b(c)[3];
a.b(c).d;
a.b(c)`xyz`;
</code></pre>
<h3 id="LeftHandSideExpression-左值表达式"><a href="#LeftHandSideExpression-左值表达式" class="headerlink" title="LeftHandSideExpression 左值表达式"></a>LeftHandSideExpression 左值表达式</h3><p>NewExpression 和 CallExpression 都属于LeftHandSideExpression。左值表达式就是可以放到等号左边的表达式</p>
<h3 id="AssignmentExpression-赋值表达式"><a href="#AssignmentExpression-赋值表达式" class="headerlink" title="AssignmentExpression 赋值表达式"></a>AssignmentExpression 赋值表达式</h3><p>赋值表达式很常见，同时他还有一些其他写法</p>
<pre><code>a = b = c = d  // 向右结合 a = (b = (c = d))
a += b
</code></pre>
<h3 id="Expression表达式"><a href="#Expression表达式" class="headerlink" title="Expression表达式"></a>Expression表达式</h3><p>在 JavaScript 中，表达式就是用逗号运算符连接的赋值表达式：</p>
<p>   a=b,b=1,null;</p>
<p>在 JavaScript 中，比赋值运算优先级更低的就是逗号运算符了。我们可以把逗号可以理解为一种小型的分号</p>
<h3 id="更新表达式-UpdateExpression"><a href="#更新表达式-UpdateExpression" class="headerlink" title="更新表达式 UpdateExpression"></a>更新表达式 UpdateExpression</h3><p>左值表达式搭配 ++ – 运算符，可以形成更新表达式。他会改变左值表达式的值</p>
<pre><code>  -- a;
  ++ a;
  a --
  a ++
</code></pre>
<h3 id="一元运算表达式-UnaryExpression"><a href="#一元运算表达式-UnaryExpression" class="headerlink" title="一元运算表达式 UnaryExpression"></a>一元运算表达式 UnaryExpression</h3><p>更新表达式搭配了一个一元运算符可以形成一元运算表达式</p>
<pre><code>delete a.b;
void a;
typeof a;
- a;
~ a;
! a;
await a;
</code></pre>
<h3 id="乘方表达式-ExponentiationExpression"><a href="#乘方表达式-ExponentiationExpression" class="headerlink" title="乘方表达式 ExponentiationExpression"></a>乘方表达式 ExponentiationExpression</h3><p>乘方表达式也是由更新表达式构成的。它使用**号</p>
<pre><code>++i ** 30
2 ** 30 //正确
-2 ** 30 //报错 -(2 ** 30) 就可以了
</code></pre>
<h3 id="乘法表达式-MultiplicativeExpression"><a href="#乘法表达式-MultiplicativeExpression" class="headerlink" title="乘法表达式 MultiplicativeExpression"></a>乘法表达式 MultiplicativeExpression</h3><p>这里面包含：乘法，除法，求余</p>
<pre><code>x * 2
x / 2
x % 2
</code></pre>
<h3 id="加法表达式-AdditiveExpression"><a href="#加法表达式-AdditiveExpression" class="headerlink" title="加法表达式 AdditiveExpression"></a>加法表达式 AdditiveExpression</h3><p>这里面包含：加法，减法</p>
<pre><code>x + 1
x - 1
</code></pre>
<h3 id="移位表达式-ShiftExpression"><a href="#移位表达式-ShiftExpression" class="headerlink" title="移位表达式 ShiftExpression"></a>移位表达式 ShiftExpression</h3><p>移位是一种位运算，包含：向左移动（<code>&lt;&lt;</code>）,向右移动（<code>&gt;&gt;</code>），无符号向右移动（<code>&gt;&gt;&gt;</code>）</p>
<p>PS：在 JavaScript 中，二进制操作整数并不能提高性能，移位运算这里也仅仅作为一种数学运算存在。</p>
<h3 id="关系表达式-RelationalExpression"><a href="#关系表达式-RelationalExpression" class="headerlink" title="关系表达式 RelationalExpression"></a>关系表达式 RelationalExpression</h3><p>关系运算包含</p>
<pre><code>  &lt;=   //小于等于
  &gt;=   //大于等于
  &lt;    //小于
  &gt;    // 大于
  instanceof // 检测目标是否为指定实例
  in // 检测属性是否存在目标及其原型链上
</code></pre>
<p>并且，此处的<code>&lt;=</code>与<code>&gt;=</code>针对的完全是数字类型，不等价于<code>&lt;</code>或<code>==</code></p>
<pre><code>  null &lt;= undefined  // false
  null == undefined  // true
</code></pre>
<h3 id="相等表达式-EqualityExpression"><a href="#相等表达式-EqualityExpression" class="headerlink" title="相等表达式 EqualityExpression"></a>相等表达式 EqualityExpression</h3><p>相等表达式由四种运算符和关系表达式构成，四种运算符包含</p>
<pre><code>  ==
  !=
  ===
  !==
</code></pre>
<p>关于<code>==</code>运算符，有许多不太符合直觉的地方，我们可以牢记以下三条规则</p>
<ul>
<li>undefined 与 null 相等；</li>
<li>字符串和 bool 都转为数字再比较</li>
<li>对象转换成 primitive 类型再比较</li>
</ul>
<h3 id="位运算表达式"><a href="#位运算表达式" class="headerlink" title="位运算表达式"></a>位运算表达式</h3><p>位运算包含三种：按位与（<code>&amp;</code>）、按位或（<code>|</code>）、按位异或（<code>^</code>）</p>
<h3 id="逻辑与-或表达式"><a href="#逻辑与-或表达式" class="headerlink" title="逻辑与/或表达式"></a>逻辑与/或表达式</h3><p>逻辑运算包含两种：逻辑与（<code>&amp;&amp;</code>）和逻辑或（<code>||</code>）<br>逻辑表达式具有短路特性</p>
<h3 id="条件表达式-ConditionalExpression"><a href="#条件表达式-ConditionalExpression" class="headerlink" title="条件表达式 ConditionalExpression"></a>条件表达式 ConditionalExpression</h3><p>条件运算符又称三目运算符</p>
<pre><code>x ? a : b
</code></pre>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - 前端知识架构图</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对于任何计算机语言来说，必定是“<strong>用一定的词法和语法，表达一定语义，从而操作运行时。</strong>”的一个过程。而程序 = 算法 + 数据结构。</p>
<span id="more"></span>

<h2 id="知识体系"><a href="#知识体系" class="headerlink" title="知识体系"></a>知识体系</h2><p><img src="1-1.jpg"></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://blog.csdn.net/zhouhao88410234/article/details/71190691">文法、语法和词法的解释</a></li>
</ol>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>知识架构图</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - 浏览器部分-CSSDOM</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-%E6%B5%8F%E8%A7%88%E5%99%A8%E9%83%A8%E5%88%86-CSSDOM/</url>
    <content><![CDATA[<h2 id="CSSOM-API-的基本用法"><a href="#CSSOM-API-的基本用法" class="headerlink" title="CSSOM API 的基本用法"></a>CSSOM API 的基本用法</h2><p>一般来说，我们需要先获取文档中所有的样式表：</p>
<pre><code>document.styleSheets
</code></pre>
<p>document 的 styleSheets 属性表示文档中的所有样式表，这是一个只读的列表，我们可以用方括号运算符下标访问样式表，也可以使用 item 方法来访问，它有 length 属性表示文档中的样式表数量。</p>
<p>重学前端-CSS部分-CSSDOM</p>
<span id="more"></span>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>我们虽然无法用 CSSOM API 来创建样式表，但是我们可以修改样式表中的内容（数字参数表示索引）。</p>
<pre><code>document.styleSheets[0].insertRule(&quot;div &#123;border:1px solid blue&#125;&quot;,0)  

document.styleSheets[0].removeRule(5)
</code></pre>
<p>执行后，页面样式会发生对应变化，但并不会在style标签对应的位置真的插入样式代码。</p>
<h3 id="cssRules属性"><a href="#cssRules属性" class="headerlink" title="cssRules属性"></a>cssRules属性</h3><p>更进一步，我们可以获取样式表中特定的规则（Rule），并且对它进行一定的操作，具体来说，就是使用它的 cssRules 属性来实现：</p>
<p><img src="19-2.png"></p>
<p>在chrome上测试发现，link标签引入的css文件样式，cssRules无法读取，因此也无法操作（insertRule，removeRule等无效），只可以操作style标签内的内联样式。</p>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>CSSOM 还提供了一个非常重要的方法，来获取一个元素最终经过 CSS 计算得到的属性：</p>
<pre><code>window.getComputedStyle(elt, pseudoElt);
</code></pre>
<p>其中第一个参数就是我们要获取属性的元素，第二个参数是可选的，用于选择伪元素。</p>
<h2 id="CSSOM-View"><a href="#CSSOM-View" class="headerlink" title="CSSOM View"></a>CSSOM View</h2><h3 id="窗口API"><a href="#窗口API" class="headerlink" title="窗口API"></a>窗口API</h3><p>窗口 API 用于操作浏览器窗口的位置、尺寸等（方法在window下调用）。</p>
<pre><code>moveTo(x, y) 窗口移动到屏幕的特定坐标；
moveBy(x, y) 窗口移动特定距离；
resizeTo(x, y) 改变窗口大小到特定尺寸；
resizeBy(x, y) 改变窗口大小特定尺寸。
</code></pre>
<p>还规定了 window.open() 的第三个参数：</p>
<pre><code>window.open(&quot;about:blank&quot;, &quot;_blank&quot; ,&quot;width=100,height=100,left=100,right=100&quot; )
</code></pre>
<p>一些浏览器出于安全考虑没有实现，也不适用于移动端浏览器，简单了解即可</p>
<h3 id="滚动-API"><a href="#滚动-API" class="headerlink" title="滚动 API"></a>滚动 API</h3><h4 id="视口滚动-API"><a href="#视口滚动-API" class="headerlink" title="视口滚动 API"></a>视口滚动 API</h4><p>可视区域（视口）滚动行为由 window 对象上的一组 API 控制，我们先来了解一下：</p>
<pre><code>scrollX 是视口的属性，表示 X 方向上的当前滚动距离，有别名 pageXOffset；
scrollY 是视口的属性，表示 Y 方向上的当前滚动距离，有别名 pageYOffset；
scroll(x, y) 使得页面滚动到特定的位置，有别名 scrollTo，支持传入配置型参数 &#123;top, left&#125;；
scrollBy(x, y) 使得页面滚动特定的距离，支持传入配置型参数 &#123;top, left&#125;。
</code></pre>
<p>通过这些属性和方法，我们可以读取视口的滚动位置和操纵视口滚动。不过，要想监听视口滚动事件，我们需要在 document 对象上绑定事件监听函数：</p>
<pre><code>document.addEventListener(&quot;scroll&quot;, function(event)&#123;    
  //......    
&#125;)
</code></pre>
<p>视口滚动 API 是页面的顶层容器的滚动，大部分移动端浏览器都会采用一些性能优化，它和元素滚动不完全一样。</p>
<h4 id="元素滚动-API"><a href="#元素滚动-API" class="headerlink" title="元素滚动 API"></a>元素滚动 API</h4><p>在 Element 类（参见 DOM 部分），为了支持滚动，加入了以下 API。</p>
<pre><code>scrollTop 元素的属性，表示 Y 方向上的当前滚动距离。
scrollLeft 元素的属性，表示 X 方向上的当前滚动距离。
scrollWidth 元素的属性，表示元素内部的滚动内容的宽度，一般来说会大于等于元素宽度。
scrollHeight 元素的属性，表示元素内部的滚动内容的高度，一般来说会大于等于元素高度。
scroll(x, y) 使得元素滚动到特定的位置，有别名 scrollTo，支持传入配置型参数 &#123;top, left&#125;。
scrollBy(x, y) 使得元素滚动到特定的位置，支持传入配置型参数 &#123;top, left&#125;。
scrollIntoView(arg) 滚动元素所在的父元素，使得元素滚动到可见区域，可以通过 arg 来指定滚到中间、开始或者就近。
</code></pre>
<p>除此之外，可滚动的元素也支持 scroll 事件，我们在元素上监听它的事件即可：</p>
<pre><code>element.addEventListener(&quot;scroll&quot;, function(event)&#123;    
  //......    
&#125;)
</code></pre>
<h3 id="布局-API"><a href="#布局-API" class="headerlink" title="布局 API"></a>布局 API</h3><h4 id="全局尺寸信息"><a href="#全局尺寸信息" class="headerlink" title="全局尺寸信息"></a>全局尺寸信息</h4><p>window 对象上提供了一些全局的尺寸信息，它是通过属性来提供的:</p>
<p><img src="19-3.png"></p>
<ul>
<li><p>window.innerHeight, window.innerWidth 这两个属性表示视口的大小。</p>
</li>
<li><p>window.outerWidth, window.outerHeight 这两个属性表示浏览器窗口占据的大小，很多浏览器没有实现，一般来说这两个属性无关紧要。</p>
</li>
<li><p>window.devicePixelRatio 这个属性非常重要，表示物理像素和 CSS 像素单位的倍率关系，Retina 屏这个值是 2，后来也出现了一些 3 倍的 Android 屏。</p>
</li>
<li><p>window.screen （屏幕尺寸相关的信息）</p>
</li>
<li><p>window.screen.width, window.screen.height 设备的屏幕尺寸。</p>
</li>
<li><p>window.screen.availWidth, window.screen.availHeight 设备屏幕的可渲染区域尺寸，一些 Android 机器会把屏幕的一部分预留做固定按钮，所以有这两个属性，实际上一般浏览器不会实现的这么细致。</p>
</li>
<li><p>window.screen.colorDepth, window.screen.pixelDepth 这两个属性是固定值 24，应该是为了以后预留。</p>
</li>
</ul>
<p>以上比较有用的只有三个：innerHeight、innerWidth 和 devicePixelRatio </p>
<h4 id="元素的布局信息"><a href="#元素的布局信息" class="headerlink" title="元素的布局信息"></a>元素的布局信息</h4><p>首先应该从脑中消除“元素有宽高”这样的概念，有些元素可能产生多个盒，事实上，只有盒有宽和高，元素是没有的。</p>
<p>所以我们获取宽高的对象应该是“盒”，于是 CSSOM View 为 Element 类添加了两个方法：</p>
<ul>
<li><p>getClientRects(): 返回一个列表，里面包含元素对应的每一个盒所占据的客户端矩形区域，这里每一个矩形区域可以用 x, y, width, height 来获取它的位置和尺寸。</p>
<pre><code>  document.getElementById(&quot;wrap&quot;).getClientRects()[0]
  //结果：
  &#123;bottom: 342
  height: 42
  left: 0
  right: 819
  top: 300
  width: 819
  x: 0
  y: 300&#125;
</code></pre>
</li>
<li><p>getBoundingClientRect(): 这个 API 的设计更接近我们脑海中的元素盒的概念，它返回元素对应的所有盒的包裹的矩形区域，需要注意，这个 API 获取的区域会包括当 overflow 为 visible 时的子元素区域</p>
<pre><code>  document.getElementById(&quot;wrap&quot;).getBoundingClientRect()
  //结果：
  &#123;bottom: 300
  height: 0
  left: 0
  right: 819
  top: 300
  width: 819
  x: 0
  y: 300&#125;
</code></pre>
</li>
</ul>
<p>两个api通常情况下计算结果是一致的。</p>
<p>这两个 API 获取的矩形区域都是相对于视口的坐标，这意味着，这些区域都是受滚动影响的。  </p>
<p>如果我们要获取相对坐标，或者包含滚动区域的坐标，需要一点小技巧：</p>
<pre><code>var offsetX = document.documentElement.getBoundingClientRect().x - element.getBoundingClientRect().x;
</code></pre>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - 浏览器部分-工作流程-css渲染</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-%E6%B5%8F%E8%A7%88%E5%99%A8%E9%83%A8%E5%88%86-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-css%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>浏览器使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面的过程。今天我们主要来看阶段二：如何解析请求回来的 HTML 代码，DOM 树又是如何构建的。</p>
<span id="more"></span>

<h2 id="解析代码"><a href="#解析代码" class="headerlink" title="解析代码"></a>解析代码</h2><p>HTML 的结构不算太复杂，我们日常开发需要的 90% 的“词”（指编译原理的术语 token，表示最小的有意义的单元），种类大约只有标签开始、属性、标签结束、注释、CDATA 节点几种。</p>
<h2 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h2><p>接下来我们要把这些简单的词变成 DOM 树，这个过程我们是使用栈来实现的，(JavaScript 中的栈只要用数组就可以)。<br>构建 DOM 树的流程大致如下：</p>
<ol>
<li>栈顶元素就是当前节点；</li>
<li>遇到属性，就添加到当前节点；</li>
<li>遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点；</li>
<li>遇到注释节点，作为当前节点的子节点；</li>
<li>遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点；</li>
<li>遇到 tag end 就出栈一个节点（还可以检查是否匹配）。</li>
</ol>
<h2 id="css的渲染"><a href="#css的渲染" class="headerlink" title="css的渲染"></a>css的渲染</h2><p>上述 DOM 的构建过程中，实际上信息是不全的，它只有节点和属性，不包含任何的样式信息。  </p>
<p>首先要理解CSS 规则是 DOM 树构建好了以后，再进行选择并给它添加样式的。实际上，这个过程并不是这样的。  </p>
<p>构建 DOM 的过程是：从父到子，从先到后，一个一个节点构造，并且挂载到 DOM 树上的，在这个过程中，我们依次拿到上一部构造好的元素，去检查它匹配到了哪些规则，再根据规则的优先级，做覆盖和调整。（所谓的选择器，应该被理解成“匹配器”才更合适。）</p>
<p>目前css选择器的各种符号如下：</p>
<pre><code>空格: 后代，选中它的子节点和所有子节点的后代节点。
&gt;: 子代，选中它的子节点。
+：直接后继选择器，选中它的下一个相邻节点。
~：后继，选中它之后所有的相邻节点。
||：列，选中表格中的一列。
</code></pre>
<p>CSS选择器的出现顺序，必定跟构建 DOM 树的顺序一致。这是一个 CSS 设计的原则，即保证选择器在 DOM 树构建到当前节点时，已经可以准确判断是否匹配，不需要后续节点信息。这就决定未来也不可能会出现“父元素选择器”这种东西，因为父元素选择器要求根据当前节点的子节点，来判断当前节点是否被选中，而父节点会先于子节点构建。</p>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - 浏览器部分-工作流程-排版</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-%E6%B5%8F%E8%A7%88%E5%99%A8%E9%83%A8%E5%88%86-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-%E6%8E%92%E7%89%88/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>书接上文。浏览器进行到这一步，我们已经给 DOM 元素添加了用于展现的 CSS 属性，接下来，浏览器的工作就是确定每一个元素的位置，进入“排版”流程了。</p>
<p>在现代浏览器中，仍然借用了这个概念，但是排版的内容更加复杂，包括文字、图片、图形、表格等等，我们把浏览器确定它们位置的过程，叫作排版。</p>
<span id="more"></span>
<h3 id="正常流文字排版"><a href="#正常流文字排版" class="headerlink" title="正常流文字排版"></a>正常流文字排版</h3><p>浏览器最基本的排版方案是正常流排版，它包含了顺次排布和折行等规则，这是一个跟我们提到的印刷排版类似的排版方案，也跟我们平时书写文字的方式一致，所以我们把它叫做正常流。在正常流的文字排版中，多数元素被当作长方形盒来排版，而只有 display 为 inline 的元素，是被拆成文本来排版的。 </p>
<p>在正常流中，display 不为 inline 的元素或者伪元素，会以盒的形式跟文字一起排版。多数 display 属性都可以分成两部分：内部的排版和是否 inline，带有 inline- 前缀的盒，被称作行内级盒。</p>
<p>根据盒模型，一个盒具有 margin、border、padding、width/height 等属性，它在主轴方向占据的空间是由对应方向的这几个属性之和决定的，而 vertical-align 属性决定了盒在交叉轴方向的位置，同时也会影响实际行高。  </p>
<p>所以，浏览器对行的排版，一般是先行内布局，再确定行的位置，根据行的位置计算出行内盒和文字的排版位置。</p>
<p>块级盒比较简单，它总是单独占据一整行，计算出交叉轴方向的高度即可。</p>
<h4 id="绝对定位元素"><a href="#绝对定位元素" class="headerlink" title="绝对定位元素"></a>绝对定位元素</h4><p>position 属性为 absolute 的元素，我们需要根据它的包含块来确定位置，这是完全跟正常流无关的一种独立排版模式，逐层找到其父级的 position 非 static 元素即可。</p>
<h4 id="浮动元素排版"><a href="#浮动元素排版" class="headerlink" title="浮动元素排版"></a>浮动元素排版</h4><p>float 元素非常特别，浏览器对 float 的处理是先排入正常流，再移动到排版宽度的最左 / 最右（这里实际上是主轴的最前和最后）。</p>
<p>移动之后，float 元素占据了一块排版的空间，因此，在数行之内，主轴方向的排版距离发生了变化，直到交叉轴方向的尺寸超过了浮动元素的交叉轴尺寸范围，主轴排版尺寸才会恢复。<br>float 元素排布完成后，float 元素所在的行需要重新确定位置。</p>
<h3 id="其它的排版"><a href="#其它的排版" class="headerlink" title="其它的排版"></a>其它的排版</h3><p>CSS 的每一种排版都有一个很复杂的规定，实际实现形式也各不相同。比如如 flex 排版，支持了 flex 属性，flex 属性将每一行排版后的剩余空间平均分配给主轴方向的 width/height 属性。浏览器支持的每一种排版方式，都是按照对应的标准来实现的</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><p>文字排版的思路是“改变文字和盒的相对位置，把它放进特定的版面中”，软件界面的思路则是“改变盒的大小，使得它们的结构保持固定”。在早年的 CSS 中，“使盒按照外部尺寸变化”的能力非常弱。就出现了CSS 三大经典问题：垂直居中问题，两列等高问题，自适应宽问题。这是在其它 UI 系统中最为基本的问题，而到了 CSS 中，却变成了困扰工程师的三座大山。</p>
<p>flex 排版方式应运而生，这是一种典型的“根据外部容器决定内部尺寸”的思路，也是我们最常用的 Windows 和 Apple 窗口系统的设计思路，有了它，解决当年的 CSS 三大经典问题，便易如反掌(具体代码请参照<a href="https://time.geekbang.org/column/article/90148">35 | CSS Flex排版：为什么垂直居中这么难？</a>)</p>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - 浏览器部分-工作流程-渲染和绘制</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-%E6%B5%8F%E8%A7%88%E5%99%A8%E9%83%A8%E5%88%86-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-%E6%B8%B2%E6%9F%93%E5%92%8C%E7%BB%98%E5%88%B6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这里我们进入最后的阶段：根据这些样式信息和大小信息，为每个元素在内存中渲染它的图形，并且把它绘制到对应的位置。</p>
<span id="more"></span>
<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>本文中出现的“渲染”一词，统一指的是它在图形学的意义，也就是把模型变成位图的过程。</p>
<p>浏览器中渲染这个过程，就是把每一个元素对应的盒变成位图。这里的元素包括 HTML 元素和伪元素，一个元素可能对应多个盒（比如 inline 元素，可能会分成多行）。每一个盒对应着一张位图。</p>
<h2 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h2><p>渲染过程不会把子元素渲染到位图上面，合成的过程，就是为一些元素创建一个“合成后的位图”（我们把它称为合成层），把一部分子元素渲染到合成的位图上面。</p>
<p>目前，主流浏览器一般根据 position、transform 等属性来决定合成策略，来“猜测”这些元素未来可能发生变化。</p>
<p>但是，这样的猜测准确性有限，所以新的 CSS 标准中，规定了 will-change 属性，可以由业务代码来提示浏览器的合成策略，灵活运用这样的特性，可以大大提升合成策略的效果。</p>
<h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><p>绘制是把“位图最终绘制到屏幕上，变成肉眼可见的图像”的过程，不过，一般来说，浏览器并不需要用代码来处理这个过程，浏览器只需要把最终要显示的位图交给操作系统即可</p>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - 浏览器部分-工作流程-请求</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-%E6%B5%8F%E8%A7%88%E5%99%A8%E9%83%A8%E5%88%86-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h2 id="总流程"><a href="#总流程" class="headerlink" title="总流程"></a>总流程</h2><p>一个 URL 变成一个屏幕上显示的网页的流程如下：</p>
<ol>
<li>浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面；</li>
<li>把请求回来的 HTML 代码经过解析，构建成 DOM 树；</li>
<li>计算 DOM 树上的 CSS 属性；</li>
<li>最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图；</li>
<li>一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度；</li>
<li>合成之后，再绘制到界面上。<span id="more"></span></li>
</ol>
<p><img src="/6-1.jpg"></p>
<p>从 HTTP 请求回来，就产生了流式的数据，后续的 DOM 树构建、CSS 计算、渲染、合成、绘制，都是尽可能地流式处理前一步的产出：即不需要等到上一步骤完全结束，就开始处理上一步的输出，这样我们在浏览网页时，才会看到逐步出现的页面。</p>
<h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><h3 id="七层结构"><a href="#七层结构" class="headerlink" title="七层结构"></a>七层结构</h3><p>为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了“开放系统互联参考模型”，即著名的OSI/RM模型。它将计算机网络体系结构的通信协议划分为七层。  </p>
<h3 id="四层结构"><a href="#四层结构" class="headerlink" title="四层结构"></a>四层结构</h3><p>但是由于OSI参考模型的过于庞大、复杂，所以出现了其他模型：TCP/IP协议栈是美国国防部高级研究计划局计算机网和其后继因特网使用的参考模型，并最终成为应用最广泛的模型。</p>
<h3 id="五层结构"><a href="#五层结构" class="headerlink" title="五层结构"></a>五层结构</h3><p>五层结构只是OSI和TCP/IP的综合，实际应用还是TCP/IP的四层结构。为了方便可以把下两层称为网络接口层。</p>
<h3 id="对比图"><a href="#对比图" class="headerlink" title="对比图"></a>对比图</h3><p><img src="/6-2.png"></p>
<p><img src="/6-3.png"></p>
<h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><p>因特网本身是基于TCP/IP模型的。用网络术语来说的话，HTTP(超文本传输协议)协议位于TCP的上层，是属于应用层的协议。HTTP 是纯粹的文本协议，它是规定了使用 TCP 协议来传输文本格式的一个应用层协议。HTTP协议大致分为以下部分：<br><img src="/6-4.jpg"></p>
<h3 id="1-请求方法"><a href="#1-请求方法" class="headerlink" title="1 请求方法"></a>1 请求方法</h3><p>http请求方法标识此次 HTTP 请求希望执行的操作类型。方法有以下几种定义：</p>
<ul>
<li>GET </li>
<li>POST</li>
<li>HEAD</li>
<li>PUT</li>
<li>5DELECT</li>
<li>CONNECT</li>
<li>OPTIONS</li>
<li>TRACE</li>
</ul>
<p>浏览器通过地址栏访问页面都是 GET 方法。表单提交产生 POST 方法。  </p>
<p>HEAD 则是跟 GET 类似，只返回请求头，多数由 JavaScript 发起。  </p>
<p>PUT 和 DELETE 分别表示添加资源和删除资源，但是实际上这只是语义上的一种约定，并没有强约束。  </p>
<p>CONNECT 现在多用于 HTTPS 和 WebSocket。</p>
<p>PUT 和 DELETE 分别表示添加资源和删除资源，但是实际上这只是语义上的一种约定，并没有强约束。</p>
<p>OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。</p>
<h3 id="2-状态码"><a href="#2-状态码" class="headerlink" title="2 状态码"></a>2 状态码</h3><ol>
<li>对我们前端来说，1xx 系列的状态码是非常陌生的，原因是 1xx 的状态被浏览器 http 库直接处理掉了，不会让上层应用知晓。</li>
<li>2xx 系列的状态最熟悉的就是 200，这通常是网页请求成功的标志，也是大家最喜欢的状态码。</li>
<li>3xx 系列比较复杂，301 和 302 两个状态表示当前资源已经被转移，只不过一个是永久性转移，一个是临时性转移。实际上 301 更接近于一种报错，提示客户端下次别来了。304 又是一个每个前端必知必会的状态，产生这个状态的前提是：客户端本地已经有缓存的版本，并且在 Request 中告诉了服务端，当服务端通过时间或者 tag，发现没有更新的时候，就会返回一个不含 body 的 304 状态。</li>
</ol>
<h3 id="3-HTTP-头"><a href="#3-HTTP-头" class="headerlink" title="3 HTTP 头"></a>3 HTTP 头</h3><p>HTTP 头可以看作一个键值对。</p>
<p>先来看看 Request Header:</p>
<p><img src="/6-5.png"></p>
<p>接下来看一下 Response Header:</p>
<p><img src="/6-6.png"></p>
<h3 id="4-HTTP-Request-Body"><a href="#4-HTTP-Request-Body" class="headerlink" title="4 HTTP Request Body"></a>4 HTTP Request Body</h3><p>http 请求的 body 是比较自由的，只要浏览器端发送的 body 服务端认可就可以了。一些常见的 body 格式是：</p>
<ul>
<li>application/json</li>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/xml</li>
</ul>
<p>我们使用 html 的 form 标签提交产生的 html 请求，默认会产生 application/x-www-form-urlencoded 的数据格式，当有文件上传时，则会使用 multipart/form-data。</p>
<h3 id="5-HTTPS"><a href="#5-HTTPS" class="headerlink" title="5 HTTPS"></a>5 HTTPS</h3><p>HTTPS 有两个作用，一是确定请求的目标服务端身份，二是保证传输的数据不会被网络中间节点窃听或者篡改。</p>
<p>HTTPS 是使用加密通道来传输 HTTP 的内容。但是 HTTPS 首先与服务端建立一条 TLS 加密通道。TLS 构建于 TCP 协议之上，它实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS 跟 HTTP 没有任何区别。</p>
<h3 id="6-HTTP-2"><a href="#6-HTTP-2" class="headerlink" title="6 HTTP 2"></a>6 HTTP 2</h3><p>HTTP 2.0 最大的改进有两点，一是支持服务端推送，二是支持 TCP 连接复用。HTTP1.X的连接无法复用，这就会导致每次请求都经历三次握手和慢启动。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://mp.weixin.qq.com/s/hjxU-rjr-ISk0rzeQHAIeA">一文读懂HTTP/2 及 HTTP/3特性</a></li>
</ol>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - 浏览器部分-捕获和冒泡</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-%E6%B5%8F%E8%A7%88%E5%99%A8%E9%83%A8%E5%88%86-%E6%8D%95%E8%8E%B7%E5%92%8C%E5%86%92%E6%B3%A1/</url>
    <content><![CDATA[<h2 id="事件捕获和冒泡"><a href="#事件捕获和冒泡" class="headerlink" title="事件捕获和冒泡"></a>事件捕获和冒泡</h2><p>捕获过程是从外向内，冒泡过程是从内向外。</p>
<p>实际上点击事件来自触摸屏或者鼠标，鼠标点击并没有位置信息，但是一般操作系统会根据位移的累积计算出来，跟触摸屏一样，提供一个坐标给浏览器。那么，把这个坐标转换为具体的元素上事件的过程，就是捕获过程了。而冒泡过程，则是符合人类理解逻辑的：当你按电视机开关时，你也按到了电视机。</p>
<p>所以我们可以认为，捕获是计算机处理事件的逻辑，而冒泡是人类处理事件的逻辑。</p>
<p>addEventListener 有三个参数：</p>
<pre><code>事件名称；
事件处理函数
捕获还是冒泡
</code></pre>
<p>在现代浏览器中，建议默认不传第三个参数，因为冒泡是符合正常的人类心智模型的，大部分业务开发者不需要关心捕获过程。</p>
<span id="more"></span>
<h3 id="焦点"><a href="#焦点" class="headerlink" title="焦点"></a>焦点</h3><p>键盘事件是由焦点系统控制的，一般来说，操作系统也会提供一套焦点系统，但是现代浏览器一般都选择在自己的系统内覆盖原本的焦点系统。</p>
<p>焦点系统认为整个 UI 系统中，有且仅有一个“聚焦”的元素，所有的键盘事件的目标元素都是这个聚焦元素。</p>
<p>浏览器 API 还提供了 API 来操作焦点，如：</p>
<pre><code>document.body.focus();
    
document.body.blur();
</code></pre>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><pre><code>var evt = new Event(&quot;look&quot;, &#123;&quot;bubbles&quot;:true, &quot;cancelable&quot;:false&#125;);
document.dispatchEvent(evt);
</code></pre>
<p>这里使用 Event 构造器来创造了一个新的事件，然后调用 dispatchEvent 来在特定元素上触发。我们可以给这个 Event 添加自定义属性、方法</p>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>重学前端 - 浏览器部分-节点种类</title>
    <url>/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-%E6%B5%8F%E8%A7%88%E5%99%A8%E9%83%A8%E5%88%86-%E8%8A%82%E7%82%B9%E7%A7%8D%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM API 大致会包含 4 个部分:</p>
<ul>
<li><p>节点：DOM 树形结构中的节点相关 API。</p>
</li>
<li><p>事件：触发和监听事件相关 API。</p>
</li>
<li><p>Range：操作文字范围相关 API。</p>
</li>
<li><p>遍历：遍历 DOM 需要的 API。</p>
<span id="more"></span>
<h3 id="节点的类型"><a href="#节点的类型" class="headerlink" title="节点的类型"></a>节点的类型</h3><p><img src="16-1.png"></p>
</li>
</ul>
<p>要重点掌握的是：Document、Element、Text 节点。DocumentFragment 也非常有用，它常常被用来高性能地批量添加节点。</p>
<pre><code>console.time(&quot;sort1&quot;);
for (var i1 = 0; i1 &lt; 10000; i1++) &#123;
  var p1 = document.createElement(&quot;p&quot;);
  var oTxt1 = document.createTextNode(&quot;段落&quot; +i1);
  p1.appendChild(oTxt1);
  document.getElementById(&quot;sort1&quot;).appendChild(p1);
&#125;
console.timeEnd(&quot;sort1&quot;);
console.time(&quot;sort2&quot;);
var oFragment = document.createDocumentFragment();
for (var i2 = 0; i2 &lt; 10000; i2++) &#123;
  var p2 = document.createElement(&quot;p&quot;);
  var oTxt2 = document.createTextNode(&quot;段落&quot; + i2);
  p2.appendChild(oTxt2);
  oFragment.appendChild(p2);
&#125;
document.getElementById(&quot;sort2&quot;).appendChild(oFragment);
console.timeEnd(&quot;sort2&quot;);
</code></pre>
<p>实测对比，运行相差最长5ms,有些情况下sort1执行时间小于sort2，有点迷~</p>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node 是 DOM 树继承关系的根节点，它定义了 DOM 节点在 DOM 树上的操作</p>
<p>Node下属性：</p>
<pre><code>parentNode
childNodes
firstChild
lastChild
nextSibling
previousSibling
</code></pre>
<p>Node下方法：</p>
<pre><code>appendChild
insertBefore
removeChild
replaceChild
</code></pre>
<p>创建Node：</p>
<p>DOM 标准规定了节点必须从文档的 create 方法创建出来，不能够使用原生的 JavaScript 的 new 运算。于是 document 对象有这些方法。</p>
<pre><code>createElement
createTextNode
createCDATASection
createComment
createProcessingInstruction
createDocumentFragment
createDocumentType
</code></pre>
<h2 id="Element-和-Attribute"><a href="#Element-和-Attribute" class="headerlink" title="Element 和 Attribute"></a>Element 和 Attribute</h2><p>Element(元素)作为Node（节点）的子类，是大部分时候我们比较关注的。元素对应了 HTML 中的标签，它既有子节点，又有属性。所以 Element 子类中，有一系列操作属性的方法：</p>
<pre><code>getAttribute
setAttribute
removeAttribute
hasAttribute
</code></pre>
<p>还可以把 Attribute 当作节点(IE6,7也是支持的)：</p>
<pre><code>getAttributeNode
setAttributeNode
</code></pre>
<p>关于getAttributeNode：返回的是Attr类型的属性节点</p>
<pre><code>document.getElementById(&quot;app&quot;).getAttributeNode(&quot;id&quot;).nodeValue===document.getElementById(&quot;app&quot;).getAttribute(&quot;id&quot;)
</code></pre>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>document 节点提供了查找元素的能力：。</p>
<pre><code>querySelector
querySelectorAll
getElementById
getElementsByName
getElementsByTagName
getElementsByClassName
</code></pre>
<p>我们需要注意，getElementById、getElementsByName、getElementsByTagName、getElementsByClassName，这几个 API 的性能高于 querySelector。而 getElementsByName、getElementsByTagName、getElementsByClassName 获取的集合并非数组，而是一个能够动态更新的集合。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>除了使用JavaScript 遍历整个树外，还可以通过DOM API 中的 NodeIterator 和 TreeWalker 来遍历树。</p>
<pre><code>var iterator = document.createNodeIterator(document.body, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_COMMENT, null, false);
</code></pre>
<p>不常用，知道即可</p>
<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p>Range API 表示一个 HTML 上的范围，这个范围是以文字为最小单位的，所以 Range 不一定包含完整的节点，它可能是 Text 节点中的一段，也可以是头尾两个 Text 的一部分加上中间的元素。</p>
<p>我们通过 Range API 可以比节点 API 更精确地操作 DOM 树，凡是 节点 API 能做到的，Range API 都可以做到，而且可以做到更高性能，但是 Range API 使用起来比较麻烦，所以在实际项目中，并不常用，只有做底层框架和富文本编辑对它有强需求。</p>
<pre><code>var range = new Range(),
firstText = p.childNodes[1],
secondText = em.firstChild
range.setStart(firstText, 9) // do not forget the leading space
range.setEnd(secondText, 4)
</code></pre>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>创建元素和属性相关的 API 都有带命名空间的版本：</p>
<pre><code>createElementNS
createAttributeNS
getAttributeNS
setAttributeNS
attributes.setNamedItemNS
...
</code></pre>
<p>在 HTML 场景中，需要考虑命名空间的场景不多。最主要的场景是 SVG。</p>
<h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p>SVG 是使用 XML 来描述二维图形和绘图程序的语言。我们可以查看一个<a href="http://www.w3school.com.cn/svg/svg_example.asp">svg实例</a>，关于命名空间的问题可以查看《Javascript高级程序设计》第12章 DOM2和DOM3,下面简要记录一些命名空间的相关内容：</p>
<h3 id="命名空间-1"><a href="#命名空间-1" class="headerlink" title="命名空间"></a>命名空间</h3><p>有了XML命名空间的，不同 XML 文档的元素就可以混合在一起，共同构成格式良好的文档，而不必担心发生命名冲突（扩展阅读：<a href="https://www.cnblogs.com/hcd48/p/6866657.html">XML,HTML以及XHTML的区别</a>）</p>
<p>譬如，我们看一个混合 XHTML 和 SVG 语言的文档</p>
<pre><code>&lt;html xmlns:h=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;title&gt;Example XHTML page&lt;/title&gt;
  &lt;style&gt;
    @namespace svg url(http://www.w3.org/2000/svg);
    @namespace html url(http://www.w3.org/1999/xhtml);

    html|a &#123;
      color: red;
    &#125;

    svg|a &#123;
      stroke: blue;
      stroke-width: 1;
    &#125;
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;a&gt;I am HTML&lt;/a&gt;
  &lt;svg xmlns:s=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 100 100&quot; style=&quot;width:100%; height:100%&quot;&gt;
    &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;fill:red&quot; /&gt;
    &lt;a width=&quot;10&quot; height=&quot;10&quot;&gt;&lt;text x=&quot;0&quot; y=&quot;15&quot; fill=&quot;red&quot;&gt;I love SVG&lt;/text&gt;&lt;/a&gt;
  &lt;/svg&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>我们通过带有命名空间版本的DOM api访问得到的结果是(css中也有命名空间)：</p>
<p><img src="16-2.png"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://blog.csdn.net/wonder233/article/details/78596524">DOM：Attr类型</a></li>
<li><a href="https://www.cnblogs.com/wangfupeng1988/p/3639330.html">js便签笔记（4）——简单说说getAttributeNode()和setAttributeNode()</a></li>
<li><a href="https://www.jianshu.com/p/f5b510b656f2">SVG-简书</a></li>
</ol>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
</search>
