<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://static.wangminghuan.cn/cdn/fontawesome@5.15.3/all.min.css">
  <link rel="stylesheet" href="https://static.wangminghuan.cn/cdn/animejs@3.2.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{"hostname":"wangminghuan.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

  <meta name="description" content="概述Proxy: 英文意思为：代理，读音为：[ˈprɒksi]。它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。 Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6系列-4-Proxy与Reflect">
<meta property="og:url" content="https://wangminghuan.github.io/ES6%E7%B3%BB%E5%88%97-4-Proxy%E4%B8%8EReflect/index.html">
<meta property="og:site_name" content="WMH&#39;s Blog">
<meta property="og:description" content="概述Proxy: 英文意思为：代理，读音为：[ˈprɒksi]。它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。 Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wangminghuan.github.io/ES6%E7%B3%BB%E5%88%97-4-Proxy%E4%B8%8EReflect/1.jpg">
<meta property="og:image" content="https://wangminghuan.github.io/ES6%E7%B3%BB%E5%88%97-4-Proxy%E4%B8%8EReflect/2.jpg">
<meta property="og:image" content="https://wangminghuan.github.io/ES6%E7%B3%BB%E5%88%97-4-Proxy%E4%B8%8EReflect/3.jpg">
<meta property="og:image" content="https://wangminghuan.github.io/ES6%E7%B3%BB%E5%88%97-4-Proxy%E4%B8%8EReflect/4.jpg">
<meta property="article:published_time" content="2019-11-04T11:10:13.000Z">
<meta property="article:modified_time" content="2022-05-17T10:04:10.801Z">
<meta property="article:author" content="WMH">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wangminghuan.github.io/ES6%E7%B3%BB%E5%88%97-4-Proxy%E4%B8%8EReflect/1.jpg">


<link rel="canonical" href="https://wangminghuan.github.io/ES6%E7%B3%BB%E5%88%97-4-Proxy%E4%B8%8EReflect/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://wangminghuan.github.io/ES6%E7%B3%BB%E5%88%97-4-Proxy%E4%B8%8EReflect/","path":"ES6系列-4-Proxy与Reflect/","title":"ES6系列-4-Proxy与Reflect"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ES6系列-4-Proxy与Reflect | WMH's Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">WMH's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-主页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a></li>
        <li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Proxy-%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text">Proxy 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">Proxy 构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy-%E5%AE%9E%E4%BE%8B"><span class="nav-number">2.2.</span> <span class="nav-text">Proxy 实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Proxy-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">Proxy 实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#get"><span class="nav-number">3.1.</span> <span class="nav-text">get()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA%E8%AF%BB%E5%8F%96"><span class="nav-number">3.1.1.</span> <span class="nav-text">拦截读取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA%E7%BB%A7%E6%89%BF"><span class="nav-number">3.1.2.</span> <span class="nav-text">拦截继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#receiver-%E5%8F%82%E6%95%B0"><span class="nav-number">3.1.3.</span> <span class="nav-text">receiver 参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%86%99%E9%85%8D%E7%BD%AE%E4%B8%94%E4%B8%8D%E5%8F%AF%E5%86%99%E5%B1%9E%E6%80%A7%E7%9A%84%E6%8B%A6%E6%88%AA"><span class="nav-number">3.1.4.</span> <span class="nav-text">不可写配置且不可写属性的拦截</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set"><span class="nav-number">3.2.</span> <span class="nav-text">set()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C"><span class="nav-number">3.2.1.</span> <span class="nav-text">数据校验</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#receiver-%E5%8F%82%E6%95%B0-1"><span class="nav-number">3.2.2.</span> <span class="nav-text">receiver 参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%86%99%E9%85%8D%E7%BD%AE%E4%B8%94%E4%B8%8D%E5%8F%AF%E5%86%99%E5%B1%9E%E6%80%A7%E7%9A%84%E6%8B%A6%E6%88%AA-1"><span class="nav-number">3.2.3.</span> <span class="nav-text">不可写配置且不可写属性的拦截</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#apply"><span class="nav-number">3.3.</span> <span class="nav-text">apply()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#has"><span class="nav-number">3.4.</span> <span class="nav-text">has()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#construct"><span class="nav-number">3.5.</span> <span class="nav-text">construct()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deleteProperty"><span class="nav-number">3.6.</span> <span class="nav-text">deleteProperty()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defineProperty"><span class="nav-number">3.7.</span> <span class="nav-text">defineProperty()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getOwnPropertyDescriptor"><span class="nav-number">3.8.</span> <span class="nav-text">getOwnPropertyDescriptor()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getPrototypeOf"><span class="nav-number">3.9.</span> <span class="nav-text">getPrototypeOf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isExtensible"><span class="nav-number">3.10.</span> <span class="nav-text">isExtensible()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ownKeys"><span class="nav-number">3.11.</span> <span class="nav-text">ownKeys()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#preventExtensions"><span class="nav-number">3.12.</span> <span class="nav-text">preventExtensions()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setPrototypeOf"><span class="nav-number">3.13.</span> <span class="nav-text">setPrototypeOf()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Proxy-revocable"><span class="nav-number">4.</span> <span class="nav-text">Proxy.revocable()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this-%E9%97%AE%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">this 问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reflect-%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.</span> <span class="nav-text">Reflect 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reflect-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">Reflect 静态方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect-get"><span class="nav-number">7.1.</span> <span class="nav-text">Reflect.get()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect-set"><span class="nav-number">7.2.</span> <span class="nav-text">Reflect.set()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect-apply"><span class="nav-number">7.3.</span> <span class="nav-text">Reflect.apply()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect-has"><span class="nav-number">7.4.</span> <span class="nav-text">Reflect.has()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect-construct-target-args"><span class="nav-number">7.5.</span> <span class="nav-text">Reflect.construct(target, args)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect-deleteProperty-target-name"><span class="nav-number">7.6.</span> <span class="nav-text">Reflect.deleteProperty(target, name)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect-defineProperty-target-name-desc"><span class="nav-number">7.7.</span> <span class="nav-text">Reflect.defineProperty(target, name, desc)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect-getOwnPropertyDescriptor"><span class="nav-number">7.8.</span> <span class="nav-text">Reflect.getOwnPropertyDescriptor()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect-getPrototypeOf-target"><span class="nav-number">7.9.</span> <span class="nav-text">Reflect.getPrototypeOf(target)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect-isExtensible-target"><span class="nav-number">7.10.</span> <span class="nav-text">Reflect.isExtensible(target)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect-ownKeys-target"><span class="nav-number">7.11.</span> <span class="nav-text">Reflect.ownKeys(target)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect-preventExtensions-target"><span class="nav-number">7.12.</span> <span class="nav-text">Reflect.preventExtensions(target)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect-setPrototypeOf"><span class="nav-number">7.13.</span> <span class="nav-text">Reflect.setPrototypeOf()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="WMH"
      src="/images/avatar2.png">
  <p class="site-author-name" itemprop="name">WMH</p>
  <div class="site-description" itemprop="description">just code it</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">101</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/wangminghuan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangminghuan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:m.h.wang@foxmail.com" title="E-Mail → mailto:m.h.wang@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weblog.wangminghuan.cn/" title="WebSite → https:&#x2F;&#x2F;weblog.wangminghuan.cn" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i>WebSite</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/1657970003?topnav=1&wvr=6&topsug=1&is_all=1" title="微博 → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;1657970003?topnav&#x3D;1&amp;wvr&#x3D;6&amp;topsug&#x3D;1&amp;is_all&#x3D;1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>微博</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wangminghuan.github.io/ES6%E7%B3%BB%E5%88%97-4-Proxy%E4%B8%8EReflect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.png">
      <meta itemprop="name" content="WMH">
      <meta itemprop="description" content="just code it">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WMH's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ES6系列-4-Proxy与Reflect
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-04 11:10:13" itemprop="dateCreated datePublished" datetime="2019-11-04T11:10:13+00:00">2019-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-17 10:04:10" itemprop="dateModified" datetime="2022-05-17T10:04:10+00:00">2022-05-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ES6%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">ES6系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Proxy: 英文意思为：代理，读音为：[ˈprɒksi]。它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。</p>
<span id="more"></span>
<p>我们先看一个例子</p>
<pre><code>var obj = new Proxy(&#123;&#125;, &#123;
  get(target, key, receiver) &#123;
    console.log(`getting $&#123;key&#125;!`);
    return Reflect.get(target, key, receiver);
  &#125;,
  set(target, key, value, receiver) &#123;
    console.log(`setting $&#123;key&#125;!`);
    return Reflect.set(target, key, value, receiver);
  &#125;
&#125;);
</code></pre>
<p>运行下面代码：</p>
<pre><code>obj.name=&quot;mike&quot;
//setting name!

obj.name
//getting name!
</code></pre>
<p>可以看到ES6重载了点运算符，即用自己的定义覆盖了语言的原始定义。</p>
<h2 id="Proxy-对象"><a href="#Proxy-对象" class="headerlink" title="Proxy 对象"></a>Proxy 对象</h2><h3 id="Proxy-构造函数"><a href="#Proxy-构造函数" class="headerlink" title="Proxy 构造函数"></a>Proxy 构造函数</h3><p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>
<pre><code>var proxy = new Proxy(target, handler);
</code></pre>
<ul>
<li>target参数表示所要拦截的目标对象</li>
<li>handler参数也是一个对象，用来定制拦截行为</li>
</ul>
<p>我们在target对象上设置一层拦截：</p>
<pre><code>  var target = &#123;&#125;;
  var handler = &#123;
    get(target, property)&#123;
      return &#39;Li&#39;
    &#125;,
  &#125;;
  var proxy = new Proxy(target, handler);
</code></pre>
<p>当修改target对象时</p>
<pre><code>  target.name=&quot;jack&quot;;
</code></pre>
<p>可以看到proxy其实是接收到变化了<br><img src="1.jpg"></p>
<p>但当我们访问proxy下属性时，返回的依旧是<code>Li</code>:</p>
<pre><code>  proxy.name //&#39;Li&#39;
</code></pre>
<p>直接设置proxy.name,proxy返回的依旧是<code>Li</code>,target变为了<code>tom</code>:</p>
<pre><code>  proxy.name=&quot;tom&quot;
  proxy.name //&#39;Li&#39;
  target.name //&quot;tom&quot;
</code></pre>
<p>这很好理解，所有访问操作都会经过代理再处理一层，所以返回的永远是 <code>Li</code></p>
<h3 id="Proxy-实例"><a href="#Proxy-实例" class="headerlink" title="Proxy 实例"></a>Proxy 实例</h3><p>Proxy 实例也可以作为其他对象的原型对象（沿用上述例子）。</p>
<pre><code>  var target = &#123;&#125;;
  var handler = &#123;
    get(target, property)&#123;
      return &#39;Li&#39;
    &#125;,
  &#125;;
  var proxy = new Proxy(target, handler);
  var obj = Object.creat(proxy)
  console.log(obj.time);// &#39;Li&#39;
</code></pre>
<h2 id="Proxy-实例方法"><a href="#Proxy-实例方法" class="headerlink" title="Proxy 实例方法"></a>Proxy 实例方法</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>get方法用于拦截某个属性的读取操作，可以接受三个参数：</p>
<pre><code>get(target,propKey[,receiver])

- target: 目标对象
- propKey: 属性名
- receiver: proxy 实例本身,严格地说，是操作行为所针对的对象，可选
</code></pre>
<h4 id="拦截读取"><a href="#拦截读取" class="headerlink" title="拦截读取"></a>拦截读取</h4><pre><code>const person = &#123;
  name: &quot;张三&quot;
&#125;;

const proxy = new Proxy(person, &#123;
  get: function(target, propKey) &#123;
    if (propKey in target) &#123;
      return target[propKey];
    &#125; else &#123;
      throw new ReferenceError(&quot;propKey \&quot;&quot; + propKey + &quot;\&quot; does not exist.&quot;);
    &#125;
  &#125;
&#125;);
</code></pre>
<p>运行结果：</p>
<p><img src="2.jpg"></p>
<h4 id="拦截继承"><a href="#拦截继承" class="headerlink" title="拦截继承"></a>拦截继承</h4><pre><code>const Obj=new Proxy(&#123;&#125;, &#123;
  get: function(target, propKey, receiver) &#123;
      console.log(&quot;GET &quot;+propKey)
      console.log(receiver)
      return target[propKey];
  &#125;
&#125;);
const p1=Object.create(Obj)
</code></pre>
<p>运行结果：</p>
<pre><code> p1.name // GET name
</code></pre>
<h4 id="receiver-参数"><a href="#receiver-参数" class="headerlink" title="receiver 参数"></a>receiver 参数</h4><pre><code>const proxy = new Proxy(&#123;&#125;, &#123;
  get: function(target, propKey, receiver) &#123;
    return receiver;
  &#125;
&#125;);
const b=Object.create(proxy)
proxy.getReceiver === proxy;// true
b.a===b.c; //true
b.a===b; //true
</code></pre>
<p>  b对象本身没有a属性，所以读取b.a的时候，会去d的原型proxy对象找。这时，receiver就指向b，代表原始的读操作所在的那个对象。</p>
<h4 id="不可写配置且不可写属性的拦截"><a href="#不可写配置且不可写属性的拦截" class="headerlink" title="不可写配置且不可写属性的拦截"></a>不可写配置且不可写属性的拦截</h4><pre><code>const target = Object.defineProperties(&#123;&#125;, &#123;
  foo: &#123;
    value: 123,
    writable: false,
    configurable: false
  &#125;,
&#125;);


const proxy = new Proxy(target, &#123;
  get(target, propKey) &#123;
    return &#39;abc&#39;;
  &#125;
&#125;);
</code></pre>
<p>此时，访问<code>proxy.foo</code>会报错</p>
<p><img src="3.jpg"></p>
<p>这种情况下只能返回原属性本身：</p>
<pre><code>const proxy = new Proxy(target, &#123;
  get(target, propKey) &#123;
    return target[propKey]
  &#125;
&#125;);
</code></pre>
<h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p>set方法用来拦截某个属性的赋值操作，可以接受四个参数：</p>
<pre><code>set(target, propKey, value, receiver)

- target: 目标对象
- propKey: 属性名
- value: 属性值
- receiver: proxy 实例本身,严格地说，是操作行为所针对的对象，可选
</code></pre>
<h4 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h4><pre><code>const validator=&#123;
  set(target,propKey,value)&#123;
    if(propKey===&quot;age&quot;)&#123;
    if(!Number.isInteger(value))&#123;
      throw new TypeError(&#39;The age is not an integer&#39;);
    &#125;else if(value&gt;100)&#123;
      throw new RangeError(&#39;The age seems invalid&#39;);
    &#125;
    &#125;
    target[propKey]=value
  &#125;
&#125;
const person=new Proxy(&#123;&#125;,validator)
</code></pre>
<p>运行结果：</p>
<p><img src="4.jpg"></p>
<p>这是数据验证的一种实现方法。利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM（Vue 3.x的版本采用此方法）</p>
<h4 id="receiver-参数-1"><a href="#receiver-参数-1" class="headerlink" title="receiver 参数"></a>receiver 参数</h4><pre><code>const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = receiver;
  &#125;
&#125;;
const proxy = new Proxy(&#123;&#125;, handler);

const b = &#123;&#125;;
Object.setPrototypeOf(b, proxy); 
//Object.setPrototypeOf 将一个指定的对象的原型设置为另一个对象
// 等同于 const b = Object.create(proxy)
</code></pre>
<p>运行结果：</p>
<pre><code>  b.a ===b;  //false
  b.a = &#39;bar&#39;;//&quot;bar&quot;
  b.a ===b; //true
</code></pre>
<p>设置b.a属性的值时，b并没有a属性，因此引擎会到b的原型链去找a属性。b的原型对象proxy是一个 Proxy 实例，设置它的a属性会触发set方法。这时，第四个参数receiver就指向原始赋值行为所在的对象b</p>
<h4 id="不可写配置且不可写属性的拦截-1"><a href="#不可写配置且不可写属性的拦截-1" class="headerlink" title="不可写配置且不可写属性的拦截"></a>不可写配置且不可写属性的拦截</h4><pre><code>  const obj = &#123;&#125;;
  Object.defineProperty(obj, &#39;foo&#39;, &#123;
    value: &#39;bar&#39;,
    writable: false,
  &#125;);

  const handler = &#123;
    set: function(obj, prop, value, receiver) &#123;
      obj[prop] = &#39;baz&#39;;
    &#125;
  &#125;;

  const proxy = new Proxy(obj, handler);
</code></pre>
<p>运行结果：</p>
<pre><code>  proxy.foo = &#39;baz&#39;;
  proxy.foo // &quot;bar&quot;
</code></pre>
<p>obj.foo属性不可写，所以代理不生效，并且不会报错</p>
<p><strong>注意，严格模式下，set代理必须返回true，否则就会报错。</strong></p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p>apply方法拦截函数的调用、call和apply操作, apply方法可以接受三个参数:</p>
<pre><code>apply(target, object, args)

- target: 目标对象
- object: 目标对象的上下文对象（this）
- args: 目标对象的参数数组
</code></pre>
<p>拦截 Proxy 实例作为函数调用的操作，比如 proxy(…args)、 proxy.call(object, …args) 、proxy.apply(…)、Reflect.apply(proxy,…)都会被拦截。</p>
<pre><code>const foo=()=&gt;&#123;
  return &#39;I am the target&#39;;
&#125;
const p= new Proxy(foo,&#123;
  apply(target, ctx, args)&#123;
    console.log(target===foo)
    console.log([...args])
    return &quot;I am Proxy apply&quot;
  &#125;
&#125;)
p(1,2,3);
</code></pre>
<p>运行结果：</p>
<pre><code>true
[1, 2, 3]
&quot;I am Proxy apply&quot;
</code></pre>
<h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p>has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。可以接受两个参数，</p>
<pre><code>has(target, propKey)

- target: 目标对象
- propKey: 需查询的属性名
</code></pre>
<p>拦截 propKey in proxy的操作，返回一个布尔值。典型的操作就是in运算符。</p>
<pre><code>var handler = &#123;
  has (target, key) &#123;
    if (key[0] === &#39;_&#39;) &#123;
      return false;
    &#125;
    return key in target;
  &#125;
&#125;;
var target = &#123; _prop: &#39;foo&#39;, prop: &#39;bar&#39; &#125;;
var proxy = new Proxy(target, handler);
&#39;_prop&#39; in proxy; //false
&#39;prop&#39; in proxy;//true
</code></pre>
<p>has方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has方法不判断一个属性是对象自身的属性，还是继承的属性。</p>
<p>虽然for…in循环也用到了in运算符，但是has拦截对for…in循环不生效</p>
<pre><code>for(let k in proxy)&#123;
  console.log(k);
    //_prop
    // prop
&#125;
</code></pre>
<h3 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h3><p>construct方法用于拦截new命令，可以接受两个参数:</p>
<pre><code>construct(target, args)
- target：目标对象
- args：构造函数的参数对象
</code></pre>
<p>拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</p>
<pre><code>var p = new Proxy(function () &#123;&#125;, &#123;
  construct: function(target, args) &#123;
    console.log(&#39;called: &#39; + args.join(&#39;, &#39;));
    return &#123; value: args[0] * 10 &#125;;
  &#125;
&#125;);

(new p(1)).value 
 //called: 1
 // 10
</code></pre>
<p>construct方法返回的必须是一个对象，否则会报错。</p>
<h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><p>deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。</p>
<pre><code>  deleteProperty(target, propKey)
  
  - target：目标对象
  - propKey：要删除的属性名
</code></pre>
<p>删除”_”开头的属性会报错：</p>
<pre><code>  var handler = &#123;
    deleteProperty (target, propKey) &#123;
    if(propKey.match(/^_/))&#123;
      throw new Error(&quot;unable delect &quot;+propKey)
    &#125;else&#123;
      delete target[propKey];
    &#125;
      return true;
    &#125;
  &#125;;
  const person=&#123;
    name:&quot;Tom&quot;,
    _age:&quot;10&quot;
  &#125;
var proxy=new Proxy(person,handler)
delete proxy._age;//报错
</code></pre>
<p>注意，目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错。</p>
<h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h3><blockquote>
<p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象</p>
</blockquote>
<p>defineProperty方法会拦截Object.defineProperty 和 Object.defineProperties操作。返回一个布尔值</p>
<pre><code>defineProperty (target, propKey, descriptor)

- target：目标对象
- propKey：要删除的属性名
- descriptor: 将被定义或修改的属性的描述符，参见Object.defineProperty中的描述符
</code></pre>
<p>例如：</p>
<pre><code>var handler = &#123;
  defineProperty (target, key, descriptor) &#123;
    return false;
  &#125;
&#125;;
var target = &#123;&#125;;
var proxy = new Proxy(target, handler);
proxy.foo = &#39;bar&#39; // 不会生效
</code></pre>
<p>上面代码中，defineProperty方法返回false，导致添加新属性总是无效。</p>
<h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h3><blockquote>
<p>Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）<br>Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符</p>
</blockquote>
<p>getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。</p>
<pre><code>getOwnPropertyDescriptor (target, propKey)

- target：目标对象
- propKey：目标属性名
</code></pre>
<h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h3><blockquote>
<p>Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值</p>
</blockquote>
<p>getPrototypeOf方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。</p>
<pre><code>Object.prototype.__proto__
Object.prototype.isPrototypeOf()
Object.getPrototypeOf()
Reflect.getPrototypeOf()
instanceof
</code></pre>
<p>方法所需参数：<br>    getPrototypeOf (target)</p>
<pre><code>- target：目标对象
</code></pre>
<p>下面是一个例子。</p>
<pre><code>var proto = &#123;&#125;;
var p = new Proxy(&#123;&#125;, &#123;
  getPrototypeOf(target) &#123;
    return proto;
  &#125;
&#125;);
Object.getPrototypeOf(p) === proto // true
</code></pre>
<p>上面代码中，getPrototypeOf方法拦截Object.getPrototypeOf()，返回proto对象。该方法的返回值必须是对象或者null，否则报错。</p>
<h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h3><blockquote>
<p>Object.isExtensible() 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。</p>
</blockquote>
<p>isExtensible方法拦截Object.isExtensible操作</p>
<p>方法所需参数：</p>
<pre><code>isExtensible (target)

- target：目标对象
</code></pre>
<p>举个例子：</p>
<pre><code>var p = new Proxy(&#123;&#125;, &#123;
  isExtensible(target) &#123;
    console.log(&quot;called&quot;);
    return true;
  &#125;
&#125;);

Object.isExtensible(p)
// &quot;called&quot;
// true
</code></pre>
<p>上面代码设置了isExtensible方法，在调用Object.isExtensible时会输出called。</p>
<p>注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。</p>
<p>这个方法有一个强限制，它的返回值必须与目标对象的isExtensible属性保持一致，否则就会抛出错误，即：</p>
<pre><code>Object.isExtensible(proxy) === Object.isExtensible(target);//true
</code></pre>
<h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h3><blockquote>
<p>Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组<br>Object.getOwnPropertySymbols() 方法返回一个给定对象自身的所有 Symbol 属性的数组。<br>Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 。</p>
</blockquote>
<p>ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p>
<pre><code>Object.getOwnPropertyNames()
Object.getOwnPropertySymbols()
Object.keys()
for...in循环
</code></pre>
<p>方法所需参数：</p>
<pre><code>ownKeys (target)

- target：目标对象
</code></pre>
<p>举个例子：</p>
<pre><code>let obj = &#123;
  a: 1,
  b: 2,
  c: 3,
  [Symbol.for(&#39;d&#39;)]:4
&#125;;
var proxy = new Proxy(obj, &#123;
  ownKeys: function(target) &#123;
    return [&#39;a&#39;, &#39;b&#39;, Symbol.for(&#39;d&#39;)];
  &#125;
&#125;);

Object.getOwnPropertyNames(proxy); //[&quot;a&quot;, &quot;b&quot;]
Object.keys(proxy); //[&quot;a&quot;, &quot;b&quot;]
Object.getOwnPropertySymbols(proxy); //[Symbol(d)]
for (let key in proxy) &#123;
  console.log(key); // a // b
&#125;
</code></pre>
<p>注：Symbol 作为属性名，遍历对象的时候，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回，只能通过Object.getOwnPropertySymbols()方法获取。</p>
<h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h3><blockquote>
<p>Object.preventExtensions()方法让一个对象变的不可扩展，也就是永远不能再添加新的属性</p>
</blockquote>
<p>preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。</p>
<pre><code>preventExtensions (target)

- target：目标对象
</code></pre>
<p>例子：</p>
<pre><code>var proxy = new Proxy(&#123;&#125;, &#123;
  preventExtensions: function(target) &#123;
    return true;
  &#125;
&#125;);

Object.preventExtensions(proxy);//报错
</code></pre>
<p>这个方法有一个限制，只有目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true，否则会报错。</p>
<h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h3><blockquote>
<p>Object.setPrototypeOf() 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或  null。</p>
</blockquote>
<p>setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。</p>
<pre><code>setPrototypeOf (target, propKey)

- target：目标对象
- propKey：目标属性名
</code></pre>
<p>修改目标对象的原型：</p>
<pre><code>var handler = &#123;
  setPrototypeOf (target, proto) &#123;
    throw new Error(&#39;Changing the prototype is forbidden&#39;);
  &#125;
&#125;;
var proto = &#123;&#125;;
var target = function () &#123;&#125;;
var proxy = new Proxy(target, handler);
Object.setPrototypeOf(proxy, proto);
// Error: Changing the prototype is forbidden
</code></pre>
<p>只要修改target的原型对象，就会报错；注意，该方法只能返回布尔值，否则会被自动转为布尔值。</p>
<h2 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h2><p>Proxy.revocable方法返回一个可取消的 Proxy 实例。</p>
<pre><code>  let target = &#123;&#125;;
  let handler = &#123;&#125;;

  let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);

  proxy.foo = 123;
  proxy.foo // 123

  revoke();
  proxy.foo // TypeError: Revoked
</code></pre>
<p>Proxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<h2 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h2><p>Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理:</p>
<pre><code>  const target = &#123;
    m: function () &#123;
      console.log(this === proxy);
    &#125;
  &#125;;
  const handler = &#123;&#125;;

  const proxy = new Proxy(target, handler);

  target.m() // false
  proxy.m()  // true
</code></pre>
<h2 id="Reflect-对象"><a href="#Reflect-对象" class="headerlink" title="Reflect 对象"></a>Reflect 对象</h2><p>Reflect对象的设计目的有如下几个：</p>
<ol>
<li><p>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</p>
</li>
<li><p>修改某些Object方法的返回结果，让其变得更合理：</p>
<pre><code>Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误
Reflect.defineProperty(obj, name, desc)则会返回false
</code></pre>
</li>
<li><p>让Object操作都变成函数行为。</p>
<pre><code>const obj=&#123;name:&quot;Jack&quot;&#125;;
// 老写法
name in obj // true
delete obj[name]

 // 新写法
 Reflect.has(obj, &#39;name&#39;) // true
 Reflect.deleteProperty(obj, name);//true
</code></pre>
</li>
<li><p>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法</p>
<pre><code> var loggedObj = new Proxy(obj, &#123;
   get(target, name) &#123;
     console.log(&#39;get&#39;, target, name);
     return Reflect.get(target, name);
   &#125;,
   deleteProperty(target, name) &#123;
     console.log(&#39;delete&#39; + name);
     return Reflect.deleteProperty(target, name);
   &#125;,
   has(target, name) &#123;
     console.log(&#39;has&#39; + name);
     return Reflect.has(target, name);
   &#125;
 &#125;);
 //每一个Proxy对象的拦截操作（get、delete、has），内部都调用对应的Reflect方法，保证原生行为能够正常执行。同时每一个操作输出一行日志。
 //也就是说:无论Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为
</code></pre>
</li>
</ol>
<h2 id="Reflect-静态方法"><a href="#Reflect-静态方法" class="headerlink" title="Reflect 静态方法"></a>Reflect 静态方法</h2><h3 id="Reflect-get"><a href="#Reflect-get" class="headerlink" title="Reflect.get()"></a>Reflect.get()</h3><p>用来读取一个对象的属性：<br>      Reflect.get(target, propKey [, receiver])</p>
<pre><code>  - target：目标对象
  - propKey：目标属性名称
  - receiver：可选，如果propKey的getter函数里面有this值，那么receiver就是这个this所代表的上下文
</code></pre>
<p>例子：</p>
<pre><code>  var myObject = &#123;
    foo: 1,
    bar: 2,
    get baz() &#123;
      return this.foo + this.bar;
    &#125;,
  &#125;;
  Reflect.get(myObject, &#39;foo&#39;);//1
  Reflect.get(myObject, &#39;baz&#39;);//3
  Reflect.get(myObject, &#39;baz&#39;,&#123;foo:5,bar:40&#125;);//45
</code></pre>
<h3 id="Reflect-set"><a href="#Reflect-set" class="headerlink" title="Reflect.set()"></a>Reflect.set()</h3><p>在一个对象身上设置一个属性：</p>
<pre><code>  Reflect.set(target, propKey, value[, receiver])
  
  - target：目标对象
  - propKey：目标属性名称
  - value：要设置的属性值
  - receiver：可选，如果在设置值的时候遇到setter函数，那么receiver值表示的就是setter函数中的this值。这个函数会返回一个Boolean值，表示在目标对象上设置属性是否成功
</code></pre>
<p>例子：</p>
<pre><code>  var myObject=&#123;
    foo: 1,
    set bar(value) &#123;
      return this.foo = value;
    &#125;,
  &#125;
  myObject.foo;//1
  Reflect.set(myObject, &#39;foo&#39;, 2);//true
  myObject.foo;//2
  Reflect.set(myObject, &#39;bar&#39;, 100);//true
  myObject.foo;//100
</code></pre>
<h3 id="Reflect-apply"><a href="#Reflect-apply" class="headerlink" title="Reflect.apply()"></a>Reflect.apply()</h3><p>通过指定的参数列表，来调用函数target，等同于Function.prototype.apply.call(func, thisArg, args)</p>
<pre><code>  Reflect.apply(target, thisArg, args)

  - target：目标函数
  - thisArg：target函数调用的时候绑定的this对象
  - args：函数的参数列表
</code></pre>
<p>一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)，采用Reflect对象可以简化这种操作。</p>
<p>例子：</p>
<pre><code> const ages = [11, 33, 12, 54, 18, 96];

// 旧写法
const youngest = Math.min.apply(Math, ages);
const oldest = Math.max.apply(Math, ages);
const type = Object.prototype.toString.call(youngest);

// 新写法
const youngest = Reflect.apply(Math.min, Math, ages);
const oldest = Reflect.apply(Math.max, Math, ages);
const type = Reflect.apply(Object.prototype.toString, youngest, []);
</code></pre>
<h3 id="Reflect-has"><a href="#Reflect-has" class="headerlink" title="Reflect.has()"></a>Reflect.has()</h3><p>检查一个对象上是否含有特定的属性。Reflect.has方法对应name in obj里面的in运算符。</p>
<pre><code>  Reflect.has(target, propKey)

  - target：目标对象
  - propKey：目标属性
</code></pre>
<p>例子：</p>
<pre><code>  var myObject = &#123;
    foo: 1,
  &#125;;

  // 旧写法
  &#39;foo&#39; in myObject // true

  // 新写法
  Reflect.has(myObject, &#39;foo&#39;) // true
</code></pre>
<p>如果Reflect.has()方法的第一个参数不是对象，会报错。</p>
<h3 id="Reflect-construct-target-args"><a href="#Reflect-construct-target-args" class="headerlink" title="Reflect.construct(target, args)"></a>Reflect.construct(target, args)</h3><p>Reflect.construct方法等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。</p>
<pre><code>  Reflect.construct(target, args)

  - target：运行的目标函数
  - args：调用构造函数传递的参数数组或者伪数组
</code></pre>
<p>例子：</p>
<pre><code>  function Greeting(name) &#123;
    this.name = name;
  &#125;

  // new 的写法
  const instance = new Greeting(&#39;张三&#39;);

  // Reflect.construct 的写法
  const instance = Reflect.construct(Greeting, [&#39;张三&#39;]);
</code></pre>
<h3 id="Reflect-deleteProperty-target-name"><a href="#Reflect-deleteProperty-target-name" class="headerlink" title="Reflect.deleteProperty(target, name)"></a>Reflect.deleteProperty(target, name)</h3><p>用于删除一个对象上的属性，等同于delete obj[name]，用于删除对象的属性。</p>
<pre><code>  Reflect.deleteProperty(target, propKey)

  - target：目标对象
  - propKey：目标属性名称
</code></pre>
<p>例子：</p>
<pre><code>  const myObj = &#123; foo: &#39;bar&#39; &#125;;

  // 旧写法
  delete myObj.foo;

  // 新写法
  Reflect.deleteProperty(myObj, &#39;foo&#39;);
</code></pre>
<p>该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false。  </p>
<p>如果Reflect.deleteProperty()方法的第一个参数不是对象，会报错。</p>
<h3 id="Reflect-defineProperty-target-name-desc"><a href="#Reflect-defineProperty-target-name-desc" class="headerlink" title="Reflect.defineProperty(target, name, desc)"></a>Reflect.defineProperty(target, name, desc)</h3><p>Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。</p>
<pre><code>  Reflect.defineProperty(target, propKey, desc)

  - target：目标对象
  - propKey：目标属性名称
  - desc：将被定义或修改的属性的描述符，参见Object.defineProperty中的描述符
</code></pre>
<p>例子：</p>
<pre><code>    function MyDate() &#123;
      /*…*/
    &#125;

    // 旧写法
    Object.defineProperty(MyDate, &#39;now&#39;, &#123;
      value: () =&gt; Date.now()
    &#125;);

    // 新写法
    Reflect.defineProperty(MyDate, &#39;now&#39;, &#123;
      value: () =&gt; Date.now()
    &#125;);
</code></pre>
<h3 id="Reflect-getOwnPropertyDescriptor"><a href="#Reflect-getOwnPropertyDescriptor" class="headerlink" title="Reflect.getOwnPropertyDescriptor()"></a>Reflect.getOwnPropertyDescriptor()</h3><p>Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。</p>
<pre><code>  Reflect.getOwnPropertyDescriptor(target, propKey)

  - target：目标对象
  - propKey：目标属性
</code></pre>
<p>例子：</p>
<pre><code>  var myObject = &#123;&#125;;
  Object.defineProperty(myObject, &#39;hidden&#39;, &#123;
    value: true,
    enumerable: false,
  &#125;);

  // 旧写法
  var theDescriptor = Object.getOwnPropertyDescriptor(myObject, &#39;hidden&#39;);

  // 新写法
  var theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, &#39;hidden&#39;);
</code></pre>
<h3 id="Reflect-getPrototypeOf-target"><a href="#Reflect-getPrototypeOf-target" class="headerlink" title="Reflect.getPrototypeOf(target)"></a>Reflect.getPrototypeOf(target)</h3><p>用于读取对象的__proto__属性, 等同Object.getPrototypeOf方法，都是返回一个对象的原型</p>
<pre><code>  Reflect.getPrototypeOf(target)

  - target：目标对象
</code></pre>
<p>例子：</p>
<pre><code>const myObj = new FancyThing();

// 旧写法
Object.getPrototypeOf(myObj) === FancyThing.prototype;

// 新写法
Reflect.getPrototypeOf(myObj) === FancyThing.prototype;
</code></pre>
<h3 id="Reflect-isExtensible-target"><a href="#Reflect-isExtensible-target" class="headerlink" title="Reflect.isExtensible(target)"></a>Reflect.isExtensible(target)</h3><p>方法等同Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。</p>
<pre><code>  Reflect.isExtensible(target)

  - target：目标对象
</code></pre>
<p>例子：</p>
<pre><code>  const myObject = &#123;&#125;;

  // 旧写法
  Object.isExtensible(myObject) // true

  // 新写法
  Reflect.isExtensible(myObject) // true
</code></pre>
<h3 id="Reflect-ownKeys-target"><a href="#Reflect-ownKeys-target" class="headerlink" title="Reflect.ownKeys(target)"></a>Reflect.ownKeys(target)</h3><p>用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和</p>
<pre><code>  Reflect.ownKeys(target)

  - target：目标对象
</code></pre>
<p>例子：</p>
<pre><code>  var myObject = &#123;
    foo: 1,
    bar: 2,
    [Symbol.for(&#39;baz&#39;)]: 3,
    [Symbol.for(&#39;bing&#39;)]: 4,
  &#125;;

  // 旧写法
  Object.getOwnPropertyNames(myObject)
  // [&#39;foo&#39;, &#39;bar&#39;]

  Object.getOwnPropertySymbols(myObject)
  //[Symbol(baz), Symbol(bing)]

  // 新写法
  Reflect.ownKeys(myObject)
  // [&#39;foo&#39;, &#39;bar&#39;, Symbol(baz), Symbol(bing)]
  如果Reflect.ownKeys()方法的第一个参数不是对象，会报错。
</code></pre>
<h3 id="Reflect-preventExtensions-target"><a href="#Reflect-preventExtensions-target" class="headerlink" title="Reflect.preventExtensions(target)"></a>Reflect.preventExtensions(target)</h3><p>对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。</p>
<pre><code>  Reflect.preventExtensions(target)

  - target：目标对象
</code></pre>
<p>例子：</p>
<pre><code>  var myObject = &#123;&#125;;

  // 旧写法
  Object.preventExtensions(myObject) // Object &#123;&#125;

  // 新写法
  Reflect.preventExtensions(myObject) // true
</code></pre>
<h3 id="Reflect-setPrototypeOf"><a href="#Reflect-setPrototypeOf" class="headerlink" title="Reflect.setPrototypeOf()"></a>Reflect.setPrototypeOf()</h3><p>用于设置目标对象的原型（prototype），对应Object.setPrototypeOf(obj, newProto)方法。它返回一个布尔值，表示是否设置成功。</p>
<pre><code>  Reflect.setPrototypeOf(target, propKey)

  - target：目标对象，
  - propKey：目标属性
</code></pre>
<p>例子：</p>
<pre><code>  const myObj = &#123;&#125;;

  // 旧写法
  Object.setPrototypeOf(myObj, Array.prototype);

  // 新写法
  Reflect.setPrototypeOf(myObj, Array.prototype);

  myObj.length // 0
</code></pre>
<p>如果无法设置目标对象的原型（比如，目标对象禁止扩展），<code>Reflect.setPrototypeO</code>f方法返回false。</p>
<pre><code>    Reflect.setPrototypeOf(&#123;&#125;, null)
    // true
    Reflect.setPrototypeOf(Object.freeze(&#123;&#125;), null)
    // false
</code></pre>
<p><code>Object.setPrototypeOf</code>与<code>Reflect.setPrototypeOf</code>差异：</p>
<pre><code>    /* 如果第一个参数不是对象，Object.setPrototypeOf会返回第一个参数本身，而Reflect.setPrototypeOf会报错。*/

    Object.setPrototypeOf(1, &#123;&#125;) // 1

    Reflect.setPrototypeOf(1, &#123;&#125;) // TypeError: Reflect.setPrototypeOf called on non-object
    
    
    /* 如果第一个参数是undefined或null，Object.setPrototypeOf和Reflect.setPrototypeOf都会报错。*/

    Object.setPrototypeOf(null, &#123;&#125;) // TypeError: Object.setPrototypeOf called on null or undefined

    Reflect.setPrototypeOf(null, &#123;&#125;) // TypeError: Reflect.setPrototypeOf called on non-object
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/proxy">阮一峰ES6入门</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24778807">知乎专栏-ES6 Reflect</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/50547367">知乎专栏-使用Proxy实现Vue数据劫持</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/javascript/" rel="tag"># javascript</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/ES6%E7%B3%BB%E5%88%97-3-Iterator/" rel="prev" title="ES6系列-3-Iterator">
                  <i class="fa fa-chevron-left"></i> ES6系列-3-Iterator
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/ES6%E7%B3%BB%E5%88%97-5-Class%E4%B8%8EModule/" rel="next" title="ES6系列-5-Class与Module">
                  ES6系列-5-Class与Module <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WMH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://static.wangminghuan.cn/cdn/animejs@3.2.1/anime.min.js"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://static.wangminghuan.cn/cdn/hexo-generator-searchdb/search.js"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
