<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://static.wangminghuan.cn/cdn/fontawesome@5.15.3/all.min.css">
  <link rel="stylesheet" href="https://static.wangminghuan.cn/cdn/animejs@3.2.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{"hostname":"wangminghuan.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

  <meta name="description" content="本篇主要介绍全新的原始数据类型Symbol, 以及ES6新增的数据结构：set与map, 还有对ES6之前数据类型新增了一些扩展方法。">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6系列-2-新增类型与扩展方法">
<meta property="og:url" content="https://wangminghuan.github.io/ES6%E7%B3%BB%E5%88%97-2-%E6%96%B0%E5%A2%9E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/index.html">
<meta property="og:site_name" content="WMH&#39;s Blog">
<meta property="og:description" content="本篇主要介绍全新的原始数据类型Symbol, 以及ES6新增的数据结构：set与map, 还有对ES6之前数据类型新增了一些扩展方法。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wangminghuan.github.io/ES6%E7%B3%BB%E5%88%97-2-%E6%96%B0%E5%A2%9E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/1.png">
<meta property="og:image" content="https://wangminghuan.github.io/ES6%E7%B3%BB%E5%88%97-2-%E6%96%B0%E5%A2%9E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/2.png">
<meta property="og:image" content="https://wangminghuan.github.io/ES6%E7%B3%BB%E5%88%97-2-%E6%96%B0%E5%A2%9E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/3.png">
<meta property="og:image" content="https://wangminghuan.github.io/ES6%E7%B3%BB%E5%88%97-2-%E6%96%B0%E5%A2%9E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/4.png">
<meta property="og:image" content="https://wangminghuan.github.io/ES6%E7%B3%BB%E5%88%97-2-%E6%96%B0%E5%A2%9E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/5.png">
<meta property="article:published_time" content="2019-11-04T11:08:32.000Z">
<meta property="article:modified_time" content="2022-05-17T10:04:10.801Z">
<meta property="article:author" content="WMH">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wangminghuan.github.io/ES6%E7%B3%BB%E5%88%97-2-%E6%96%B0%E5%A2%9E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/1.png">


<link rel="canonical" href="https://wangminghuan.github.io/ES6%E7%B3%BB%E5%88%97-2-%E6%96%B0%E5%A2%9E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://wangminghuan.github.io/ES6%E7%B3%BB%E5%88%97-2-%E6%96%B0%E5%A2%9E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/","path":"ES6系列-2-新增类型与扩展方法/","title":"ES6系列-2-新增类型与扩展方法"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ES6系列-2-新增类型与扩展方法 | WMH's Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">WMH's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-主页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a></li>
        <li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-Symbol"><span class="nav-number">1.</span> <span class="nav-text">第一章  Symbol</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">基本属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7%E5%90%8D"><span class="nav-number">1.2.</span> <span class="nav-text">作为属性名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-set"><span class="nav-number">2.</span> <span class="nav-text">第二章 新的数据结构-set</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">实例的属性和方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7"><span class="nav-number">2.2.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.2.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#weekSet%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.</span> <span class="nav-text">weekSet结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-map"><span class="nav-number">3.</span> <span class="nav-text">第三章 新的数据结构-map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-1"><span class="nav-number">3.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95-1"><span class="nav-number">3.2.</span> <span class="nav-text">实例的属性和方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-1"><span class="nav-number">3.2.2.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.3.</span> <span class="nav-text">与其他数据结构的互相转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#weekMap%E7%BB%93%E6%9E%84"><span class="nav-number">3.4.</span> <span class="nav-text">weekMap结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#WeakMap%E7%BB%93%E6%9E%84%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-number">3.4.1.</span> <span class="nav-text">WeakMap结构的用途</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">第四章 数据类型的扩展方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95"><span class="nav-number">4.1.</span> <span class="nav-text">字符串扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%81%8D%E5%8E%86%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.1.1.</span> <span class="nav-text">字符串的遍历器接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#normalize%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.2.</span> <span class="nav-text">normalize方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#includes-amp-amp-startsWith-amp-amp-endsWith"><span class="nav-number">4.1.3.</span> <span class="nav-text">includes() &amp;&amp; startsWith() &amp;&amp; endsWith()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#repeat%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.4.</span> <span class="nav-text">repeat方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#padStart-amp-amp-padEnd"><span class="nav-number">4.1.5.</span> <span class="nav-text">padStart() &amp;&amp; padEnd()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.1.6.</span> <span class="nav-text">模板字符串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">4.2.</span> <span class="nav-text">数值的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">4.2.1.</span> <span class="nav-text">二进制和八进制表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Number-isFinite-amp-amp-Number-isNaN"><span class="nav-number">4.2.2.</span> <span class="nav-text">Number.isFinite() &amp;&amp; Number.isNaN()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Number-parseInt-Number-parseFloat"><span class="nav-number">4.2.3.</span> <span class="nav-text">Number.parseInt(), Number.parseFloat()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Number-isInteger"><span class="nav-number">4.2.4.</span> <span class="nav-text">Number.isInteger()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Number-isSafeInteger-%E5%92%8C%E5%AE%89%E5%85%A8%E6%95%B4%E6%95%B0"><span class="nav-number">4.2.5.</span> <span class="nav-text">Number.isSafeInteger()和安全整数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MATH-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">4.2.6.</span> <span class="nav-text">MATH 对象的扩展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">4.2.7.</span> <span class="nav-text">指数运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">4.3.</span> <span class="nav-text">数组的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">4.3.1.</span> <span class="nav-text">扩展运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E9%80%94"><span class="nav-number">4.3.1.2.</span> <span class="nav-text">用途</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-from"><span class="nav-number">4.3.2.</span> <span class="nav-text">Array.from</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-of"><span class="nav-number">4.3.3.</span> <span class="nav-text">Array.of</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-copyWithin"><span class="nav-number">4.3.4.</span> <span class="nav-text">数组实例的 copyWithin()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-find-%E5%92%8C-findIndex"><span class="nav-number">4.3.5.</span> <span class="nav-text">数组实例的 find() 和 findIndex()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84fill"><span class="nav-number">4.3.6.</span> <span class="nav-text">数组实例的fill()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-entries-%EF%BC%8Ckeys-%E5%92%8C-values"><span class="nav-number">4.3.7.</span> <span class="nav-text">数组实例的 entries()，keys() 和 values()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-includes"><span class="nav-number">4.3.8.</span> <span class="nav-text">数组实例的 includes()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-flat-%EF%BC%8CflatMap"><span class="nav-number">4.3.9.</span> <span class="nav-text">数组实例的 flat()，flatMap()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%A9%BA%E4%BD%8D"><span class="nav-number">4.3.10.</span> <span class="nav-text">数组的空位</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">4.4.</span> <span class="nav-text">函数的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">4.4.1.</span> <span class="nav-text">函数参数的默认值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-2"><span class="nav-number">4.4.1.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8E%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-number">4.4.1.2.</span> <span class="nav-text">与解构赋值的配合使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84-length-%E5%B1%9E%E6%80%A7"><span class="nav-number">4.4.1.3.</span> <span class="nav-text">函数的 length 属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">4.4.1.4.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-number">4.4.1.5.</span> <span class="nav-text">应用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rest-%E5%8F%82%E6%95%B0"><span class="nav-number">4.4.2.</span> <span class="nav-text">rest 参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.4.3.</span> <span class="nav-text">严格模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#name-%E5%B1%9E%E6%80%A7"><span class="nav-number">4.4.4.</span> <span class="nav-text">name 属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.5.</span> <span class="nav-text">箭头函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">4.4.5.1.</span> <span class="nav-text">使用注意点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E5%86%92%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">4.4.6.</span> <span class="nav-text">双冒号运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">4.5.</span> <span class="nav-text">正则的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RegExp-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">4.5.1.</span> <span class="nav-text">RegExp 构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AD%A3%E5%88%99%E6%96%B9%E6%B3%95"><span class="nav-number">4.5.2.</span> <span class="nav-text">字符串的正则方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">4.5.3.</span> <span class="nav-text">新增修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7"><span class="nav-number">4.5.4.</span> <span class="nav-text">新增属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">4.6.</span> <span class="nav-text">对象的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E7%AE%80%E6%B4%81%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">4.6.1.</span> <span class="nav-text">属性的简洁表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%90%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.6.2.</span> <span class="nav-text">属性名表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84-name-%E5%B1%9E%E6%80%A7"><span class="nav-number">4.6.3.</span> <span class="nav-text">方法的 name 属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%AF%E6%9E%9A%E4%B8%BE%E6%80%A7%E5%92%8C%E9%81%8D%E5%8E%86"><span class="nav-number">4.6.4.</span> <span class="nav-text">属性的可枚举性和遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E6%9E%9A%E4%B8%BE%E6%80%A7"><span class="nav-number">4.6.4.1.</span> <span class="nav-text">可枚举性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">4.6.4.2.</span> <span class="nav-text">属性的遍历</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#super-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">4.6.5.</span> <span class="nav-text">super 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number">4.6.6.</span> <span class="nav-text">解构赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E2%80%A6%EF%BC%89"><span class="nav-number">4.6.7.</span> <span class="nav-text">扩展运算符（…）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">第五章 对象新增方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-is"><span class="nav-number">5.1.</span> <span class="nav-text">Object.is</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-assign"><span class="nav-number">5.2.</span> <span class="nav-text">Object.assign</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">5.2.1.</span> <span class="nav-text">其他注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E9%80%94-1"><span class="nav-number">5.2.2.</span> <span class="nav-text">用途</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-keys"><span class="nav-number">5.3.</span> <span class="nav-text">Object.keys</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-values"><span class="nav-number">5.4.</span> <span class="nav-text">Object.values</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-entries"><span class="nav-number">5.5.</span> <span class="nav-text">Object.entries()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-fromEntries"><span class="nav-number">5.6.</span> <span class="nav-text">Object.fromEntries()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-getOwnPropertyDescriptor"><span class="nav-number">5.7.</span> <span class="nav-text">Object.getOwnPropertyDescriptor()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">5.7.1.</span> <span class="nav-text">作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#proto-%E5%B1%9E%E6%80%A7"><span class="nav-number">5.8.</span> <span class="nav-text">__proto__属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-setPrototypeOf"><span class="nav-number">5.9.</span> <span class="nav-text">Object.setPrototypeOf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-getPrototypeOf"><span class="nav-number">5.10.</span> <span class="nav-text">Object.getPrototypeOf()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="nav-number">6.</span> <span class="nav-text">参考文章</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="WMH"
      src="/images/avatar2.png">
  <p class="site-author-name" itemprop="name">WMH</p>
  <div class="site-description" itemprop="description">just code it</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">101</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/wangminghuan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangminghuan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:m.h.wang@foxmail.com" title="E-Mail → mailto:m.h.wang@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weblog.wangminghuan.cn/" title="WebSite → https:&#x2F;&#x2F;weblog.wangminghuan.cn" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i>WebSite</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/1657970003?topnav=1&wvr=6&topsug=1&is_all=1" title="微博 → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;1657970003?topnav&#x3D;1&amp;wvr&#x3D;6&amp;topsug&#x3D;1&amp;is_all&#x3D;1" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>微博</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wangminghuan.github.io/ES6%E7%B3%BB%E5%88%97-2-%E6%96%B0%E5%A2%9E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.png">
      <meta itemprop="name" content="WMH">
      <meta itemprop="description" content="just code it">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WMH's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ES6系列-2-新增类型与扩展方法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-04 11:08:32" itemprop="dateCreated datePublished" datetime="2019-11-04T11:08:32+00:00">2019-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-17 10:04:10" itemprop="dateModified" datetime="2022-05-17T10:04:10+00:00">2022-05-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ES6%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">ES6系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>本篇主要介绍全新的原始数据类型Symbol, 以及ES6新增的数据结构：set与map, 还有对ES6之前数据类型新增了一些扩展方法。</p>
<span id="more"></span>

<h2 id="第一章-Symbol"><a href="#第一章-Symbol" class="headerlink" title="第一章  Symbol"></a>第一章  Symbol</h2><h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><ol>
<li><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。所以ES6新引入了一种全新的原始数据类型Symbol。</p>
</li>
<li><p>Symbol不是对象，所以不同通过创建对象的方式来创建（譬如 new），它的值通过Symbol函数生成。基本上，它是一种类似于字符串的数据类型。</p>
</li>
<li><p>举个例子</p>
<pre><code> let s1 = Symbol(&#39;foo&#39;);
 let s2 = Symbol(&#39;bar&#39;);
 console.log([s1,s2])//[Symbol(foo), Symbol(bar)]
  //Symbol 值不能与其他类型的值进行运算
 console.log(&quot;s1的值为&quot;+s1) //报错，Cannot convert a Symbol value to a string
 console.log(&quot;s1的值为&quot;+s1.toString()) // s1的值为Symbol(foo)

 let s3 = Symbol();
 let s4 = Symbol();
 console.log(s3===s4);//false ,就算参数相同，symbol函数每次返回的值都是不相等的，这就可以用于对象属性命名上

 let s5=&quot;hello&quot;;
 let s6=&quot;hello&quot;;
 console.log(s5===s6);//true
 
</code></pre>
</li>
</ol>
<h3 id="作为属性名"><a href="#作为属性名" class="headerlink" title="作为属性名"></a>作为属性名</h3><ol>
<li><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，可以防止改写或者覆盖</p>
<pre><code> let symbol1=Symbol(),symbol2=Symbol(),symbol3=Symbol();
 let myObject = &#123; 
     publicProperty: &#39;Value of myObject[ &quot;publicProperty&quot; ]&#39;,
     [symbol1]:&#39;Value of myObject[ symbol1 ]&#39;
 &#125;;
  
 myObject[ symbol2 ] = &#39;value of myObject[ symbol2 ]&#39;;
 Object.defineProperty(myObject, symbol3, &#123; value: &#39;Value of myObject[ symbol1 ]&#39; &#125;);
 console.log(myObject)
</code></pre>
<p><img src="1.png"></p>
</li>
<li><p>Symbol 值作为对象属性名时，不能用点运算符,所以读取该属性时，必须通过<code>myObject[ symbol2 ]</code>来读取。</p>
</li>
<li><p>Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys(</code>)、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回，</p>
</li>
<li><p>可以通过<code>Object.getOwnPropertySymbols</code>来进行读取symbol属性，他返回一个数据</p>
<pre><code> [Symbol(), Symbol(), Symbol()]
</code></pre>
</li>
<li><p>在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
</li>
<li><p>Symbol.for()，Symbol.keyFor()（略）</p>
</li>
</ol>
<h2 id="第二章-新的数据结构-set"><a href="#第二章-新的数据结构-set" class="headerlink" title="第二章 新的数据结构-set"></a>第二章 新的数据结构-set</h2><p>ES6新增了两种数据结构，set结构和map结构：首先介绍一下set结构：</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>Set本身是一个构造函数，用来生成 Set 数据结构。<br>Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。返回的是一个set结构的数据  </p>
<p><img src="2.png">  </p>
<p>可以用作数组和字符串的去重操作:</p>
<pre><code>[...new Set([1,2,3,5,6,7,2,3])] //[1, 2, 3, 5, 6, 7] 数组去重
[...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)// &quot;abc&quot; 字符串去重
Array.from(new Set([1,2,3,5,6,7,2,3])) //[1, 2, 3, 5, 6, 7] Array.from方法也可以将 Set 结构转为数组。
</code></pre>
<h3 id="实例的属性和方法"><a href="#实例的属性和方法" class="headerlink" title="实例的属性和方法"></a>实例的属性和方法</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ol>
<li><p>Set.prototype.constructor：构造函数，默认就是Set函数。</p>
</li>
<li><p>Set.prototype.size：返回Set实例的成员总数。</p>
</li>
</ol>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol>
<li><p>四个操作方法（用于操作数据）</p>
<pre><code> add(value)：添加某个值，返回 Set 结构本身。
 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
 has(value)：返回一个布尔值，表示该值是否为Set的成员。
 clear()：清除所有成员，没有返回值。
</code></pre>
<p>举个例子：</p>
<pre><code> let s = new Set();
 s.add(2).add(&quot;2&quot;).add(1).add(1)
 console.log(s.size)；//3        
 console.log(s.has(&quot;2&quot;));// true
 console.log(s.has(0));// false
 s.delete(2);
 console.log(s.has(2))// false
</code></pre>
</li>
<li><p>四个遍历方法（三个遍历器生成函数和一个遍历方法）。</p>
<pre><code> keys()：返回键名的遍历器
 values()：返回键值的遍历器
 entries()：返回键值对的遍历器
 forEach()：使用回调函数遍历每个成员
</code></pre>
<p>举个例子：需要特别指出的是，Set的遍历顺序就是插入顺序。</p>
<pre><code> let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);
 
 for (let item of set.keys()) &#123;
   console.log(item);
 &#125;
 // red
 // green
 // blue
 
 for (let item of set.values()) &#123;
   console.log(item);
 &#125;
 // red
 // green
 // blue
 
 for (let item of set.entries()) &#123;
   console.log(item);
 &#125;
 // [&quot;red&quot;, &quot;red&quot;]
 // [&quot;green&quot;, &quot;green&quot;]
 // [&quot;blue&quot;, &quot;blue&quot;]

 /////可以省略values方法，直接用for...of循环遍历 Set。

 for (let x of set) &#123;
   console.log(x);
 &#125;
 // red
 // green
 // blue

 set.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value))
 // red : red
 // green : green
 // blue : blue
</code></pre>
</li>
</ol>
<p>扩展运算符（…）内部使用for…of循环，所以也可以用于 Set 结构。相结合后，数组的map和filter方法也可以间接用于 Set 了。</p>
<pre><code>let set = new Set([1, 2, 3, 4, 5]);
set = new Set([...set].filter(x =&gt; (x % 2) == 0));
</code></pre>
<h3 id="weekSet结构"><a href="#weekSet结构" class="headerlink" title="weekSet结构"></a>weekSet结构</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别：</p>
<ol>
<li>WeakSet 的成员只能是对象，而不能是其他类型的值。</li>
<li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用</li>
<li>WeakSet 没有size属性，没有办法遍历它的成员</li>
<li>WeakSet 没有clear方法。</li>
</ol>
<h2 id="第三章-新的数据结构-map"><a href="#第三章-新的数据结构-map" class="headerlink" title="第三章 新的数据结构-map"></a>第三章 新的数据结构-map</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p>
<ol>
<li><p>Map是一个构造函数，创建map对象通过关键字new即可。</p>
</li>
<li><p>Map构造函数参数可以为空，数组或Set,Map等，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。</p>
<pre><code> const m=new Map();
 const s=&#123;p:&quot;hello world&quot;&#125;
 
 m.set(s,&#39;jack&#39;)
 console.log(m.get(s));//&quot;jack&quot;
 console.log(m.has(s));// true
 m.delete(s)
 console.log(m.has(s));// false
 
 //传入一个set结构
 const set = new Set([
   [&#39;foo&#39;, 1],
   [&#39;bar&#39;, 2]
 ]);
 const m1 = new Map(set);
 console.log(m1.get(&#39;foo&#39;)) // 1
 
 //传入一个map结构
 const m2 = new Map([[&#39;baz&#39;, 3]]);
 const m3 = new Map(m2);
 console.log(m3.get(&#39;baz&#39;)) // 3

 //传入一个数组，数组内的元素是键-值对组合的方式（多余的会被忽略，就像例子中的 other），
 const n=new Map([
       [&#39;name&#39;,&quot;lilei&quot;],
       [&#39;age&#39;,24],
       [&#39;sex&#39;,&quot;man&quot;,&#39;other&#39;]
     ]);
 console.log(n.get(&#39;sex&#39;)); //man
 console.log(n);
</code></pre>
<p><img src="3.png"></p>
</li>
<li><p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>
</li>
<li><p>如果读取一个未知的键，则返回undefined。</p>
</li>
<li><p>对于引用类型，只有对同一个对象的引用，Map 结构才将其视为同一个键。</p>
</li>
<li><p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键：</p>
<pre><code> //0和-0就是一个键，布尔值true和字符串true则是两个不同的键。
 //另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。
 let map = new Map();
 
 map.set(-0, 123);
 map.get(+0) // 123
 
 map.set(true, 1);
 map.set(&#39;true&#39;, 2);
 map.get(true) // 1
 
 map.set(undefined, 3);
 map.set(null, 4);
 map.get(undefined) // 3
 
 map.set(NaN, 123);
 map.get(NaN) // 123
</code></pre>
<h3 id="实例的属性和方法-1"><a href="#实例的属性和方法-1" class="headerlink" title="实例的属性和方法"></a>实例的属性和方法</h3><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4></li>
<li><p>size 属性: 返回 Map 结构的成员总数</p>
</li>
</ol>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ol>
<li><p>四个操作方法（用于操作数据）</p>
<pre><code> set(key, value)：设置键名key对应的键值为value,返回是当前的Map对象，因此可以采用链式写法。
 get(key)：读取key对应的键值，如果找不到key，返回undefined。
 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
 has(value)：返回一个布尔值，表示某个键是否在当前 Map 对象之中。
 clear()：清除所有成员，没有返回值。
</code></pre>
<p>举个例子：</p>
<pre><code> const map=new Map();
 const s=&#123;p:&quot;hello world&quot;&#125;
 const o=()=&gt;&#123;console.log(&quot;my function&quot;)&#125;
 map.set(s,&#39;jack&#39;).set(o,&quot;fun&quot;);
 console.log(map.get(o));//fun
 console.log(map.has(s));// true
 map.delete(s);
 console.log(map.size);//1
 map.clear();
 console.log(map.size);//0
</code></pre>
</li>
<li><p>四个遍历方法（三个遍历器生成函数和一个遍历方法）。</p>
<pre><code> keys()：返回键名的遍历器。
 values()：返回键值的遍历器。
 entries()：返回所有成员的遍历器。
 forEach()：遍历 Map 的所有成员。
</code></pre>
<p>举个例子：</p>
<pre><code> const map = new Map([
   [&#39;F&#39;, &#39;no&#39;],
   [&#39;T&#39;,  &#39;yes&#39;],
 ]);
 
 for (let key of map.keys()) &#123;
   console.log(key);
 &#125;
 // &quot;F&quot;
 // &quot;T&quot;
 
 for (let value of map.values()) &#123;
   console.log(value);
 &#125;
 // &quot;no&quot;
 // &quot;yes&quot;
 
 for (let item of map.entries()) &#123;
   console.log(item[0], item[1]);
 &#125;
 // &quot;F&quot; &quot;no&quot;
 // &quot;T&quot; &quot;yes&quot;
 
 // 或者
 for (let [key, value] of map.entries()) &#123;
   console.log(key, value);
 &#125;
 // &quot;F&quot; &quot;no&quot;
 // &quot;T&quot; &quot;yes&quot;
 
 // 等同于使用map.entries() ,也可以省略entries
 for (let [key, value] of map) &#123;
   console.log(key, value);
 &#125;
 // &quot;F&quot; &quot;no&quot;
 // &quot;T&quot; &quot;yes&quot;
 
 //forEach方法
 map.forEach((value, key, map)=&gt; &#123;
   console.log(&quot;Key: %s, Value: %s&quot;, key, value, map);
 &#125;);
</code></pre>
<h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3></li>
<li><p>Map &lt;=&gt; 数组</p>
<pre><code> 1. Map =&gt; 数组
 //（...)运算符将map转换为数组，转换成数组
 //结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）
 const myMap = new Map()
   .set(true, 7)
   .set(&#123;foo: 3&#125;, [&#39;abc&#39;]);
 [...myMap]
 // [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#39;abc&#39; ] ] ]

 2. 数组 =&gt; Map，
 //将数组作为构造函数参数即可

 new Map([
   [true, 7],
   [&#123;foo: 3&#125;, [&#39;abc&#39;]]
 ])
 // Map &#123;
 //   true =&gt; 7,
 //   Object &#123;foo: 3&#125; =&gt; [&#39;abc&#39;]
 // &#125;
</code></pre>
</li>
<li><p>Map &lt;=&gt; 对象</p>
<pre><code> 1. Map =&gt; 对象
 //如果所有 Map 的键都是字符串，它可以无损地转为对象。
 //如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。
 
 function strMapToObj(strMap) &#123;
   let obj = Object.create(null);
   for (let [k,v] of strMap) &#123;
     obj[k] = v;
   &#125;
   return obj;
 &#125;
 
 const myMap = new Map()
   .set(&#39;yes&#39;, true)
   .set(&#39;no&#39;, false);
 strMapToObj(myMap) // &#123; yes: true, no: false &#125;

 2. 对象 =&gt; Map
 function objToStrMap(obj) &#123;
   let strMap = new Map();
   for (let k of Object.keys(obj)) &#123;
     strMap.set(k, obj[k]);
   &#125;
   return strMap;
 &#125;
 
 objToStrMap(&#123;yes: true, no: false&#125;)
 // Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125;
</code></pre>
</li>
<li><p>Map &lt;=&gt; JSON<br>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p>
<pre><code> //Map 的键名都是字符串
 function strMapToJson(strMap) &#123;
   return JSON.stringify(strMapToObj(strMap));
 &#125;
 
 let myMap = new Map().set(&#39;yes&#39;, true).set(&#39;no&#39;, false);
 strMapToJson(myMap)
 // &#39;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#39;

 //Map 的键名有非字符串，这时可以选择转为数组 JSON
 function mapToArrayJson(map) &#123;
   return JSON.stringify([...map]);
 &#125;
 
 let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&#39;abc&#39;]);
 const result=mapToArrayJson(myMap)// &#39;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#39;
 console.log(typeof result);// string
</code></pre>
<p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p>
<pre><code> function jsonToStrMap(jsonStr) &#123;
   return objToStrMap(JSON.parse(jsonStr));
 &#125;
 
 jsonToStrMap(&#39;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&#39;)
 // Map &#123;&#39;yes&#39; =&gt; true, &#39;no&#39; =&gt; false&#125;
</code></pre>
<p>还有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p>
<pre><code> function jsonToMap(jsonStr) &#123;
   return new Map(JSON.parse(jsonStr));
 &#125;
 
 jsonToMap(&#39;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#39;)
 // Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&#39;abc&#39;]&#125;
</code></pre>
</li>
</ol>
<h3 id="weekMap结构"><a href="#weekMap结构" class="headerlink" title="weekMap结构"></a>weekMap结构</h3><p>WeakMap结构与Map结构类似，也是用于生成键值对的集合。但是，它与 Set 有两个区别：</p>
<ol>
<li>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</li>
<li>WeakMap的键名所指向的对象，不计入垃圾回收机制。</li>
</ol>
<h4 id="WeakMap结构的用途"><a href="#WeakMap结构的用途" class="headerlink" title="WeakMap结构的用途"></a>WeakMap结构的用途</h4><p>WeakMap 的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。  </p>
<p>因此，一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。</p>
<pre><code>    const wm = new WeakMap();
    
    const element = document.getElementById(&#39;example&#39;);
    
    wm.set(element, &#39;some information&#39;);
    wm.get(element) // &quot;some information&quot;
</code></pre>
<h2 id="第四章-数据类型的扩展方法"><a href="#第四章-数据类型的扩展方法" class="headerlink" title="第四章 数据类型的扩展方法"></a>第四章 数据类型的扩展方法</h2><h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><h4 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h4><p>ES6 为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历。</p>
<pre><code>for (let codePoint of &#39;foo&#39;) &#123;
  console.log(codePoint)
&#125;
</code></pre>
<h4 id="normalize方法"><a href="#normalize方法" class="headerlink" title="normalize方法"></a>normalize方法</h4><p>ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</p>
<pre><code>&#39;\u01D1&#39;.normalize() === &#39;\u004F\u030C&#39;.normalize()
// true
</code></pre>
<h4 id="includes-amp-amp-startsWith-amp-amp-endsWith"><a href="#includes-amp-amp-startsWith-amp-amp-endsWith" class="headerlink" title="includes() &amp;&amp; startsWith() &amp;&amp; endsWith()"></a>includes() &amp;&amp; startsWith() &amp;&amp; endsWith()</h4><p>ES6 又提供了三种新方法，来确定一个字符串是否包含在另一个字符串中（ES5中只有indexOf）。</p>
<ol>
<li><p>includes()：返回布尔值，表示是否找到了参数字符串。</p>
</li>
<li><p>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</p>
</li>
<li><p>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</p>
<pre><code> let s = &#39;Hello world!&#39;;
 
 s.startsWith(&#39;Hello&#39;) // true
 s.endsWith(&#39;!&#39;) // true
 s.includes(&#39;o&#39;) // true
</code></pre>
<p>这三个方法都支持第二个参数，表示开始搜索的位置。</p>
<pre><code> let s = &#39;Hello world!&#39;;
 
 s.startsWith(&#39;world&#39;, 6) // true 针对第n个位置直到字符串结束
 s.endsWith(&#39;Hello&#39;, 5) // true   针对前n个
 s.includes(&#39;Hello&#39;, 6) // false  针对第n个位置直到字符串结束
</code></pre>
</li>
</ol>
<h4 id="repeat方法"><a href="#repeat方法" class="headerlink" title="repeat方法"></a>repeat方法</h4><p>repeat方法返回一个新字符串，表示将原字符串重复n次。</p>
<pre><code>&#39;x&#39;.repeat(3) // &quot;xxx&quot;
&#39;hello&#39;.repeat(2) // &quot;hellohello&quot;
&#39;na&#39;.repeat(0) // &quot;&quot;
</code></pre>
<h4 id="padStart-amp-amp-padEnd"><a href="#padStart-amp-amp-padEnd" class="headerlink" title="padStart() &amp;&amp; padEnd()"></a>padStart() &amp;&amp; padEnd()</h4><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</p>
<pre><code>&#39;x&#39;.padStart(5, &#39;ab&#39;) // &#39;ababx&#39;
&#39;x&#39;.padEnd(4, &#39;ab&#39;) // &#39;xaba&#39;
&#39;xxx&#39;.padStart(2, &#39;ab&#39;) // &#39;xxx&#39; 等于或大于最大长度，则字符串补全不生效，返回原字符串。
&#39;abc&#39;.padStart(10, &#39;0123456789&#39;) // &#39;0123456abc&#39; 补全字符串与原字符串的长度之和超过了最大长度，则会截去超出位数的补全字符串
&#39;x&#39;.padStart(4) // &#39;   x&#39; 省略第二个参数，默认使用空格补全长度
</code></pre>
<p>padStart()的常见用途是为数值补全指定位数和提示字符串格式。</p>
<pre><code>&#39;123456&#39;.padStart(10, &#39;0&#39;) // &quot;0000123456&quot;
&#39;09-12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-09-12&quot;
</code></pre>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>模板字符串（template string）是增强版的字符串，用反引号 <code>`</code> 标识。</p>
<pre><code>// 普通字符串
`In JavaScript &#39;\n&#39; is a line-feed.`

// 多行字符串
`In JavaScript this is
 not legal.`

// 字符串中嵌入变量
let name = &quot;Bob&quot;, time = &quot;today&quot;;
`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`
&quot;Hello Bob, how are you today?&quot;
</code></pre>
<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。<br>变量名写在${}之中，大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性 ，还可以调用函数。</p>
<pre><code>let x = 1;
let y = 2;

`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`
// &quot;1 + 2 = 3&quot;

`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`
// &quot;1 + 4 = 5&quot;

let obj = &#123;x: 1, y: 2&#125;;
`$&#123;obj.x + obj.y&#125;`

//函数调用
function fn() &#123;
  return &quot;Hello World&quot;;
&#125;

`foo $&#123;fn()&#125; bar`
</code></pre>
<h3 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h3><h4 id="二进制和八进制表示法"><a href="#二进制和八进制表示法" class="headerlink" title="二进制和八进制表示法"></a>二进制和八进制表示法</h4><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示。</p>
<pre><code>0b111110111 === 503 // true
0o767 === 503 // true
</code></pre>
<h4 id="Number-isFinite-amp-amp-Number-isNaN"><a href="#Number-isFinite-amp-amp-Number-isNaN" class="headerlink" title="Number.isFinite() &amp;&amp; Number.isNaN()"></a>Number.isFinite() &amp;&amp; Number.isNaN()</h4><p>ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效：</p>
<p>Number.isFinite()对于非数值一律返回false。<br>Number.isNaN()只有对于NaN才返回true，非NaN一律返回false</p>
<pre><code>isFinite(25) // true
isFinite(&quot;25&quot;) // true
Number.isFinite(25) // true
Number.isFinite(&quot;25&quot;) // false

isNaN(NaN) // true
isNaN(&quot;NaN&quot;) // true
Number.isNaN(NaN) // true
Number.isNaN(&quot;NaN&quot;) // false
Number.isNaN(1) // false

Number.isFinite(Infinity); // false
Number.isFinite(-Infinity); // false
isFinite(Infinity); // false
isFinite(-Infinity); // false
</code></pre>
<h4 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(), Number.parseFloat()"></a>Number.parseInt(), Number.parseFloat()</h4><p>ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。（这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。）</p>
<h4 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h4><p>用来判断一个数值是否为整数。</p>
<pre><code>Number.isInteger(25) // true
Number.isInteger(25.1) // false
Number.isInteger(25.0) // true
</code></pre>
<h4 id="Number-isSafeInteger-和安全整数"><a href="#Number-isSafeInteger-和安全整数" class="headerlink" title="Number.isSafeInteger()和安全整数"></a>Number.isSafeInteger()和安全整数</h4><p>ES6 引入了 <code>Number.MAX_SAFE_INTEGER</code> 和 <code>Number.MIN_SAFE_INTEGER</code> 这两个常量（2^53 和 -2^53），超出这两个常量js就无法精确表示了。Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</p>
<h4 id="MATH-对象的扩展"><a href="#MATH-对象的扩展" class="headerlink" title="MATH 对象的扩展"></a>MATH 对象的扩展</h4><p>ES6 在 Math 对象上新增了 <strong>17</strong> 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。</p>
<ol>
<li><p>Math.trunc 方法用于去除一个数的小数部分，返回整数部分。</p>
<pre><code> Math.trunc(4.1) // 4
 Math.trunc(-4.1) // -4
 Math.trunc(-0.1234) // -0
 
 //对于非数值，Math.trunc内部使用Number方法将其先转为数值
 Math.trunc(&#39;123.456&#39;) // 123
 Math.trunc(true) //1
 Math.trunc(false) // 0
 Math.trunc(null) // 0

 //对于空值和无法截取整数的值，返回NaN。
 Math.trunc(NaN);      // NaN
 Math.trunc(&#39;foo&#39;);    // NaN
 Math.trunc();         // NaN
 Math.trunc(undefined) // NaN
</code></pre>
</li>
<li><p>Math.sign 方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p>
<pre><code> // 它会返回五种值。
 //         参数为正数，返回+1；
 //         参数为负数，返回-1；
 //         参数为 0，返回0；
 //         参数为-0，返回-0;
 //         其他值，返回NaN。

 Math.sign(-5) // -1
 Math.sign(5) // +1
 Math.sign(0) // +0
 Math.sign(-0) // -0
 Math.sign(NaN) // NaN
 Math.sign(&#39;&#39;)  // 0
 Math.sign(true)  // +1
 Math.sign(false)  // 0
 Math.sign(null)  // 0
 Math.sign(&#39;9&#39;)  // +1
 Math.sign(&#39;foo&#39;)  // NaN
 Math.sign()  // NaN
 Math.sign(undefined)  // NaN
</code></pre>
</li>
<li><p>Math.cbrt 方法用于计算一个数的立方根。</p>
<pre><code> Math.cbrt(-1) // -1
 Math.cbrt(0)  // 0
 Math.cbrt(1)  // 1
 Math.cbrt(2)  // 1.2599210498948734
 //对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。
 Math.cbrt(&#39;8&#39;) // 2
 Math.cbrt(&#39;hello&#39;) // NaN
</code></pre>
</li>
<li><p>Math.clz32 方法将参数转为 32 位无符号整数的形式</p>
</li>
<li><p>Math.imul方 法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</p>
</li>
<li><p>Math.fround 方法返回一个数的32位单精度浮点数形式。</p>
</li>
<li><p>Math.hypot 方法返回所有参数的平方和的平方根。</p>
</li>
<li><p>Math.expm1 方法: Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1</p>
</li>
<li><p>Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。</p>
</li>
<li><p>Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。</p>
</li>
<li><p>Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。</p>
</li>
<li><p>Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）</p>
</li>
<li><p>Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）</p>
</li>
<li><p>Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）</p>
</li>
<li><p>Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）</p>
</li>
<li><p>Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）</p>
</li>
<li><p>Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）</p>
</li>
</ol>
<h4 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h4><p>ES2016 新增了一个指数运算符（**）,这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。</p>
<pre><code>2 ** 3 ** 2;// 512   相当于 2 ** (3 ** 2)
</code></pre>
<h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><ol>
<li><p>将一个数组转为用逗号分隔的参数序列。</p>
<pre><code> console.log(...[1, 2, 3])// 1 2 3
 console.log([...[], 1]) //[1]
</code></pre>
</li>
<li><p>主要用于函数调用, 该运算符将一个数组，变为参数序列</p>
<pre><code> function add(x, y) &#123;
   return x + y;
 &#125;
 
 const numbers = [4, 38];
 add(...[4, 38]);//42
</code></pre>
</li>
<li><p>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。</p>
<pre><code> // 在函数后面加上apply就等同于调用执行了函数,apply接受的第一个参数仍是运行函数的作用域，第二个是参数数组
 Math.max.apply(null, [14, 3, 77]);//77
 
 // ES6 的写法
 Math.max(...[14, 3, 77]);//77
 
 // 等同于
 Math.max(14, 3, 77);//77
</code></pre>
<h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5></li>
<li><p>复制数组(浅拷贝)</p>
<pre><code> const a1 = [1, &#123;x:2&#125;];
 // 写法一
 const a2 = [...a1];
 // 写法二
 const [...a2] = a1;
 a1[1].y=3;
 console.log(a1);//[1,&#123;x: 2, y: 3&#125;]
 console.log(a2);//[1,&#123;x: 2, y: 3&#125;] //注意是浅拷贝
</code></pre>
</li>
<li><p>合并数组(浅拷贝，同上)</p>
<pre><code> const arr1 = [&#39;a&#39;, &#39;b&#39;];
 const arr2 = [&#39;c&#39;];
 const arr3 = [&#39;d&#39;, &#39;e&#39;];
 // ES5 的合并数组
 arr1.concat(arr2, arr3);
 // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
 
 // ES6 的合并数组
 [...arr1, ...arr2, ...arr3]
</code></pre>
</li>
<li><p>与解构赋值结合：</p>
<pre><code> const [first, ...rest] = [1, 2, 3, 4, 5];
 //如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。
 const [...butLast, last] = [1, 2, 3, 4, 5]; //报错
</code></pre>
</li>
<li><p>字符串</p>
<pre><code> //扩展运算符还可以将字符串转为真正的数组。
 [...&#39;hello&#39;]
 // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]
</code></pre>
</li>
</ol>
<ol start="5">
<li><p>实现了 Iterator 接口的对象<br>任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组。</p>
<pre><code> let nodeList = document.querySelectorAll(&#39;div&#39;);//得到类数组
 let array = [...nodeList]; //转化成真正数组
</code></pre>
</li>
<li><p>Map 和 Set 结构，Generator 函数<br>只要具有 Iterator 接口的对象，都可以使用扩展运算符：</p>
<pre><code> let map = new Map([
   [1, &#39;one&#39;],
   [2, &#39;two&#39;],
   [3, &#39;three&#39;],
 ]);
 
 let arr = [...map.keys()]; // [1, 2, 3]

 const go = function*()&#123;
   yield 1;
   yield 2;
   yield 3;
 &#125;;
 
 [...go()] // [1, 2, 3]
</code></pre>
</li>
</ol>
<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h4><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）</p>
<h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h4><p>用于将一组值，转换为数组。</p>
<pre><code>Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
</code></pre>
<h4 id="数组实例的-copyWithin"><a href="#数组实例的-copyWithin" class="headerlink" title="数组实例的 copyWithin()"></a>数组实例的 copyWithin()</h4><p>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<pre><code>//Array.prototype.copyWithin(target(必选), start = 0（可选）, end = this.length（可选）)

[1, 2, 3, 4, 5].copyWithin(0, 3);
//[4, 5, 3, 4, 5]
//上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。

// 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4)
// [4, 2, 3, 4, 5]
</code></pre>
<h4 id="数组实例的-find-和-findIndex"><a href="#数组实例的-find-和-findIndex" class="headerlink" title="数组实例的 find() 和 findIndex()"></a>数组实例的 find() 和 findIndex()</h4><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数</p>
<pre><code>[1, 4, -5, 10].find((n) =&gt; n &lt; 0)
</code></pre>
<p>find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<pre><code>[1, 5, 10, 15].find(function(value, index, arr) &#123;
  return value &gt; 9;
&#125;) // 10
</code></pre>
<p>findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>
<pre><code>[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;
  return value &gt; 9;
&#125;) // 2
</code></pre>
<p>这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。</p>
<pre><code>function f(v)&#123;
  return v &gt; this.age;
&#125;
let person = &#123;name: &#39;John&#39;, age: 20&#125;;
[10, 12, 26, 15].find(f, person);    //26
</code></pre>
<h4 id="数组实例的fill"><a href="#数组实例的fill" class="headerlink" title="数组实例的fill()"></a>数组实例的fill()</h4><p>fill方法使用给定值，填充一个数组。用于空数组的初始化非常方便,数组中已有的元素，会被全部抹去。fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<pre><code>new Array(3).fill(7)
// [7, 7, 7]

[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)
// [&#39;a&#39;, 7, &#39;c&#39;]
</code></pre>
<p>如果填充的类型为对象，依旧是浅拷贝。</p>
<h4 id="数组实例的-entries-，keys-和-values"><a href="#数组实例的-entries-，keys-和-values" class="headerlink" title="数组实例的 entries()，keys() 和 values()"></a>数组实例的 entries()，keys() 和 values()</h4><p>ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。可以用for…of循环进行遍历:</p>
<pre><code>//是对键名的遍历
for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) &#123;
  console.log(index);
&#125;
// 0
// 1
//对键值的遍历
for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) &#123;
  console.log(elem);
&#125;
// &#39;a&#39;
// &#39;b&#39;
//对键值对的遍历
for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) &#123;
  console.log(index, elem);
&#125;
// 0 &quot;a&quot;
// 1 &quot;b&quot;
</code></pre>
<h4 id="数组实例的-includes"><a href="#数组实例的-includes" class="headerlink" title="数组实例的 includes()"></a>数组实例的 includes()</h4><p>与字符串的includes方法类似。返回一个布尔值，表示某个数组是否包含给定的值。ES2016 引入了该方法：</p>
<pre><code>[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(3, 3);  // false， 第二个参数表示搜索的起始位置，默认为0。
</code></pre>
<h4 id="数组实例的-flat-，flatMap"><a href="#数组实例的-flat-，flatMap" class="headerlink" title="数组实例的 flat()，flatMap()"></a>数组实例的 flat()，flatMap()</h4><p><code>flat()</code>用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</p>
<pre><code>//flat()默认只会“拉平”一层，接收一个参数表示想要拉平的层数，默认为1。
[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]

[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]
</code></pre>
<p>如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。</p>
<pre><code>[1, [2, [3]]].flat(Infinity)
</code></pre>
<p>flatMap()方法对原数组的每个成员执行一个函数。然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。且只能展开一层数组。</p>
<pre><code>// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) =&gt; [x, x * 2])
// [2, 4, 3, 6, 4, 8]
</code></pre>
<h4 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h4><p>数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。ES6 则是明确将空位转为undefined</p>
<h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><h4 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h4><h5 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h5><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<pre><code>function log(x, y = &#39;World&#39;) &#123;
  console.log(x, y);
&#125;

log(&#39;Hello&#39;) // Hello World
log(&#39;Hello&#39;, &#39;China&#39;) // Hello China
log(&#39;Hello&#39;, &#39;&#39;) // Hello
</code></pre>
<p>这比ES5中的断路运算要好很多，断路运算存在缺点：如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用</p>
<pre><code>function log(x, y) &#123;
  y = y || &#39;World&#39;;
  console.log(x, y);
&#125;
</code></pre>
<p>注意：  </p>
<ol>
<li><p>参数变量是默认声明的，所以不能用let或const再次声明。</p>
<pre><code> function foo(x = 5) &#123;
   let x = 1; // error
   const x = 2; // error
 &#125;
</code></pre>
</li>
<li><p>使用参数默认值时，函数不能有同名参数。</p>
<pre><code> // 不报错
 function foo(x, x, y) &#123;
   // ...
 &#125;
 
 // 报错
 function foo(x, x, y = 1) &#123;
   // ...
 &#125;
</code></pre>
</li>
</ol>
<h5 id="与解构赋值的配合使用"><a href="#与解构赋值的配合使用" class="headerlink" title="与解构赋值的配合使用"></a>与解构赋值的配合使用</h5><pre><code>function foo(&#123;x, y = 5&#125;) &#123;
  console.log(x, y);
&#125;

foo(&#123;&#125;) // undefined 5
foo(&#123;x: 1&#125;) // 1 5
foo(&#123;x: 1, y: 2&#125;) // 1 2
foo() // TypeError: Cannot read property &#39;x&#39; of undefined
</code></pre>
<p>从上面代码中可以看到：如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。为了解决这个问题，我们可以提供函数参数的默认值</p>
<pre><code>function foo(&#123;x, y = 5&#125;=&#123;&#125;) &#123;
  console.log(x, y);
&#125;
foo();//  undefined 5
</code></pre>
<p>对于可以省略的参数，我们可以使用双重默认值。    </p>
<pre><code>function fetch(url, &#123; body = &#39;&#39;, method = &#39;GET&#39;, headers = &#123;&#125; &#125;=&#123;&#125;) &#123;
  console.log(method);
&#125;
fetch(&quot;/test&quot;,&#123;&#125;);//正常
fetch(&quot;/test&quot;);//正常运行，不会报错
</code></pre>
<h5 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h5><p>函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真</p>
<pre><code>(function (a) &#123;&#125;).length // 1
(function (a = 5) &#123;&#125;).length // 0
(function (a, b, c = 5) &#123;&#125;).length // 2
</code></pre>
<h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<pre><code>var x = 1;
function f1(x, y = x) &#123;
  console.log(y);
&#125;

f1(2) // 2
//解释：参数y的默认值等于变量x。调用函数f1时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。

function f2(y = x) &#123;
    let x = 2;
    console.log(y);
  &#125;

f2() // 1
//解释：函数f2调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。
//如果此时，全局变量x不存在，f2就会报错。
</code></pre>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<pre><code>  function throwIfMissing() &#123;
    throw new Error(&#39;Missing parameter&#39;);
  &#125;
  
  function foo(mustBeProvided = throwIfMissing()) &#123;
    return mustBeProvided;
  &#125;
  
  foo() // Error: Missing parameter
</code></pre>
<h4 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h4><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<pre><code>function add(...values) &#123;
  let sum = 0;

  for (var val of values) &#123;
    sum += val;
  &#125;

  return sum;
&#125;

console.log(add(2, 5, 3, 9, 2)); //21
</code></pre>
<p>rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<pre><code>function f(a, ...b, c) &#123;
  // ...
&#125;//报错
</code></pre>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>从 ES5 开始，函数内部可以设定为严格模式。</p>
<pre><code>function doSomething(a, b) &#123;
  &#39;use strict&#39;;
  // code
&#125;
</code></pre>
<p>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<h4 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h4><pre><code>var f = function () &#123;&#125;;
console.log(f.name) // &quot;f&quot; ES5 会返回空

const bar = function baz() &#123;&#125;;
console.log(bar.name) // &quot;baz&quot; ES5和 ES6 返回结果一致

(new Function()).name // &quot;anonymous&quot; 含义为“匿名”
</code></pre>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><pre><code>var sum = (num1, num2) =&gt; num1 + num2;
// 等同于
var sum = function(num1, num2) &#123;
  return num1 + num2;
&#125;
</code></pre>
<p>如果箭头函数中只有一个语句，可以省略return;</p>
<h5 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h5><ol>
<li><p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
</li>
<li><p>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
</li>
<li><p>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
</li>
<li><p>不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</p>
</li>
</ol>
<h4 id="双冒号运算符"><a href="#双冒号运算符" class="headerlink" title="双冒号运算符"></a>双冒号运算符</h4><p>“函数绑定”（function bind）运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。用来取代call、apply、bind调用。</p>
<pre><code>foo::bar;
// 等同于
bar.bind(foo);

foo::bar(...arguments);
// 等同于
bar.apply(foo, arguments);
</code></pre>
<h3 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h3><h4 id="RegExp-构造函数"><a href="#RegExp-构造函数" class="headerlink" title="RegExp 构造函数"></a>RegExp 构造函数</h4><pre><code>var regex = new RegExp(&#39;xyz&#39;, &#39;i&#39;); //写法一
var regex = new RegExp(/xyz/i); //写法二
// 等价于
var regex = /xyz/i;
</code></pre>
<p>但是ES5中不允许这种写法，会报错：</p>
<pre><code>var regex = new RegExp(/xyz/, &#39;i&#39;);
</code></pre>
<p>ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符：</p>
<pre><code>new RegExp(/abc/ig, &#39;i&#39;)
</code></pre>
<h4 id="字符串的正则方法"><a href="#字符串的正则方法" class="headerlink" title="字符串的正则方法"></a>字符串的正则方法</h4><p>字符串对象共有 4 个方法，可以使用正则表达式：<code>match()、replace()、search()和split()</code>。<br>ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</p>
<h4 id="新增修饰符"><a href="#新增修饰符" class="headerlink" title="新增修饰符"></a>新增修饰符</h4><ol>
<li>u修饰符</li>
<li>y 修饰符</li>
<li>s 修饰符</li>
</ol>
<h4 id="新增属性"><a href="#新增属性" class="headerlink" title="新增属性"></a>新增属性</h4><ol>
<li>unicode属性，表示是否设置了u修饰符</li>
<li>sticky 属性，表示是否设置了y修饰符</li>
<li>flags属性，会返回正则表达式的修饰符。</li>
</ol>
<h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><p>对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级</p>
<h4 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h4><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。</p>
<pre><code>const foo = &#39;bar&#39;;
const baz = &#123;foo&#125;;

console.log(baz);//&#123;foo: &quot;bar&quot;&#125;
</code></pre>
<p>ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。</p>
<pre><code>let x=1,y=2;
console.log(&#123;x,y&#125;);//&#123;x: 1, y: 2&#125;
</code></pre>
<p>属性简写，方法也可以简写。</p>
<pre><code>let x=1;
const o = &#123;
  x,
  method() &#123;
    return &quot;Hello!&quot;;
  &#125;
&#125;;
console.log(o.x);//1
console.log(o.method());//&quot;Hello!&quot;
</code></pre>
<p>VUE中组件的ES6写法也是这样：</p>
<pre><code>const VueComponents = &#123;
  data() &#123;
    return &#123;&#125;
  &#125;,
  computed: &#123;
    $target() &#123;
      return null
    &#125;
  &#125;,
  method: &#123;
    handleClick() &#123;
      //...
    &#125;
  &#125;,
  mounted() &#123;&#125;,
  created() &#123;&#125;
&#125;
</code></pre>
<p>CommonJS 模块输出一组变量，就非常合适使用简洁写法：</p>
<pre><code>const getItem= ()=&gt; &#123;&#125;;
const setItem= ()=&gt; &#123;&#125;;
const clear= ()=&gt; &#123;&#125;;
module.exports = &#123; getItem, setItem, clear &#125;;
// 等同于
module.exports = &#123;
  getItem: getItem,
  setItem: setItem,
  clear: clear
&#125;;
</code></pre>
<h4 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h4><p>JavaScript 定义对象的属性，有两种方法。</p>
<pre><code>// 方法一
obj.foo = true;

// 方法二
obj[&#39;a&#39; + &#39;bc&#39;] = 123;
</code></pre>
<p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p>
<pre><code>let propKey = &#39;foo&#39;;

let obj = &#123;
  [propKey]: true,
  [&#39;a&#39; + &#39;bc&#39;]: 123,
  [&#39;h&#39; + &#39;ello&#39;]() &#123;
    return &#39;hi&#39;;
  &#125;
&#125;;
</code></pre>
<p>属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。</p>
<pre><code>const keyA = &#123;a: 1&#125;;
const keyB = &#123;b: 2&#125;;

const myObject = &#123;
  [keyA]: &#39;valueA&#39;,
  [keyB]: &#39;valueB&#39;
&#125;;

myObject // Object &#123;[object Object]: &quot;valueB&quot;&#125;
</code></pre>
<h4 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h4><p>函数的name属性，返回函数名。对象方法也是函数，因此也有name属性</p>
<pre><code>const o = &#123;
  x,
  method() &#123;
    return &quot;Hello!&quot;;
  &#125;
&#125;;
console.log(o.x.name);//undefined
console.log(o.method.name)// method
</code></pre>
<p>bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous</p>
<pre><code>(new Function()).name // &quot;anonymous&quot;

var doSomething = function() &#123;
  // ...
&#125;;
doSomething.bind().name // &quot;bound doSomething&quot;
</code></pre>
<h4 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="headerlink" title="属性的可枚举性和遍历"></a>属性的可枚举性和遍历</h4><h5 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h5><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</p>
<pre><code>let obj = &#123; foo: 123 &#125;;
console.log(Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;))
//  &#123;
//    value: 123,
//    writable: true,
//    enumerable: true,
//    configurable: true
//  &#125;
</code></pre>
<p>描述对象的enumerable属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。<br>目前，有四个操作会忽略enumerable为false的属性。</p>
<ol>
<li>for…in循环：只遍历对象自身的和<strong>继承</strong>的可枚举的属性。</li>
<li>Object.keys()：返回对象自身的所有可枚举的属性的键名。</li>
<li>JSON.stringify()：只串行化对象自身的可枚举的属性。</li>
<li>Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</li>
</ol>
<h5 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h5><p>ES6 一共有 5 种方法可以遍历对象的属性：</p>
<ol>
<li><p>for…in<br>Object.defineProperty</p>
<pre><code> //for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。
</code></pre>
</li>
<li><p>Object.keys(obj)</p>
<pre><code> //Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。
</code></pre>
</li>
<li><p>Object.getOwnPropertyNames(obj)</p>
<pre><code> //Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。
</code></pre>
</li>
<li><p>Object.getOwnPropertySymbols(obj)</p>
<pre><code> //Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。
</code></pre>
</li>
<li><p>Reflect.ownKeys(obj)</p>
<pre><code> //返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举
</code></pre>
<p>举个例子：</p>
<pre><code> const obj=&#123;
   name:&quot;jack&quot;,
   [Symbol()]:&quot;1&quot;
 &#125;
 Object.prototype.age=12;
 Object.defineProperty(obj, &quot;job&quot;, &#123;
     configurable:true,
     value:&quot;teacher&quot;,
     writable:true,
     enumerable:false
 &#125;)
 for(let key in obj)&#123;
   console.log(obj[key]);//&quot;jack&quot;  12
 &#125;
 
 console.log(Object.getOwnPropertyNames(obj));// [&quot;name&quot;, &quot;job&quot;]
 
 console.log(Object.getOwnPropertySymbols(obj));// [Symbol()]
 
 console.log(Reflect.ownKeys(obj));// [&quot;name&quot;, &quot;job&quot;, Symbol()]
</code></pre>
</li>
</ol>
<h4 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h4><p>this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。</p>
<pre><code>const proto = &#123;
  foo: &#39;hello&#39;
&#125;;

const obj = &#123;
  foo: &#39;world&#39;,
  find() &#123;
    return super.foo;
  &#125;
&#125;;

Object.setPrototypeOf(obj, proto);//setPrototypeOf方法设置一个指定的对象的原型到另一个对象
obj.find() // &quot;hello&quot;
</code></pre>
<p>super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。</p>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><pre><code>let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;
x // 1
y // 2
z // &#123; a: 3, b: 4 &#125;
</code></pre>
<p>变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。<br>解构赋值必须是最后一个参数，否则会报错。</p>
<pre><code>let &#123; ...x, y, z &#125; = someObject; // 句法错误
let &#123; x, ...y, ...z &#125; = someObject; // 句法错误
</code></pre>
<h4 id="扩展运算符（…）"><a href="#扩展运算符（…）" class="headerlink" title="扩展运算符（…）"></a>扩展运算符（…）</h4><p>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中（注意，还是浅拷贝）。</p>
<pre><code>const n=&#123;
  a:&#123;name:&quot;jack&quot;&#125;,
  b:2
&#125;
const m=&#123;
  c:3，
  b:4
&#125;
const p=&#123;...n,...m&#125;;

n.a.name=&quot;lilei&quot;;
m.c=&quot;0&quot;;
console.log(p);//a: &#123;name: &quot;lilei&quot;&#125;, b: 4, c: 3&#125; 同名属性后面会覆盖前面的，依旧是浅拷贝
</code></pre>
<p>对象的扩展运算符等同于使用Object.assign()方法（下一章会讲到）。</p>
<h2 id="第五章-对象新增方法"><a href="#第五章-对象新增方法" class="headerlink" title="第五章 对象新增方法"></a>第五章 对象新增方法</h2><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a>Object.is</h3><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，且+0等于-0，因此需要一个新算法来解决这个问题，<code>Object.is</code>接收两个参数，除了刚才提到的两个异常，其他均与<code>===</code>运算符结果一致：</p>
<pre><code>    +0 === -0 //true
    NaN === NaN // false
    
    Object.is(+0, -0) // false
    Object.is(NaN, NaN) // true
</code></pre>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p><code>Object.assign</code>方法用于对象的合并，第一个参数是目标对象，后面的参数都是源对象</p>
<pre><code>const target = &#123; a: 1, b: 1 &#125;;
const source1 = &#123; b: 2, c: 2 &#125;;
const source2 = &#123; c: 3 &#125;;
Object.assign(target,source1,source2);//&#123;a: 1, b: 2, c: 3&#125;
</code></pre>
<p>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 </p>
<ol>
<li><p>如果只有一个参数，如果该参数不是对象，则会先转成对象，然后返回（无法转换null 和 undefined）：</p>
<pre><code> Object.assign(2)
 Object.assign(&quot;2&quot;)
 Object.assign(false)
 Object.assign(undefined) // 报错
 Object.assign(null) // 报错
</code></pre>
</li>
<li><p>如果非对象参数出现在源对象的位置（即非首参数）,无法转成对象的参数，就会跳过（null 和 undefined不会报错）</p>
<pre><code> let obj = &#123;a: 1&#125;;
 Object.assign(obj, undefined) === obj // true
 Object.assign(obj, null) === obj // true
</code></pre>
</li>
<li><p>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）</p>
<pre><code> const v1 = &#39;abc&#39;;
 const v2 = true;
 const v3 = 10;
 
 const obj = Object.assign(&#123;&#125;, v1, v2, v3);
 console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;，只有字符串的包装对象，会产生可枚举属性。
</code></pre>
</li>
<li><p>属性名为 Symbol 值的属性，也会被Object.assign拷贝。</p>
</li>
</ol>
<h4 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h4><ol>
<li><p><code>Object.assign</code>方法实行的是浅拷贝，而不是深拷贝。</p>
</li>
<li><p>对于嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加：</p>
<pre><code> const target = &#123; a: &#123; b: &#39;c&#39;, d: &#39;e&#39; &#125; &#125;
 const source = &#123; a: &#123; b: &#39;hello&#39; &#125; &#125;
 Object.assign(target, source)// &#123; a: &#123; b: &#39;hello&#39; &#125; &#125;
</code></pre>
</li>
<li><p>可以用来处理数组，但是会把数组视为对象</p>
<pre><code>  Object.assign([1, 2, 3], [4, 5])// [4, 5, 3]
</code></pre>
</li>
<li><p>取值函数的处理：<code>Object.assig</code>n只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p>
</li>
</ol>
<h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><ol>
<li><p>为对象添加属性/方法</p>
</li>
<li><p>克隆对象</p>
<pre><code>  const copy1=source;
 const copy2=Object.assign(&#123;&#125;,source);
 source.name=&quot;lilei&quot;;
 console.log(copy1);//&#123;name: &quot;lilei&quot;, sex: &quot;man&quot;&#125;
 console.log(copy2);//&#123;name: &quot;jack&quot;, sex: &quot;man&quot;&#125;
</code></pre>
<p>原始对象拷贝到一个空对象，就得到了原始对象的克隆；不过只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p>
<pre><code> function clone(origin) &#123;
   let originProto = Object.getPrototypeOf(origin);
   return Object.assign(Object.create(originProto), origin);
 &#125;
</code></pre>
</li>
<li><p>合并多个对象</p>
</li>
<li><p>为属性指定默认值</p>
<pre><code> const DEFAULTS = &#123;
   logLevel: 0,
   outputFormat: &#39;html&#39;
 &#125;;
 
 function processContent(options) &#123;
   options = Object.assign(&#123;&#125;, DEFAULTS, options);
 &#125;
</code></pre>
<h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys"></a>Object.keys</h3><p>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。<br>ES2017 引入了跟<code>Object.keys</code>配套的<code>Object.values和Object.entries</code>，作为遍历一个对象的补充手段，供for…of循环使用；</p>
<pre><code> const source=&#123;
       name:&quot;jack&quot;,
       sex:&quot;man&quot;
     &#125;
 console.log(Object.keys(source));//[&quot;name&quot;, &quot;sex&quot;]
</code></pre>
<h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values"></a>Object.values</h3><p>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值：</p>
<pre><code> const source=&#123;
       name:&quot;jack&quot;,
       sex:&quot;man&quot;
     &#125;
 console.log(Object.values(source));//[&quot;jack&quot;, &quot;man&quot;]
</code></pre>
<h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p>返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>
<pre><code>     const source=&#123;
       name:&quot;jack&quot;,
       sex:&quot;man&quot;,
       age:20
     &#125;
 console.log(Object.entries(source));//[[&quot;name&quot;, &quot;jack&quot;],[&quot;sex&quot;, &quot;man&quot;],[&quot;age&quot;, 20]]
</code></pre>
<p>返回值只输出属性名非 Symbol 值的属性：</p>
<pre><code>   const source1=&#123;
       name:&quot;jack&quot;,
       [Symbol()]:&quot;12&quot;
     &#125;
  const source2=&#123;
       [Symbol()]:&quot;12&quot;
     &#125;
 console.log(Object.entries(source1));//[&quot;name&quot;, &quot;jack&quot;]
 console.log(Object.entries(source2));//[]
</code></pre>
<h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h3><p><code>Object.fromEntries()</code>方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。</p>
<pre><code> Object.fromEntries([
     [&quot;name&quot;, &quot;jack&quot;],
     [&quot;sex&quot;, &quot;man&quot;]
 ]);//&#123;name:&quot;jack&quot;,sex:&quot;man&quot;&#125;
</code></pre>
</li>
</ol>
<p>该方法的主要作用是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象</p>
<pre><code>const entries = new Map([
  [&#39;foo&#39;, &#39;bar&#39;],
  [&#39;baz&#39;, 42]
]);

Object.fromEntries(entries)
// &#123; foo: &quot;bar&quot;, baz: 42 &#125;
</code></pre>
<p>ps:截止目前（2019.1.23 chrome和火狐均未实现该方法）</p>
<h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h3><p>ES5 的<code>Object.getOwnPropertyDescriptor()</code>方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了<code>Object.getOwnPropertyDescriptors()</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<pre><code>   const source=&#123;
    name:&quot;jack&quot;,
    sex:&quot;man&quot;,
    _age:18,
    get age()&#123;
        return this._age
    &#125;,
    set age(val)&#123;
        this._age=val&gt;10?10:val;
    &#125;
  &#125;;
console.log(Object.getOwnPropertyDescriptor(source, &#39;sex&#39;));
console.log(Object.getOwnPropertyDescriptors(source))
</code></pre>
<p><img src="4.png"></p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol>
<li><p>解决Object.assign()无法正确拷贝get属性和set属性的问题(主要目的)：</p>
<pre><code> const source=&#123;
     name:&quot;jack&quot;,
     sex:&quot;man&quot;,
     _age:18,
     get age()&#123;
         return this._age
     &#125;,
     set age(val)&#123;
         this._age=val&gt;10?10:val;
     &#125;
   &#125;;
 const target=Object.assign(&#123;&#125;,source);
 console.log(target)
 console.log(Object.getOwnPropertyDescriptor(source, &#39;age&#39;))
 console.log(Object.getOwnPropertyDescriptor(target, &#39;age&#39;))
</code></pre>
<p><img src="5.png"><br>我们可以这样解决：</p>
<pre><code> const source=&#123;
     name:&quot;jack&quot;,
     sex:&quot;man&quot;,
     _age:18,
     get age()&#123;
         return this._age
     &#125;,
     set age(val)&#123;
         this._age=val&gt;10?10:val;
     &#125;
   &#125;;
 const target = &#123;&#125;;
 Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
</code></pre>
</li>
<li><p>是配合Object.create()方法，将对象属性克隆到一个新对象。这属于浅拷贝:</p>
<pre><code> const source=&#123;
     name:&quot;jack&quot;,
     sex:&quot;man&quot;,
     _age:18,
     get age()&#123;
         return this._age
     &#125;,
     set age(val)&#123;
         this._age=val&gt;10?10:val;
     &#125;
   &#125;;
 const clone=(obj)=&gt;Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj))
  source.sex=&quot;women&quot;;
  console.log(clone(source));
   //&#123;name: &quot;jack&quot;, sex: &quot;women&quot;, _age: 18&#125;
</code></pre>
</li>
<li><p>可以实现一个对象继承另一个对象:</p>
<pre><code> const prot=&#123;
     x:1
 &#125;
 const obj = Object.create(
     prot,
     Object.getOwnPropertyDescriptors(&#123;
       foo: 123,
     &#125;)
   );
   console.log(obj.x);//1
   console.log(obj.foo);//123
</code></pre>
</li>
</ol>
<h3 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__属性"></a>__proto__属性</h3><p><code>__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。该属性没有写入 ES6 的正文，而是写入了附录，原因是<code>__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6（<code>__proto__</code>调用的是<code>Object.prototype.__proto__</code>）。简易使用使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p>
<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p>Object.setPrototypeOf方法的作用与<code>__proto__</code>相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法：</p>
<pre><code>let proto = &#123;&#125;;
let obj = &#123; x: 10 &#125;;
Object.setPrototypeOf(obj, proto);

proto.y = 20;
proto.z = 40;

obj.x // 10
obj.y // 20
obj.z // 40
</code></pre>
<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果,但是第一个参数如果是undefined或null，就会报错。</p>
<pre><code>    Object.setPrototypeOf(1, &#123;&#125;) === 1 // true
    Object.setPrototypeOf(&#39;foo&#39;, &#123;&#125;) === &#39;foo&#39; // true
    Object.setPrototypeOf(true, &#123;&#125;) === true // true
</code></pre>
<h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。</p>
<pre><code>    function Obj()&#123;&#125;;
    const newObj=new Obj();
    console.log(Object.getPrototypeOf(newObj)===Obj.prototype);//true
    const prop=&#123;&#125;;
    Object.setPrototypeOf(newObj,prop)
    prop.x=1;
    console.log(newObj.x);//1
    console.log(Object.getPrototypeOf(newObj));//&#123;x: 1&#125;
</code></pre>
<p>如果参数不是对象，会被自动转为对象。如果是undefined或null，就会报错。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/">阮一峰ES6入门</a></li>
<li><a target="_blank" rel="noopener" href="https://my.oschina.net/u/2903254/blog/818796">ES6 的 Symbol 类型及使用案例</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/javascript/" rel="tag"># javascript</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/ES6%E7%B3%BB%E5%88%97-1-%E5%91%BD%E5%90%8D%E4%B8%8E%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/" rel="prev" title="ES6系列-1-命名与解构赋值">
                  <i class="fa fa-chevron-left"></i> ES6系列-1-命名与解构赋值
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/ES6%E7%B3%BB%E5%88%97-3-Iterator/" rel="next" title="ES6系列-3-Iterator">
                  ES6系列-3-Iterator <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WMH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://static.wangminghuan.cn/cdn/animejs@3.2.1/anime.min.js"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://static.wangminghuan.cn/cdn/hexo-generator-searchdb/search.js"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
